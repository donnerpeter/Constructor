package cons2

import cons2.Log.Event

/**
 * @author peter
 */
class Chart {
  final Log log = new Log()
  private final LinkedHashSet<Frame> frames = []
  private final LinkedList<Frame> active = []
  private final LinkedHashSet<Frame> dirty = []
  private final Set<Frame> finished = []
  private final Set<Frame> weak = []

  String presentable() {
    log.presentable()
  }

  void aspectAppeared(Frame host, Construct aspect) {}

  void contextChanged(Frame host, Construct aspect) {}


  List<Frame> frames(boolean includeWeak = false) {
    (frames - weak) as List<Frame>
  }

  List<Frame> usages(Frame f, boolean includeWeak = false, def pattern) {
    frames(includeWeak).findAll { f in it.children && it.ping(false, pattern) }
  }

  Frame construction(int theta = -1, List<Frame> children, Construct... alternatives) {
    registerFrame(new Frame(this, theta, children).addConstructs(alternatives))
  }

  List<Frame> findActive(boolean thematic, def pattern) {
    return active.findAll { it.ping(thematic, pattern) }
  }

  Frame newFrame(Construct... alternatives) {
    registerFrame(new Frame(this, -1).addConstructs(alternatives))
  }

  private Frame registerFrame(Frame frame) {
    frames << frame
    activate(frame)
    frame
  }

  void activate(Frame frame) {
    strengthen(frame)
    active.remove frame
    active.addFirst frame
    dirty.addAll active
  }

  private Frame nextUnprocessed() {
    if (dirty) {
      def first = active.find { it in dirty }
      dirty.remove(first)
      return first
    }
    null
  }

  void update() {
    while (true) {
      def f = nextUnprocessed()
      if (!f) {
        return
      }
      f.initializedAspects.each { Construct c ->
        contextChanged f, c
      }
    }
  }

  void wrapUp() {
    wrapUp(active as Frame[])
  }

  void wrapUp(Frame... frames) {
    Set<Frame> processed = []
    while (true) {
      def f = frames.find { !(it in processed) && !(it in finished) }
      if (!f) {
        break
      }

      if (f.wrapUp()) {
        finished << f
        update()
      }
      processed << f
    }

    active.removeAll finished
    dirty.removeAll finished
  }

  void weaken(Frame f) {
    if (!(f in weak)) {
      doWeaken f
    }
  }

  private void doWeaken(Frame f) {
    weak << f
    active.remove f
    dirty.remove f
    f.strongUsages([]).each { weaken it }
  }

  private void strengthen(Frame frame) {
    if (frame in weak) {
      doStrengthen frame
    }
  }

  private void doStrengthen(Frame frame) {
    weak.remove frame
    frame.children.each { strengthen it }
  }

  void event(Event event) {
    dirty.addAll active
    log.event event
  }
}
