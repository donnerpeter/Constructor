package cons2

import cons2.Log.Event
import cons2.Log.FrameEvent
import cons2.Log.MergeEvent

/**
 * @author peter
 */
class Chart {
  final Log log = new Log()
  private final LinkedHashSet<Frame> frames = []
  private final LinkedList<Frame> active = []
  private final LinkedHashSet<Frame> dirty = []
  private final Set<Frame> finished = []
  private final Set<Frame> weak = []
  private final Language language

  Chart(Language language) {
    this.language = language
  }

  String presentable() {
    log.presentable(['sem', 'wh_focus'])
  }

  void aspectAppeared(Frame host, Aspect aspect) {
    language.aspectAppeared host, aspect, new Update(this)
  }

  List<Frame> frames(boolean includeWeak = false) {
    (frames - weak) as List<Frame>
  }

  List<Frame> usages(Frame f, boolean includeWeak = false, Map<String, Object> pattern) {
    frames(includeWeak).findAll { f in it.children && it.ping(pattern) }
  }

  Frame construction(List<Frame> children, Aspect... alternatives) {
    def frame = registerFrame(new Frame(this, children))
    if (alternatives) {
      frame.enrich(alternatives)
    }
    return frame
  }

  List<Frame> findActive(Map<String, Object> pattern) {
    return active.findAll { it.ping(pattern) }
  }

  Frame newFrame(Aspect... alternatives) {
    def frame = registerFrame(new Frame(this))
    frame.enrich(alternatives)
    return frame
  }

  private Frame registerFrame(Frame frame) {
    frames << frame
    activate(frame)
    frame
  }

  void activate(Frame frame) {
    strengthen(frame)
    active.remove frame
    active.addFirst frame
    dirty.addAll active
  }

  private Frame nextUnprocessed() {
    if (dirty) {
      def first = active.find { it in dirty }
      dirty.remove(first)
      return first
    }
    null
  }

  void update() {
    while (true) {
      def f = nextUnprocessed()
      if (!f) {
        return
      }
      f.initializedAspects.each { Aspect c ->
        language.contextChanged f, c, new Update(this)

        if (c instanceof AnticipatingConstruct) {
          ((AnticipatingConstruct)c).contextChanged f
        }

      }
    }
  }

  void wrapUp() {
    wrapUp(active as Frame[])
  }

  void wrapUp(Frame... frames) {
    Set<Frame> processed = []
    while (true) {
      Frame f = frames.find { !(it in processed) && !(it in finished) }
      if (!f) {
        break
      }

      if (f.chosenAspects.every { language.wrapUp(f, it, new Update(this)) }) {
        finished << f
        update()
      }
      processed << f
    }

    active.removeAll finished
    dirty.removeAll finished
  }

  void merge(Frame loser, Frame into) {
    loser.adopter = into
    frames.remove loser
    active.remove loser
    dirty.remove loser
    log.event new MergeEvent(into, loser)
  }

  void weaken(Frame f) {
    if (!(f in weak)) {
      doWeaken f
    }
  }

  private void doWeaken(Frame f) {
    weak << f
    active.remove f
    dirty.remove f
    log.event new FrameEvent(f, true)
    f.strongUsages().each { weaken it }
  }

  private void strengthen(Frame frame) {
    if (frame in weak) {
      doStrengthen frame
    }
  }

  private void doStrengthen(Frame frame) {
    weak.remove frame
    frame.children.each { strengthen it }
  }

  void event(Event event) {
    allDirty()
    log.event event
  }

  void allDirty() {
    dirty.addAll active
  }

  String phonString() {
    frames.findAll { !it.adopter && it['phon'] }.collect { it['phon'].toString() }.join(" ")
  }
}
