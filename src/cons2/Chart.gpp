package cons2

/**
 * @author peter
 */
class Chart {
  List<Frame> frames = []
  private Map<Frame, IntRange> positions = [:]
  private List<Frame> dirty = []
  private Set<Frame> finished = []

  String presentable() {
    LinkedList<Frame> stack = []
    StringBuilder result = []
    for (f in frames) {
      stack.addFirst f
      result << f.presentable(stack)
      result << "\n"
    }
    result.toString()
  }

  Frame construction(int theta = -1, Frame... children) {
    int start = children.foldLeft(Integer.MAX_VALUE) { Frame child, acc -> Math.min(acc, startOffset(child)) }
    int end = children.foldLeft(Integer.MIN_VALUE) { Frame child, acc -> Math.max(acc, endOffset(child)) }
    registerFrame(new Frame(this, theta, children), start..end)
  }

  List<Frame> findActive(boolean thematic, boolean eager, pattern) {
    return frames.findAll { it.respondsTo(thematic, eager, pattern) }
  }

  int endOffset(Frame f) {
    return positions[f].toInt
  }

  int startOffset(Frame f) {
    return positions[f].fromInt
  }

  Frame newFrame(Range<Integer> position) {
    registerFrame(new Frame(this, -1), position)
  }

  private Frame registerFrame(Frame frame, Range<Integer> position) {
    if (positions.containsKey(frame)) {
      dirty += frames
      return frames.find { it == frame }
    }

    frames << frame
    positions[frame] = position
    dirty += frames
    frame
  }

  private Frame nextUnprocessed() {
    if (dirty) {
      return dirty.remove(0)
    }
    null
  }

  void update() {
    while (true) {
      def f = nextUnprocessed()
      if (!f) {
        return
      }
      f.activate()
    }
  }

  void wrapUp() {
    Set<Frame> processed = []
    while (true) {
      def f = frames.find { !(it in processed) && !(it in finished) }
      if (!f) {
        return
      }

      if (f.wrapUp()) {
        finished << f
      }
      processed << f
    }
  }
}
