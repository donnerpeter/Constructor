package cons2

import cons2.Log.Event
import cons2.Log.FrameEvent
import cons2.Log.MergeEvent

 /**
 * @author peter
 */
class Chart {
  private static Set<String> interestingAspects = [//'syn', 'case', 'theta',
          'sem', 'wh_focus', 'neg']
  static String resultPrefix = "digraph Parse {\n"
  static String resultSuffix = "}"

  final Log log = new Log()
  private final LinkedHashSet<Frame> frames = []
  private final LinkedList<Frame> active = []
  private final Set<Frame> finished = []
  private final Set<Frame> weak = []
  final Language language
  final Map<Frame, Map<String, List<Function2<Frame, Update, Boolean>>>> listeners = [:]

  Chart(Language language) {
    this.language = language
  }

  String presentableLog() {
    log.presentable(interestingAspects)
  }

  String presentableGraph() {
    StringBuilder result = new StringBuilder()
    Map<String, Integer> counters = [:]
    Map<Frame, String> ids = [:]
    def toDraw = interestingFrames()
    toDraw.each { Frame f ->
      String meaningful = f['sem'] ?: ""
      int num = counters.get(meaningful, 0) + 1
      counters[meaningful] = num
      String id = "V_${meaningful}_$num"
      ids[f] = id
      def label = interestingAspects.collect { if (!f[it]) return null else "$it=${f[it]}" }.findAll { it != null }.collect { it.toString() }.join("\\n")
      result.append "$id[label=\"$label\"];\n"
    }

    result.append "\n"
    toDraw.findAll { it.children }.each { Frame f ->
      result.append f.children.collect { "${ids[f]} -> ${ids[it]}" }.join("; ") + ";\n"
    }

    return resultPrefix + result + resultSuffix
  }

  String presentableResult() {
    StringBuilder result = new StringBuilder()
    LinkedList<Frame> stack = []
    List<Frame> frames = interestingFrames() as List
    def i = frames.size()-1
    while (i >= 0) {
      def j = i
      for (c in frames[i].children) {
        j = Math.max(j, frames.indexOf(c))
      }
      if (j > i) {
        frames.add(j, frames.remove(i))
      }
      i = j - 1
    }

    frames.each { Frame f ->
      stack.addFirst f
      String children = f.children.collect { " ^" + stack.indexOf(it) }.join("")

      def aspects = interestingAspects.collect { if (!f[it]) return null else "$it=${f[it]}" }.findAll { it != null }.collect { it.toString() }.join(", ")
      result.append "frame$children: $aspects\n"
    }

    return result
  }

  private Collection<Frame> interestingFrames() {
    return frames.findAll { Frame f -> !(f in weak) && interestingAspects.any { f[it] } }
  }

  List<Frame> frames(boolean includeWeak = false) {
    (frames - weak) as List<Frame>
  }

  List<Frame> usages(Frame f, boolean includeWeak = false, Map<String, Object> pattern) {
    frames(includeWeak).findAll { f in it.children && it.ping(pattern) }
  }

  List<Frame> findActive(Map<String, Object> pattern) {
    return active.findAll { it.ping(pattern) }
  }

  Frame newFrame(List<Frame> children) {
    return registerFrame(new Frame(this, children as Frame[]))
  }

  private Frame registerFrame(Frame frame) {
    frames << frame
    activate(frame)
    frame
  }

  void activate(Frame frame) {
    strengthen(frame)
    active.remove frame
    active.addFirst frame
  }

  void wrapUp() {
    wrapUp(active as Frame[])
  }

  void wrapUp(Frame... frames) {
    Set<Frame> processed = []
    while (true) {
      Frame f = frames.find { !(it in processed) && !(it in finished) }
      if (!f) {
        break
      }

      finished << f
      processed << f
    }

    active.removeAll finished
    listeners.keySet().removeAll(finished)
  }

  void merge(Frame loser, Frame into) {
    def loserUsages = loser.strongUsages([:])
    def winnerUsages = into.strongUsages([:])

    loser.chosenAspects.each {
      into.chosenAs((it.role):it.nicknames)
    }

    loser.adopter = into

    frames.remove loser
    active.remove loser
    listeners.remove loser
    log.event new MergeEvent(into, loser)

    loserUsages.each { u ->
      def mirror = winnerUsages.find { it.children == u.children }
      if (mirror) {
        merge(u, mirror)
      }
    }
  }

  void weaken(Frame f) {
    if (!(f in weak)) {
      doWeaken f
    }
  }

  private void doWeaken(Frame f) {
    weak << f
    active.remove f
    log.event new FrameEvent(f, true)
    f.strongUsages([:]).each { weaken it }
  }

  private void strengthen(Frame frame) {
    if (frame in weak) {
      doStrengthen frame
    }
  }

  private void doStrengthen(Frame frame) {
    weak.remove frame
    frame.children.each { strengthen it }
  }

  void event(Event event) {
    log.event event
  }

  String phonString() {
    def result = new StringBuilder()
    for (frame in frames.findAll { !it.adopter && it['phon'] }) {
      def phon = frame['phon'].toString()
      if (result.length() > 0 && phon != ',') {
        result << " "
      }
      result << phon
    }
    result.toString()
  }
}
