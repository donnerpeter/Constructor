package cons2

 /**
 * @author peter
 */
class English implements Language {
  Inflection infl = new Inflection().
          wholeWord("father", ["syn", "noun"], ["sem", "father"]).
          wholeWord("mother", ["syn", "noun"], ["sem", "mother"]).
          wholeWord("beautiful", ["syn", "adj"], ["sem", "beautiful"]).
          wholeWord("daughter", ["syn", "noun"], ["sem", "daughter"]).
          wholeWord("the", ['syn', 'article']).
          suffix("s", ['syn', 'verb'])

  boolean wrapUp(Frame host, Aspect aspect) {
    true
  }

  SimpleQuery property_host = [[syn:"noun"], [new Aspect("sem", 'property_host')] as Aspect[]]

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.ping('article')) {
      def article = update.newFrame([], new AnticipatingConstruct([syn:"noun"], [syn:"noun"]))
      update.newFrame([article, host], ["syn", "det_noun"])
      return
    }

    findTheta(aspect, host, update)

    if (aspect.ping('adj')) {
      property_host.activate host, update
      return
    }

    if (aspect.role == 'stem') {
      if (aspect.ping('love')) {
        update.enrich(host, ["sem", "love"])
        return
      }
    }

    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update
    }

  }

  void contextChanged(Frame host, Aspect aspect, Update update) {
  }

  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.opponent(syn: 'theta')) {
      def found = host.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], ['syn', 'theta'], ['sem', 'theme'])
      }
      if (!found) {
        update.listen('syn') { verb, upd2 ->
          if (verb.ping(syn: 'verb')) {
            upd2.newFrame([host, verb], ['syn', 'theta'], ['sem', 'experiencer'])
            upd2.wrapUp host
            return true
          }
          return false
        }
      }
    }
  }

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') || it.ping(sem:'HAPPEN') }.each { generateSentence(it, to) }
  }

  private void generateSentence(Frame verb, Chart dst) {
    generateNP(dst, verb.opponent(sem:'experiencer'), true)
    dst.newFrame([], ['phon', verb.ping(sem:'love') ? 'loves' : 'happened'])
    def theme = verb.opponent(sem:'theme')
    if (verb.ping(sem:'love')) {
      generateNP(dst, theme, false)
    } else {
      generatePP(dst, 'to', theme)
    }
    if (verb.ping(time:'PAST')) {
      dst.newFrame([], ['phon', 'today'])
    }
  }

  private void generatePP(Chart dst, String prep, Frame noun) {
    dst.newFrame([], ['phon', prep])
    generateNP dst, noun, false
  }

  private void generateNP(Chart dst, Frame noun, boolean nom) {
    if (noun.ping(sem:'I')) {
      dst.newFrame([], ['phon', nom ? 'I' : 'me'])
      return;
    }

    dst.newFrame([], ['phon', (noun.ping(discourse:'new') ? 'An' : 'the')])
    noun.allOpponents(sem:'property_host').each { generateAdj(dst, it) }
    if (noun.ping(sem:'mother')) {
      dst.newFrame([], ['phon', 'mother'])
    } else if (noun.ping(sem:'daughter')) {
      dst.newFrame([], ['phon', 'daughter'])
    } else if (noun.ping(sem:'father')) {
      dst.newFrame([], ['phon', 'father'])
    } else if (noun.ping(sem:'THING')) {
      dst.newFrame([], ['phon', 'thing'])
    }
  }

  private def generateAdj(Chart dst, Frame adj) {
    if (adj.ping(sem:'beautiful')) {
      dst.newFrame([], ['phon', 'beautiful'])
    }
    else if (adj.ping(sem:'AMAZING')) {
      dst.newFrame([], ['phon', 'amazing'])
    }
  }

}
