package cons2

 /**
 * @author peter
 */
class English implements Language {
  Inflection infl = new Inflection().
          wholeWord("father", syn:"noun", sem:"father").
          wholeWord("mother", syn:"noun", sem:"mother").
          wholeWord("beautiful", syn:"adj", sem:"beautiful").
          wholeWord("daughter", syn:"noun", sem:"daughter").
          wholeWord("the", syn:'article').
          suffix("s", syn:'verb')

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.ping('article')) {
      def mock = update.newFrame([], syn:"noun")
      update.newFrame([mock, host], syn:"det_noun")
      update.anticipate(mock, syn:'noun')
      return
    }

    findTheta(aspect, host, update)

    if (aspect.ping('adj')) {
      update.listen(syn:'noun') { noun, upd2 -> upd2.newFrame([host, noun], sem:'property_host') }
      return
    }

    if (aspect.role == 'stem') {
      if (aspect.ping('love')) {
        update.enrich(host, aspect, sem:"love")
        return
      }
    }

    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update
    }

  }


  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.strongUsages(syn: 'theta')) {
      def found = host.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], syn:'theta', sem:'theme')
      }
      if (!found) {
        update.listen('syn':'verb') { verb, upd2 ->
          upd2.newFrame([host, verb], syn:'theta', sem:'experiencer')
          upd2.wrapUp host
        }
      }
    }
  }

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') || it.ping(sem:'HAPPEN') || it.ping(sem:"START_GO_TO") || it.ping(sem:'degree') }.each { generateSentence(it, to, [:]) }
  }

  private void addWord(Chart dst, String word) {
    dst.newFrame([]).enrich(['phon', word])
  }

  private void generateSentence(Frame verb, Chart dst, Map state) {
    def timeSpecs = verb.allOpponents(sem: 'time')
    def whTimeSpec = timeSpecs.find { it.ping(sem:'WHEN') }
    if (whTimeSpec) {
      addWord dst, "when"
      timeSpecs.remove whTimeSpec
    }

    def subject
    def subjRel = null
    if (verb.ping(sem: 'degree', wh_focus: 'true')) {
      addWord dst, "Great"
      addWord dst, "was"
      subject = verb.children[1]
      generateNP dst, subject, true
    } else {
      subjRel = verb.strongUsages(sem: 'experiencer')[0] ?: verb.strongUsages(sem: 'agent')[0]
      subject = subjRel ? subjRel.children[0] : null
      if (subject != state.generatedSubject) {
        generateNP(dst, subject, true)
      }

      def modifier = verb.opponent(sem: 'mode')
      if (modifier) {
        addWord dst, 'suddenly'
      }

      generateVerbCluster(dst, verb)

      def addressee = verb.opponent(sem: 'addressee')
      if (addressee) {
        generateNP dst, addressee, false
      }

      def theme = verb.opponent(sem: 'theme')
      if (theme) {
        if (verb.ping(sem: 'love')) {
          generateNP(dst, theme, false)
        } else if (verb.ping(sem: 'FORGET')) {
          generateSentence theme, dst, state
        } else if (verb.ping(sem: 'ASK')) {
          if (theme.ping(sem: 'THINK')) {
            addWord dst, 'about'
            generatePossessive theme.opponent(sem: 'experiencer'), dst
            addWord dst, 'opinion'
            addWord dst, 'on'
            generateNP dst, theme.opponent(sem: 'topic'), false
          }
        }
        else {
          generatePP(dst, 'to', theme)
        }
      }
    }

    if (verb.ping(sem: 'HAPPEN', time: 'PAST')) {
      addWord dst, 'today'
    }

    def vpConj = verb.opponent(sem: 'conj_left', false)
    if (vpConj) {
      addWord dst, 'and'
      state.generatedSubject = subject
      generateSentence vpConj.opponent(sem: 'conj_right'), dst, state
    }

    def subjElaboration = subject?.opponent(sem: 'elaboration')
    if (subjElaboration) {
      addWord dst, ','
      generateSentence subjElaboration, dst, state
    }

    if (subjRel?.ping(wh_focus: 'true')) {
      def conj = subject.opponent(sem: 'alternatives')
      if (conj) {
        addWord dst, '-'
        generateNP dst, conj.opponent(sem: 'conj_left'), true
        addWord dst, 'or'
        generateNP dst, conj.opponent(sem: 'conj_right'), true
      }
    }

    if (timeSpecs[0]) {
      addWord dst, ","
      generateSentence timeSpecs[0], dst, state
    }

  }

  private def generateVerbCluster(Chart dst, Frame verb) {
    if (verb.ping(sem: 'COME_SCALARLY')) {
      addWord dst, 'comes'
      def end = verb.opponent(sem: 'scalar_end')['sem'].value
      if (end == 'EARLIER') {
        addWord dst, 'first'
      } else {
        addWord dst, end
      }
      return
    }

    addWord dst, generateVerb(dst, verb)
  }

  private String generateVerb(Chart dst, Frame verb) {
    def sem = verb['sem'].value
    switch (sem) {
      case 'love': return 'loves'
      case 'HAPPEN': return 'happened'
      case 'FORGET': return 'forgot'
      case 'COME_SCALARLY': return 'comes'
      case 'START_GO_TO': return 'went'
      case 'ASK': return 'asked'
      case 'DISCOVER': return 'discovered'
    }
    return sem
  }

  private void generatePP(Chart dst, String prep, Frame noun) {
    addWord dst, prep
    generateNP dst, noun, false
  }

  private void generateNP(Chart dst, Frame noun, boolean nom) {
    if (noun.ping(sem:'I')) {
      addWord dst, nom ? 'I' : 'me'
      return;
    }
    if (noun.ping(sem:'THEY')) {
      addWord dst, nom ? 'they' : 'them'
      return;
    }

    if (noun.ping(sem: 'WHAT')) {
      addWord dst, 'what'
      return
    }

    def sem = noun['sem'].value
    if (sem.startsWith('number')) {
      addWord dst, sem.substring('number'.size())
      return
    }

    generateDeterminer(noun, dst)

    noun.allOpponents(sem:'property_host').each { generateAdj(dst, it) }

    addWord dst, generateNoun(noun)
  }

  private def generateDeterminer(Frame noun, Chart dst) {
    def opponents = noun.allOpponents(sem: 'with_respect_to')
    if (opponents) {
      generatePossessive(opponents[0], dst)
      if (opponents.size() == 2) {
        addWord dst, "and"
        generatePossessive(opponents[1], dst)
      }
      return
    }

    def det = noun.opponent(sem: 'determiner')
    if (det) {
      def sDet = det['sem'].value
      addWord dst, sDet == "THIS" ? "this" : sDet
      return
    }


    addWord dst, noun.ping(discourse: 'new') ? 'An' : 'the'
  }

  private def generatePossessive(Frame whose, Chart dst) {
    if (whose.ping(sem: 'I')) addWord(dst, 'my')
    if (whose.ping(sem: 'THEY')) addWord(dst, 'their')
  }

  private String generateNoun(Frame noun) {
    def sem = noun['sem'].value
    switch (sem) {
      case "mother": return "mother"
      case "daughter": return "daughter"
      case "father": return "father"
      case "THING": return "thing"
      case "NEIGHBOURS": return "neighbors"
      case "MATTER": return "matter"
      case "SURPRISE": return "amazement"
    }
    return sem
  }

  private def generateAdj(Chart dst, Frame adj) {
    if (adj.ping(sem:'beautiful')) {
      addWord dst, 'beautiful'
    }
    else if (adj.ping(sem:'AMAZING')) {
      addWord dst, 'amazing'
    }
  }

}
