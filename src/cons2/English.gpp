package cons2

 /**
 * @author peter
 */
class English implements Language {
  Inflection infl = new Inflection().
          wholeWord("father", ["syn", "noun"], ["sem", "father"]).
          wholeWord("mother", ["syn", "noun"], ["sem", "mother"]).
          wholeWord("beautiful", ["syn", "adj"], ["sem", "beautiful"]).
          wholeWord("daughter", ["syn", "noun"], ["sem", "daughter"]).
          wholeWord("the", ['syn', 'article']).
          suffix("s", ['syn', 'verb'])

  SimpleQuery property_host = [[syn:"noun"], [new Aspect("sem", 'property_host')] as Aspect[]]

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.ping('article')) {
      def mock = update.newFrame([], ['syn', "noun"])
      update.newFrame([mock, host], ["syn", "det_noun"])
      update.anticipate(mock, syn:'noun')
      return
    }

    findTheta(aspect, host, update)

    if (aspect.ping('adj')) {
      property_host.activate host, update
      return
    }

    if (aspect.role == 'stem') {
      if (aspect.ping('love')) {
        update.enrich(host, ["sem", "love"])
        return
      }
    }

    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update
    }

  }


  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.strongUsages(syn: 'theta')) {
      def found = host.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], ['syn', 'theta'], ['sem', 'theme'])
      }
      if (!found) {
        update.listen('syn':'verb') { verb, upd2 ->
          upd2.newFrame([host, verb], ['syn', 'theta'], ['sem', 'experiencer'])
          upd2.wrapUp host
        }
      }
    }
  }

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') || it.ping(sem:'HAPPEN') || it.ping(sem:"START_GO_TO") }.each { generateSentence(it, to, [:]) }
  }

  private void addWord(Chart dst, String word) {
    dst.newFrame([], ['phon', word])
  }

  private void generateSentence(Frame verb, Chart dst, Map state) {
    def subjRel = verb.strongUsages(sem: 'experiencer')[0] ?: verb.strongUsages(sem: 'agent')[0]
    def subject = subjRel.children[0]
    if (subject != state.generatedSubject) {
      generateNP(dst, subject, true)
    }

    def modifier = verb.opponent(sem: 'mode')
    if (modifier) {
      addWord dst, 'suddenly'
    }

    generateVerbCluster(dst, verb)

    def addressee = verb.opponent(sem: 'addressee')
    if (addressee) {
      generateNP dst, addressee, false
    }

    def theme = verb.opponent(sem:'theme')
    if (theme) {
      if (verb.ping(sem:'love')) {
        generateNP(dst, theme, false)
      } else if (verb.ping(sem: 'FORGET')) {
        generateSentence theme, dst, state
      } else if (verb.ping(sem: 'ASK')) {
        if (theme.ping(sem: 'THINK')) {
          addWord dst, 'about'
          generatePossessive theme.opponent(sem: 'experiencer'), dst
          addWord dst, 'opinion'
          addWord dst, 'on'
          generateNP dst, theme.opponent(sem:'topic'), false
        }
      }
      else {
        generatePP(dst, 'to', theme)
      }
    }

    if (verb.ping(sem:'HAPPEN', time:'PAST')) {
      dst.newFrame([], ['phon', 'today'])
    }

    def vpConj = verb.opponent(sem: 'conj_left', false)
    if (vpConj) {
      addWord dst, 'and'
      state.generatedSubject = subject
      generateSentence vpConj.opponent(sem:'conj_right'), dst, state
    }

    def subjElaboration = subject.opponent(sem:'elaboration')
    if (subjElaboration) {
      dst.newFrame([], ['phon', ','])
      generateSentence subjElaboration, dst, state
    }

    if (subjRel.ping(wh_focus: 'true')) {
      def conj = subject.opponent(sem: 'alternatives')
      if (conj) {
        addWord dst, '-'
        generateNP dst, conj.opponent(sem:'conj_left'), true
        addWord dst, 'or'
        generateNP dst, conj.opponent(sem:'conj_right'), true
      }
    }

  }

  private def generateVerbCluster(Chart dst, Frame verb) {
    if (verb.ping(sem: 'COME_SCALARLY')) {
      addWord dst, 'comes'
      def end = verb.opponent(sem: 'scalar_end')['sem'].value
      if (end == 'EARLIER') {
        addWord dst, 'first'
      } else {
        addWord dst, end
      }
      return
    }

    addWord dst, generateVerb(dst, verb)
  }

  private String generateVerb(Chart dst, Frame verb) {
    def sem = verb['sem'].value
    switch (sem) {
      case 'love': return 'loves'
      case 'HAPPEN': return 'happened'
      case 'FORGET': return 'forgot'
      case 'COME_SCALARLY': return 'comes'
      case 'START_GO_TO': return 'went'
      case 'ASK': return 'asked'
    }
    return sem
  }

  private void generatePP(Chart dst, String prep, Frame noun) {
    dst.newFrame([], ['phon', prep])
    generateNP dst, noun, false
  }

  private void generateNP(Chart dst, Frame noun, boolean nom) {
    if (noun.ping(sem:'I')) {
      dst.newFrame([], ['phon', nom ? 'I' : 'me'])
      return;
    }
    if (noun.ping(sem:'THEY')) {
      addWord dst, nom ? 'they' : 'them'
      return;
    }

    if (noun.ping(sem: 'WHAT')) {
      addWord dst, 'what'
      return
    }

    def sem = noun['sem'].value
    if (sem.startsWith('number')) {
      addWord dst, sem.substring('number'.size())
      return
    }

    generateDeterminer(noun, dst)

    noun.allOpponents(sem:'property_host').each { generateAdj(dst, it) }

    addWord dst, generateNoun(noun)
  }

  private def generateDeterminer(Frame noun, Chart dst) {
    def whose = noun.opponent(sem: 'with_respect_to')
    if (whose) {
      generatePossessive(whose, dst)
      return
    }

    def det = noun.opponent(sem: 'determiner')
    if (det) {
      def sDet = det['sem'].value
      addWord dst, sDet == "THIS" ? "this" : sDet
      return
    }


    addWord dst, noun.ping(discourse: 'new') ? 'An' : 'the'
  }

  private def generatePossessive(Frame whose, Chart dst) {
    if (whose.ping(sem: 'I')) addWord(dst, 'my')
    if (whose.ping(sem: 'THEY')) addWord(dst, 'their')
  }

  private String generateNoun(Frame noun) {
    def sem = noun['sem'].value
    switch (sem) {
      case "mother": return "mother"
      case "daughter": return "daughter"
      case "father": return "father"
      case "THING": return "thing"
      case "NEIGHBOURS": return "neighbors"
      case "MATTER": return "matter"
    }
    return sem
  }

  private def generateAdj(Chart dst, Frame adj) {
    if (adj.ping(sem:'beautiful')) {
      dst.newFrame([], ['phon', 'beautiful'])
    }
    else if (adj.ping(sem:'AMAZING')) {
      dst.newFrame([], ['phon', 'amazing'])
    }
  }

}
