package cons2

/**
 * @author peter
 */
class EnglishGenerator {
  Chart dst
  boolean startedSentence
  Aspect generatedSubject

  EnglishGenerator(Chart dst) {
    this.dst = dst
  }

  void generate(Chart from) {
    from.frames().findAll { isMainVerb(it) }.each { generateSentence(it) }
  }

  private boolean isMainVerb(Frame f) {
    // todo abstract main verb concept
    f.ping(sem: 'love') || f.ping(sem: 'HAPPEN') || f.ping(sem: "START_GO_TO") || f.ping(sem: 'degree') || f.ping(sem:'REMEMBER')
  }

  private void addWord(String word) {
    dst.newFrame([]).enrich(['phon', word])
  }

  private void generateSentence(Frame verb) {
    def timeSpecs = verb.allOpponents(sem: 'time')
    def whTimeSpec = timeSpecs.find { it.ping(sem:'WHEN') }
    if (whTimeSpec) {
      addWord "when"
      timeSpecs.remove whTimeSpec
    }

    def subject
    def subjRel = null
    if (verb.ping(sem: 'degree', wh_focus: 'true')) {
      addWord "Great"
      addWord "was"
      subject = verb.children[1]
      generateNP subject, true
      startedSentence = true
    } else {
      subjRel = verb.strongUsages(sem: 'experiencer')[0] ?: verb.strongUsages(sem: 'agent')[0]
      subject = subjRel ? subjRel.children[0] : null
      if (subject['sem'] != generatedSubject) {
        generateNP(subject, true)
      }
      startedSentence = true

      def modifier = verb.opponent(sem: 'mode')
      if (modifier?.ping(sem: 'SUDDENLY')) {
        addWord 'suddenly'
      }

      verb = generateVerbCluster(verb)

      def addressee = verb.opponent(sem: 'addressee')
      if (addressee) {
        generateNP addressee, false
      }

      def theme = verb.opponent(sem: 'theme')
      if (theme) {
        if (hasAccusativeTheme(verb)) {
          generateNP(theme, false)
        } else if (verb.ping(sem: 'FORGET')) {
          generateSentence theme
        } else if (verb.ping(sem: 'DISCOVER')) {
          addWord ','
          addWord 'that'
          generateSentence theme
        } else if (verb.ping(sem: 'ASK')) {
          if (theme.ping(sem: 'THINK')) {
            addWord 'about'
            generatePossessive theme.opponent(sem: 'experiencer')
            addWord 'opinion'
            addWord 'on'
            generateNP theme.opponent(sem: 'topic'), false
          }
        }
        else {
          generatePP('to', theme)
        }
      }
    }

    if (verb.ping(sem: 'HAPPEN', time: 'PAST')) {
      addWord 'today'
    }

    def vpConj = verb.opponent(sem: 'conj_left', false)
    if (vpConj) {
      if (vpConj.ping(sem:'AND') || vpConj.ping(sem:'AND_THEN')) {
        addWord 'and'
      } else {
        addWord ','
        addWord 'but'
      }
      generatedSubject = subject['sem']
      generateSentence vpConj.opponent(sem: 'conj_right')
    }

    def subjElaboration = subject?.opponent(sem: 'elaboration')
    if (subjElaboration) {
      addWord ','
      generateSentence subjElaboration
    }

    if (subjRel?.ping(wh_focus: 'true')) {
      def conj = subject.opponent(sem: 'alternatives')
      if (conj) {
        addWord '-'
        generateNP conj.opponent(sem: 'conj_left'), true
        addWord 'or'
        generateNP conj.opponent(sem: 'conj_right'), true
      }
    }

    if (timeSpecs[0]) {
      addWord ","
      generateSentence timeSpecs[0]
    }

  }

  private boolean hasAccusativeTheme(Frame verb) {
    return verb.ping(sem: 'love') || verb.ping(sem: 'RECALL') || verb.ping(sem:'REMEMBER')
  }

  private Frame generateVerbCluster(Frame verb) {
    if (verb.ping(sem: 'COME_SCALARLY')) {
      addWord 'comes'
      def end = verb.opponent(sem: 'scalar_end')['sem'].value
      if (end == 'EARLIER') {
        addWord 'first'
      } else if (end == 'NEXT') {
        addWord 'next'
      } else {
        addWord end
      }
      return verb
    }

    if (verb.ping(sem: 'CAN')) {
      addWord (verb.ping(neg:'true') ? "couldn't" : "could")
      def main = verb.opponent(sem: 'theme')
      if (main) {
        return generateVerbCluster(main)
      }
      return verb
    }

    addWord generateVerb(verb)
    return verb
  }

  private String generateVerb(Frame verb) {
    def sem = verb['sem'].value
    switch (sem) {
      case 'love': return 'loves'
      case 'HAPPEN': return 'happened'
      case 'FORGET': return 'forgot'
      case 'COME_SCALARLY': return 'comes'
      case 'START_GO_TO': return 'went'
      case 'ASK': return 'asked'
      case 'DISCOVER': return 'discovered'
      case 'RECALL': return 'recall'
      case 'REMEMBER': return 'remember'
    }
    return sem
  }

  private void generatePP(String prep, Frame noun) {
    addWord prep
    generateNP noun, false
  }

  private void generateNP(Frame noun, boolean nom) {
    if (noun.ping(sem:'I')) {
      addWord nom ? 'I' : 'me'
      return;
    }
    if (noun.ping(sem:'THEY')) {
      addWord nom ? (!startedSentence ? 'They' : 'they') : 'them'
      return;
    }

    if (noun.ping(sem: 'WHAT')) {
      addWord 'what'
      return
    }

    if (noun.ping(sem: 'enumeration')) {
      def members = noun.allOpponents(sem: 'member')
      def last = members.size() - 1
      for (i in 0..last) {
        generateNP members[i], nom
        if (i == last) {
          break
        }
        if (i == last - 1) {
          addWord 'and'
        } else {
          addWord ','
        }
      }
      return
    }

    def sem = noun['sem'].value
    if (sem.startsWith('number')) {
      addWord sem.substring('number'.size())
      return
    }

    generateDeterminer(noun)

    noun.allOpponents(sem:'property_host').each { generateAdj(it) }

    if (noun.ping(sem: 'ORDER')) {
      def opponent = noun.opponent(sem: 'with_respect_to')
      if (opponent) {
        addWord generateNoun(opponent)
      }
    }

    addWord generateNoun(noun)
  }

  private def generateDeterminer(Frame noun) {
    List<Frame> opponents = noun.ping(sem: 'SURPRISE') || noun.ping(sem: 'NEIGHBOURS') ? noun.allOpponents(sem: 'with_respect_to') : []
    if (opponents) {
      generatePossessive(opponents[0])
      if (opponents.size() == 2) {
        addWord "and"
        generatePossessive(opponents[1])
      }
      return
    }

    def det = noun.opponent(sem: 'determiner')
    if (det) {
      def sDet = det['sem'].value
      addWord sDet == "THIS" ? "this" : sDet
      return
    }


    addWord noun.ping(discourse: 'new') ? 'An' : 'the'
  }

  private def generatePossessive(Frame whose) {
    if (whose.ping(sem: 'I')) addWord('my')
    if (whose.ping(sem: 'THEY')) addWord('their')
  }

  private String generateNoun(Frame noun) {
    def sem = noun['sem'].value
    switch (sem) {
      case "mother": return "mother"
      case "daughter": return "daughter"
      case "father": return "father"
      case "THING": return "thing"
      case "NEIGHBOURS": return "neighbors"
      case "MATTER": return "matter"
      case "SURPRISE": return "amazement"
      case "ORDER": return "order"
      case "COUNTING": return "counting"
    }
    return sem
  }

  private def generateAdj(Frame adj) {
    if (adj.ping(sem:'beautiful')) {
      addWord 'beautiful'
    }
    else if (adj.ping(sem:'AMAZING')) {
      addWord 'amazing'
    }
  }
}
