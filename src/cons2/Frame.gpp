package cons2

import cons2.Log.AspectEvent
import cons2.Log.FrameEvent

/**
 * @author peter
 */
class Frame {
  Chart chart
  private final Map<String, List<Aspect>> alternatives = [:]
  private final Map<String, Aspect> chosen = [:]
  private final Set<Aspect> initialized = []
  Frame adopter
  Frame[] args

  def Frame(Chart chart, Frame... args) {
    this.chart = chart
    this.args = args
    for (arg in args) {
      assert arg != null
    }
    chart.event(new FrameEvent(this, false))
  }

  List<Frame> getChildren() {
    args.collect { it.resolve() }
  }

  Frame resolve() {
    if (adopter) {
      return adopter.resolve()
    }
    return this
  }

  void removeAlternative(Aspect construct) {
    def role = construct.role
    alternatives[role].remove construct
    setChosen(role,  alternatives[role].size() != 1 ? null : construct)
  }

  void enrich(Aspect... aspects) {
    Map<String, List<Aspect>> byRole = [:]
    aspects.each { aspect ->
      def role = aspect.role
      def existing = alternatives.get(role, [])
      if (aspect in existing && chosen[role] == aspect) {
        return
      }

      existing << aspect
      def values = byRole.get(role, [])
      values << aspect
      //byRole.put(role, values)
    }
    byRole.each { role, values ->
      setChosen(role,  values.size() != 1 ? null : values[0])
    }
  }

  void initializeAspects(Set<Aspect> added) {
    initialized.addAll(added)
  }

  List<Frame> strongUsages(Map<String, Object> pattern) {
    chart.usages(this, false, pattern)
  }

  Frame opponent(Map<String, Object> pattern) {
    allOpponents(pattern)[0]
  }

  List<Frame> allOpponents(Map<String, Object> pattern) {
    return strongUsages(pattern).collect {
      List<Frame> children = it.children
      return children[0] == (Frame)this ? children[1] : children[0]
    }
  }

  boolean findAround(Map<String, Object> pattern, Function1<Frame, Void> action) {
    Frame frame = findAllActiveAround(pattern)[0]
    if (frame) {
      action(frame)
    }
    return frame != null
  }

  List<Frame> findAllActiveAround(Map<String, Object> pattern) {
    def active = chart.findActive(pattern)
    return active - this
  }

  void chosenAs(Map<String, Object> pattern) {
    pattern.each { role, p ->
      def found = strongAlternatives(role).find { it.ping(p) }
      if (found) {
        setChosen(role, found)
      }
    }

  }

  private def setChosen(String role, Aspect cxt) {
    if (chosen[role] == cxt) return

    chosen[role] = cxt
    chart.event(new AspectEvent(this, role, cxt))
  }

  private Aspect findDimension(pattern) {
    for (role in roles) {
      def found = strongAlternatives(role).find { it.ping(pattern) }
      if (found) return found
    }
    return null
  }

  Aspect getAt(String role) {
    return chosen[role] 
  }

  private Collection<String> getRoles() { alternatives.keySet() }

  private List<Aspect> strongAlternatives(String role) {
    return chosen[role] ? [chosen[role]] : alternatives.get(role, [])
  }

  boolean ping(Map<String, Object> pattern) {
    pattern.every { role, p -> strongAlternatives(role).find { it.ping(p) } != null }
  }

  @Override
  String toString() {
    "[" + chosenAspects.collect { it.role + ":" + it }.join(", ") + "]"
  }

  List<Aspect> getChosenAspects() {
    roles.findAll { chosen[it] }.collect { chosen[it] }
  }

  List<Aspect> getInitializedAspects() {
    chosenAspects.findAll { it in initialized }
  }

  void relax() {
    if (chosen['syn']) {
      setChosen('syn', null)
    }
    chart.activate this
  }

}

