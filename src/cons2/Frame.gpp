package cons2

/**
 * @author peter
 */
class Frame {
  Chart chart
  private Map<String, List<Dimension>> allDims = [:]
  private Map<String, Dimension> chosenDims = [:]
  Frame[] children
  private int thematic

  def Frame(Chart chart, thematic, Frame... args) {
    this.chart = chart
    this.thematic = thematic
    this.children = args
  }

  Dimension addAspect(String aspect, String name) {
    def element = new Dimension(name)
    allDims.get(aspect, []) << element
    chosenDims[aspect] = allDims[aspect].size() > 1 ? null : element
    element
  }

  List<Frame> strongUsages(pattern) {
    def outer = this
    return chart.frames.findAll {
      outer in it.children && it.respondsTo(false, false, pattern) }
  }

  Frame findAfter(boolean thematic, boolean eager = true, pattern) {
    return findAllActiveAround(thematic, eager, pattern).find { chart.startOffset(it) >= chart.endOffset(this) }
  }

  Frame findAround(boolean thematic, boolean eager = true, pattern) {
    return findAllActiveAround(thematic, eager, pattern).find { true }
  }

  List<Frame> findAllActiveAround(boolean thematic, boolean eager, pattern) {
    return chart.findActive(thematic, eager, pattern) - this
  }

  Dimension getAt(String aspectName) {
    chosenDims[aspectName]
  }

  List<Frame> getThematicChildren() {
    thematic >= 0 ? [children[thematic]] : []
  }

  void chosenAs(def pattern) {
    respondsTo(false, true, pattern)
  }

  boolean respondsTo(boolean thematic, boolean eager, def pattern) {
    if (thematic) {
      if (strongUsages([]).any { ((Frame) this) in it.thematicChildren }) {
        return false
      }
    }

    if (pattern instanceof List) {
      return pattern.every { respondsTo(thematic, eager, it) }
    }

    for (name in allDims.keySet()) {
      for (a in dimensions(name)) {
        if (a.name == pattern) {
          if (eager) {
            chosenDims[name] = a
          }
          return true
        }
      }
    }
    return false
  }

  private List<Dimension> dimensions(String name) {
    return chosenDims[name] ? [chosenDims[name]] : allDims[name]
  }

  @Override
  String toString() {
    allDims.collect { a, v -> "$a=$v" }.join(";")
  }

  def activate() {
    chosenDims.values().each {
      if (it) {
        it.activate ((Frame) this)
      }
    }
  }

  String presentable(LinkedList<Frame> stack) {
    dimensions("sem").collect { it.name }.join("|") + children.collect { " ^" + stack.indexOf(it) }.join("")
  }

  boolean wrapUp() {
    def syn = chosenDims["syn"]
    return !syn || syn.wrapUp(this)
  }

  void relax() {
    allDims.keySet().each {
      chosenDims[it] = null
    }
  }


  boolean equals(o) {
    if (this.is(o)) return true;
    if (children.size() == 0) return false

    if (!(o instanceof Frame)) return false;

    Frame frame = (Frame) o;

    if (thematic != frame.thematic) return false;
    if (!Arrays.equals(children, frame.children)) return false;

    return true;
  }

  int hashCode() {
    if (children.size() == 0) {
      return super.hashCode()
    }

    int result = Arrays.hashCode(children);
    result = 31 * result + thematic;
    return result;
  }
}

