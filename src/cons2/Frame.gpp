package cons2

 /**
 * @author peter
 */
class Frame {
  Chart chart
  private final Map<String, List<Construct>> alternatives = [:]
  private final Map<String, Construct> chosen = [:]
  private final Set<Construct> initialized = []
  Frame[] children
  private int thematic

  def Frame(Chart chart, int thematic, Frame... args) {
    this.chart = chart
    this.thematic = thematic
    this.children = args
    chart.event([this])
  }

  void removeAlternative(Construct construct) {
    def role = construct.role
    alternatives[role].remove construct
    setChosen(role,  alternatives[role].size() != 1 ? null : construct)
  }

  Frame enrich(Construct... constructs) {
    def adopter = chart.findAdopter(constructs)
    if (adopter) {
      roles.each {
        adopter.addConstructs(alternatives[it] as Construct[])
      }
      chart.weaken this
      adopter
    } else {
      addConstructs(constructs)
      this
    }
  }

  Frame addConstructs(Construct... constructs) {
    Set<String> affectedRoles = []
    constructs.each { construct ->
      def role = construct.role
      affectedRoles << role
      alternatives.get(role, []) << construct
    }
    affectedRoles.each { role ->
      setChosen(role,  alternatives[role].size() != 1 ? null : alternatives[role][0])
      strongAlternatives(role).each {
        it.appeared this
        initialized << it
      }
    }
    this
  }

  List<Frame> strongUsages(pattern) {
    chart.usages(this, false, pattern)
  }

  Frame findAround(boolean thematic, def pattern) {
    return findAllActiveAround(thematic, pattern).find { true }
  }

  List<Frame> findAllActiveAround(boolean thematic, def pattern) {
    return chart.findActive(thematic, pattern) - this
  }

  List<Frame> getThematicChildren() {
    thematic >= 0 ? [children[thematic]] : []
  }

  void chosenAs(def pattern) {
    def found = findDimension(pattern)
    if (found) {
      setChosen(found.role, found)
    }
  }

  def setChosen(String role, Construct cxt) {
    if (chosen[role] == cxt) return

    chosen[role] = cxt
    chart.event([this, role, cxt])
  }

  private Construct findDimension(pattern) {
    for (role in roles) {
      def found = strongAlternatives(role).find { it.ping(pattern) }
      if (found) return found
    }
    return null
  }

  Construct getAt(String role) {
    return chosen[role] 
  }

  private Collection<String> getRoles() { alternatives.keySet() }

  private List<Construct> strongAlternatives(String role) {
    return chosen[role] ? [chosen[role]] : alternatives[role]
  }

  boolean ping(boolean thematic, def pattern) {
    if (thematic && strongUsages([]).any { ((Frame) this) in it.thematicChildren }) {
      return false
    }

    return findDimension(pattern) != null
  }

  @Override
  String toString() {
    strongAlternatives("sem").collect { it.toString() }.join("|")
  }

  def contextChanged() {
    for (role in roles) {
      def main = chosen[role]
      if (main && main in initialized) {
        main.contextChanged this
      }
    }
  }

  String presentable(LinkedList<Frame> stack) {
    toString() + children.collect { " ^" + stack.indexOf(it) }.join("")
  }

  boolean wrapUp() {
    for (role in roles) {
      if (chosen[role] && !chosen[role].wrapUp(this)) {
        return false
      }
    }
    return true
  }

  void relax() {
    chosen.clear()
    chart.activate this
  }


  boolean adopt(Construct[] constructs) {
    return roles.any { role -> chosen[role] && chosen[role].adopt(this, constructs) }
  }

}

