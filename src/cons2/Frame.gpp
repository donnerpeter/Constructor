package cons2

import cons2.Log.AspectEvent
import cons2.Log.FrameEvent

 /**
 * @author peter
 */
class Frame {
  Chart chart
  private final Map<String, List<Aspect>> alternatives = [:]
  private final Map<String, Aspect> chosen = [:]
  private final Map<Aspect, Set<Party>> alliances = [:]
  Frame adopter
  Frame[] args

  def Frame(Chart chart, Frame... args) {
    this.chart = chart
    this.args = args
    for (arg in args) {
      assert arg != null
    }
    chart.event(new FrameEvent(this, false))
  }

  List<Frame> getChildren() {
    args.collect { it.resolve() }
  }

  Frame resolve() {
    if (adopter) {
      return adopter.resolve()
    }
    return this
  }

  void enrich(Aspect... aspects) {
    if (empty) {
      richEnrich([aspects as List])
      return
    }

    def role = roles.find { strongAlternatives(it) }
    def ally = strongAlternatives(role)[0]
    def appended = [ally] + (aspects as List)
    richEnrich([appended])
  }

  List<Aspect> richEnrich(List<List<Aspect>> aspectSets) {
    Map<String, Set<Aspect>> byRole = [:]
    def added = []

    Set<Party> candidates = []

    if (empty) {
      aspectSets.each { aspects ->
        def alliance = new Party(aspects as Set)
        aspects.each { alliances.get(it, [] as Set) << alliance }
        candidates << alliance
      }
    } else {
      Set<Party> olds = []
      Set<Party> fresh = []
      aspectSets.each { aspects ->
        Set<Party> touchedAlliances = []
        aspects.each {
          Set<Party> p = alliances[it]
          if (p) {
            touchedAlliances.addAll(p)
          }
        }
        assert touchedAlliances.size() == 1

        Party oldParty = touchedAlliances.iterator().next()
        def newParty = oldParty.grow(aspects as List)
        olds << oldParty
        fresh << newParty
        candidates << newParty
      }

      alliances.values().each { it.removeAll(olds) }
      fresh.each { party -> party.members.each { alliances.get(it, []) << party } }
    }

    aspectSets.each { aspects ->
      aspects.each { aspect ->
        def role = aspect.role
        def existing = alternatives.get(role, [])
        if (!(aspect in existing)) {
          existing.add(aspect)
          added << aspect
        }
        byRole.get(role, [] as Set) << aspect
      }

    }

    afterElections candidates

    added
  }

  List<Frame> strongUsages(Map<String, Object> pattern) {
    chart.usages(this, false, pattern)
  }

  Frame opponent(Map<String, Object> pattern, boolean arg = true) {
    allOpponents(pattern, arg)[0]
  }

  List<Frame> allOpponents(Map<String, Object> pattern, boolean arg = true) {
    return strongUsages(pattern).findAll { it.children[arg ? 1 : 0] == (Frame) this }.collect {
      List<Frame> children = it.children
      return children[0] == (Frame)this ? children[1] : children[0]
    }
  }

  boolean findAround(Map<String, Object> pattern, Function1<Frame, Void> action) {
    Frame frame = findAllActiveAround(pattern)[0]
    if (frame) {
      action(frame)
    }
    return frame != null
  }

  List<Frame> findAllActiveAround(Map<String, Object> pattern) {
    def active = chart.findActive(pattern)
    return active - this
  }

  void chosenAs(Map<String, Object> pattern) {
    pattern.each { role, p ->
      def found = strongAlternatives(role).find { pingAspect(it, p) }
      if (found) {
        setChosen(role, found)
      }
    }

  }

  private def setChosen(String role, Aspect cxt) {
    if (chosen[role] == cxt) return

    chosen[role] = cxt
    chart.event(new AspectEvent(this, role, cxt))

    if (!cxt) {
      return
    }

    afterElections(alliances[cxt])
  }

  def afterElections(Set<Party> parties) {
    roles.each { r ->
      if (!parties.every { it.hasMember r }) {
        setChosen r, null
        return
      }

      def alts = alternatives[r]
      if (alts) {
        def friends = alts.findAll { a -> parties.any { it.contains(a) } }
        if (friends.size() == 1) {
          setChosen r, friends.iterator().next()
        } else if (!friends || chosen[r] && !(chosen[r] in friends)) {
          setChosen r, null
        }
      }

    }
  }

  private Aspect findDimension(pattern) {
    for (role in roles) {
      def found = strongAlternatives(role).find { pingAspect(it, pattern) }
      if (found) return found
    }
    return null
  }

  Aspect getAt(String role) {
    return chosen[role] 
  }

  private Collection<String> getRoles() { alternatives.keySet() }

  List<Aspect> strongAlternatives(String role) {
    return chosen[role] ? [chosen[role]] : (alternatives[role] ?: [])
  }

  boolean ping(Map<String, Object> pattern) {
    pattern.every { role, p -> strongAlternatives(role).find { pingAspect(it, p) } != null }
  }

  private boolean pingAspect(Aspect aspect, p) {
    p == null || aspect.ping(p)
  }

  @Override
  String toString() {
    "[" + chosenAspects.collect { it as String }.join(", ") + "]"
  }

  List<Aspect> getChosenAspects() {
    roles.collect { strongAlternatives(it) }.flatten()
  }

  boolean isEmpty() {
    alternatives.empty
  }

  void relax() {
    if (alternatives['theta']?.size() > 1) {
      setChosen('theta', null)
      setChosen('sem', null)
    }
    chart.activate this
  }

  private static class Party {
    Set<Aspect> members = []

    Party(Collection<Aspect> members) {
      this.members = members as Set
    }

    boolean hasMember(String role) {
      members.any { it.role == role }
    }

    boolean contains(Aspect a) {
      a in members
    }

    Iterator<Aspect> iterator() {
      members.iterator()
    }

    Party grow(Collection<Aspect> aspects) {
      Set<String> roles = aspects.collect { it.role } as Set
      new Party(members.findAll { !(it.role in roles) } + aspects)
    }

    @Override
    String toString() {
      return "Party:$members"
    }


  }

}

