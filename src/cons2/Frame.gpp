package cons2

/**
 * @author peter
 */
class Frame {
  Chart chart
  private Map<String, List<Element>> allAspects = [:]
  private Map<String, Element> chosenAspects = [:]

  def Frame(chart) {
    this.chart = chart;
  }

  Element addAspect(String aspect, String name, Frame... args) {
    def element = new Element(name, args)
    allAspects.get(aspect, []) << element
    chosenAspects[aspect] = allAspects[aspect].size() > 1 ? null : element
    element
  }

  List<Frame> strongUsages(pattern) {
    def outer = this
    return chart.frames.findAll {
      outer in it.children && it.respondsTo(false, pattern) }
  }

  Frame findAfter(boolean thematic, pattern) {
    return chart.frames.find {  it.respondsTo(thematic, pattern) && chart.startOffset(it) >= chart.endOffset(this) }
  }

  Frame findBefore(boolean thematic, pattern) {
    return chart.frames.find {  it.respondsTo(thematic, pattern) && chart.endOffset(it) <= chart.startOffset(this) }
  }

  Frame findAround(boolean thematic, pattern) {
    return chart.frames.find {  it.respondsTo(thematic, pattern) }
  }

  List<Frame> getChildren() {
    List<Frame> result = []
    for (competitors in allAspects.values()) {
      for (a in competitors) {
        result += a.args as List
      }
    }
    result
  }
  List<Frame> getThematicChildren() {
    List<Frame> result = []
    for (a in chosenAspects.values()) {
      if (a && a.thematic >= 0) {
        result << a.args[a.thematic]
      }
    }
    result
  }

  boolean respondsTo(boolean thematic, pattern) {
    if (thematic) {
      if (strongUsages([]).any { ((Frame) this) in it.thematicChildren }) {
        return false
      }
    }

    if (pattern instanceof List) {
      return pattern.every { respondsTo(thematic, it) }
    }

    for (name in allAspects.keySet()) {
      List<Element> competitors = chosenAspects[name] ? [chosenAspects[name]] : allAspects[name]
      for (a in competitors) {
        if (a.name == pattern) {
          chosenAspects[name] = a
          return true
        }
      }
    }
    return false
  }

  @Override
  String toString() {
    allAspects.collect { a, v -> "$a=$v" }.join(";")
  }


  def activate() {
    chosenAspects.values().each {
      if (it) {
        it.activate ((Frame) this)
      }
    }
  }

  String presentable(LinkedList<Frame> stack) {
    allAspects["sem"].collect { it.presentable(stack) }.join("|")
  }
}

class Element {
  String name
  Frame[] args
  Function1<Frame, Void> action = { }
  int thematic = -1

  def Element(String name, Frame... args) {
    this.name = name
    this.args = args
  }

  Element withAction(Function1<Frame, Void> action) {
    this.action = action
    this
  }

  Element withThematicArgument(int arg) {
    thematic = arg
    this
  }

  void activate(Frame f) {
    action.call(f)
  }

  @Override
  String toString() {
    name
  }

  String presentable(LinkedList<Frame> stack) {
    if (!args) {
      return name
    }
    Reference result = [name]
    args.each {
      result += " ^" + stack.indexOf(it)
    }
    return result.get()
  }
}