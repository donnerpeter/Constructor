package cons2

/**
 * @author peter
 */
class Parser {

  Chart parse(String text) {
    def chart = new Chart()
    def words = text.split(" ")

    int pos = 0
    for (w in words) {
      Range<Integer> range = pos..pos + 1
      if (w == "мать") {
        def frame = chart.findActive(false, false, "noun").find { !it["sem"] }
        if (!frame) {
          frame = chart.newFrame(range)
        }
        frame.addAspect("syn", "noun")
        frame.addAspect("case", "nom")
        frame.addAspect("case", "acc")
        frame.addAspect("sem", "mother")
      }
      if (w == "любит") {
        def frame = chart.newFrame(range)
        frame.addAspect("syn", "verb").withAction { Frame f ->
          if (!f.strongUsages("state_experiencer")) {
            def agent = f.findAround(true, ["noun", "nom"])
            if (agent) {
              f.chart.newFrame(f, agent).addAspect("sem", "state_experiencer", f, agent).withThematicArgument(1)
            }
          }
          if (!f.strongUsages("state_theme")) {
            def agent = f.findAround(true, ["noun", "acc"])
            if (agent) {
              f.chart.newFrame(f, agent).addAspect("sem", "state_theme", f, agent).withThematicArgument(1)
            }
          }
        }.withWrapUp { Frame f ->
          def subjs = f.strongUsages("state_experiencer")
          def objs = f.strongUsages("state_theme")
          if (subjs && objs) {
            return true
          }

          (subjs + objs).each { f.chart.removeFrame(it) }

          subjs.each { it.children.each {it.relax() } }
          objs.each { it.children.each {it.relax() } }

          subjs = f.findAllActiveAround(false, false, ["noun", "nom"])
          objs = f.findAllActiveAround(false, false, ["noun", "acc"])

          if (objs.size() == 1) {
            subjs -= objs
            f.chart.newFrame(objs[0], f).addAspect("sem", "state_theme", f, objs[0]).withThematicArgument(1)
          }
          if (subjs.size() == 1) {
            f.chart.newFrame(subjs[0], f).addAspect("sem", "state_experiencer", f, subjs[0]).withThematicArgument(1)
          }


          return f.strongUsages("state_experiencer") && f.strongUsages("state_theme")
        }
        frame.addAspect("sem", "loves")
      }
      if (w == "дочь") {
        def frame = chart.findActive(false, false, "noun").find { !it["sem"] }
        if (!frame) {
          frame = chart.newFrame(range)
        }
        def oldCase = frame["case"]
        frame.addAspect("syn", "noun")
        frame.addAspect("case", "nom")
        frame.addAspect("case", "acc")
        frame.addAspect("sem", "daughter")
        if (oldCase) {
          frame.respondsTo(false, true, oldCase.name)
        }
      }
      if (w == "красивая") {
        def frame = chart.newFrame(range)
        frame.addAspect("sem", "beautiful").withAction { Frame f ->
          if (!f.strongUsages("property_host")) {
            def host = f.findAfter(false, ["noun", "nom"])
            if (!host) {
              host = f.chart.newFrame(f, f)
              host.addAspect("syn", "noun")
              host.addAspect("case", "nom")
            }
            f.chart.newFrame(f, host).addAspect("sem", "property_host", f, host)
          }
        }
      }
      if (w == "красивую") {
        def frame = chart.newFrame(range)
        frame.addAspect("sem", "beautiful").withAction { Frame f ->
          if (!f.strongUsages("property_host")) {
            def host = f.findAfter(false, ["noun", "acc"])
            if (host) {
              f.chart.newFrame(f, host).addAspect("sem", "property_host", f, host)
            }
          }
        }
      }
      if (w == "отец") {
        def frame = chart.newFrame(pos..pos+1)
        frame.addAspect("syn", "noun")
        frame.addAspect("case", "nom")
        frame.addAspect("sem", "father")
      }
      if (w == "отца") {
        def frame = chart.newFrame(pos..pos+1)
        frame.addAspect("syn", "noun")
        frame.addAspect("case", "acc")
        frame.addAspect("sem", "father")
      }



      chart.update()
      pos++
    }

    chart.wrapUp()


    return chart
  }


}
