package cons2

/**
 * @author peter
 */
class Russian implements Language {
  Inflection infl = new Inflection().
          wholeWord("мать", syn:"noun", case:'nom', sem:"mother").
          wholeWord("мать", syn:"noun", case:'acc', sem:"mother").
          wholeWord("дочь", syn:"noun", case:'nom', sem:"daughter").
          wholeWord("дочь", syn:"noun", case:'acc', sem:"daughter").
          wholeWord("отец", syn:"noun", case:'nom', sem:"father").
          wholeWord("отца", syn:"noun", case:'acc', sem:"father").
          wholeWord("поводу", syn:"noun", case:'dat', sem:"MATTER").
          wholeWord("их", syn:"noun", case:"acc", sem:"THEY").
          wholeWord("их", syn:"genitive", sem:"THEY").
          wholeWord("они", syn:"noun", case:'nom', sem:"THEY").
          wholeWord("случай", syn:"noun", case:'nom', sem:"THING", discourse:'new').
          wholeWord("соседям", syn:"noun", case:'dat', sem:"NEIGHBOURS", discourse:'new').
          wholeWord("удивление", syn:"noun", case:'nom', sem:"SURPRISE", discourse:'new').
          wholeWord("порядок", syn:"noun", case:'nom', sem:"ORDER", discourse:'given').
          wholeWord("порядок", syn:"noun", case:'acc', sem:"ORDER", discourse:'given').
          wholeWord("магазин", syn:"noun", case:'nom', sem:"SHOP", discourse:'given').
          wholeWord("магазин", syn:"noun", case:'acc', sem:"SHOP", discourse:'given').
          wholeWord("счета", syn:"noun", case:'gen', sem:"COUNTING", discourse:'new').
          wholeWord("углу", syn:"noun", case:'prep', sem:"CORNER", discourse:'given').
          wholeWord("улицы", syn:"noun", case:'gen', sem:"STREET", discourse:'given').
          wholeWord("улицы", syn:"noun", case:'nom', sem:"STREET", discourse:'given').

          wholeWord("случился", syn:"verb", agr:'masc', baseForm:'случиться', sem:'HAPPEN', time:'PAST').
          wholeWord("отправился", syn:"verb", agr:'masc', baseForm:'отправиться', sem:'START_GO_TO', time:'PAST').
          wholeWord("спросил", syn:"verb", agr:'masc', baseForm:'спросить', subcat_acc:'true', subcat_whq:'true', sem:'ASK', time:'PAST').
          wholeWord("помнит", syn:"verb", agr:'masc', baseForm:'помнить', subcat_acc:'true', sem:'REMEMBER', time:'PRESENT').
          wholeWord("помнят", syn:"verb", agr:'pl', baseForm:'помнить', subcat_acc:'true', sem:'REMEMBER', time:'PRESENT').
          wholeWord("забыл", syn:"verb", agr:'masc', baseForm:'забыть', subcat_whq:'true', sem:'FORGET', time:'PERFECT').
          wholeWord("забыл", syn:"verb", agr:'masc', baseForm:'забыть', subcat_acc:'true', sem:'FORGET', time:'PERFECT').
          wholeWord("забыла", syn:"verb", agr:'fem', baseForm:'забыть', subcat_acc:'true', sem:'FORGET', time:'PERFECT').
          wholeWord("забыли", syn:"verb", agr:'pl', baseForm:'забыть', subcat_acc:'true', sem:'FORGET', time:'PERFECT').
          wholeWord("думают", syn:"verb", agr:'pl', baseForm:'думать', subcat_acc:'true', sem:'THINK', time:'PRESENT').
          wholeWord("могут", syn:"verb", agr:'pl', baseForm:'мочь', control:'true', sem:'CAN', time:'PRESENT').
          wholeWord("вспомнить", syn:"verb", agr:'inf', baseForm:'вспомнить', subcat_acc:'true', sem:'RECALL').
          wholeWord("было", syn:"copula", agr:'neutr', baseForm:'быть', sem:'BE', time:'PAST').
          wholeWord("обнаружили", syn:"verb", agr:'pl', baseForm:'обнаружить', sem:'DISCOVER', subcat_comp:'true', time:'PAST').
          wholeWord("пошли", syn:"verb", agr:'pl', baseForm:'пойти', sem:'GO', time:'PAST').

          wholeWord("мое", syn:"genitive", sem:"I").

          wholeWord("не", syn:"neg").

          wholeWord("со", syn:"prep", baseForm:'с').
          wholeWord("по", syn:"prep", baseForm:'по').
          wholeWord("на", syn:"prep", baseForm:'на').
          wholeWord("к", syn:"prep", baseForm:'к').
          wholeWord("в", syn:"prep", baseForm:'в').

          wholeWord("мной", syn:"noun", case:'instr',  sem:'I').


          wholeWord("вдруг", syn:"adverb", sem:'SUDDENLY').
          wholeWord("тоже", syn:"adverb", sem:'ALSO').
          wholeWord("я", syn:"noun", case:'nom', sem:'I').
          wholeWord("Я", syn:"noun", case:'nom', sem:'I'). //todo capitalization
          wholeWord("Мы", syn:"noun", case:'nom', sem:'WE'). //todo capitalization
          wholeWord("что", syn:"noun", wh_word:'true', case:'nom', sem:'WHAT').
          wholeWord("что", syn:"noun", wh_word:'true', case:'acc', sem:'WHAT').
          wholeWord("что", syn:"complementizer").
          wholeWord("когда", syn:"adverb", adv_kind:'time', wh_word:'true', sem:'WHEN').
          wholeWord("Каково", syn:"short_adj", wh_word:'true', sem:'HOW').
          wholeWord("идет", syn:"verb", baseForm:'идти', sem:'GO').
          wholeWord("раньше", syn:"adverb", adv_kind:'scalar', sem:'EARLIER').
          wholeWord("дальше", syn:"adverb", adv_kind:'scalar', sem:'NEXT').

          wholeWord("все", syn:"all").

          wholeWord("или", syn:"conj", sem:'OR').
          wholeWord("и", syn:"conj", sem:'AND').
          wholeWord("а", syn:"conj", sem:'BUT').

          wholeWord("этому", syn:"adj", adj_kind:'det', case:'dat', sem:'THIS').

          wholeWord("же", syn:"emph_particle").

          suffix("ит", syn:'verb').
          suffix("ая", syn:'adj', case:'nom').
          suffix("ую", syn:'adj', case:'acc').
          suffix("ый", syn:'adj', case:'nom').
          suffix("ий", syn:'adj', case:'acc').
          suffix("ой", syn:'adj', case:'gen')

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update

      if (aspect.ping(':')) {
        update.findAround(syn:'verb') { verb -> update.wrapUp verb }
      }
      if (aspect.ping('.')) {
        update.findAround(syn:'verb') { update.enrich it, syn:'verb', sentence_end:'dot'} //todo sentence end should be marked on the main verb
        update.findAllActiveAround([:]).each { update.wrapUp it } //todo automatic wrapUp of everything unreachable
      }
      if (aspect.ping(',')) {
        def hasEnum = update.findAround(sem: 'enumeration') { enm ->
          def member = enm.opponent(sem: 'member')
          update.listen(syn: member['syn'].value) { next, upd2 ->
            upd2.newFrame([next, enm], sem: 'member')
            upd2.wrapUp member
          }
        }

        if (!hasEnum) {
          update.findAround(syn:'number', phon:null) { fst ->   //todo generic enumerations
            update.listen(syn:fst['syn'].value) { snd, upd2 ->
              def enm = upd2.newFrame([], syn:'noun', case:'acc', sem: 'enumeration')
              upd2.newFrame([fst, enm], sem:'member')
              upd2.newFrame([snd, enm], sem:'member')
              upd2.wrapUp fst
            }
          }
        }
      }
      if (aspect.ping('"')) {
        update.findAround(syn:'noun') { noun ->
          update.listen(phon:null) { name, upd2 ->
            if (host.strongUsages(syn:'quote_pair')) return //todo preventing new aspects from aspectAppeared, or a special quote environment

            def phon = name['phon'].value
            upd2.enrich(name, phon:phon, sem:phon)
            upd2.newFrame([name, noun], sem:'name', name:'true')
            upd2.listen(phon:'"') { quote, upd3 ->
              upd3.newFrame([host, quote], syn:'quote_pair')
            }
          }
        }
      }
      return
    }

    findTheta(aspect, host, update)


    if (aspect.ping('adj')) {
      def caze = host['case'].value
      def sem = host.ping(adj_kind:'det') ? 'determiner' : 'property_host'
      def noun = update.newFrame([], syn:'noun', case:caze)
      update.newFrame([host, noun], syn: 'adjective_noun', sem: sem)
      update.listen ('syn') { real, upd2 ->
      if (real != noun && real.ping(syn:'noun')) {
        upd2.merge(noun, real)
        noun.strongUsages(sem:'with_respect_to').each {
          upd2.weaken it //todo a general policy for parent frames when children are merged
        }
        return true
      }
      return false
    }
      return
    }

    if (aspect.role == 'name' && aspect.ping('true') && host.ping(syn:'adj')) {
      def link = host.strongUsages(syn: 'adjective_noun')[0]
      update.enrich(link, syn:'adjective_noun', sem:'name')
      update.enrich(link.children[1], syn:'noun', sem:'STREET') //todo referent inference
    }

    if (aspect.ping('short_adj')) {
      def noun = update.newFrame([], syn:'noun', case:'nom')
      update.anticipate(noun, syn:"noun", case:'nom')

      def rel = update.newFrame([host, noun], syn:'degree', sem:'degree')
      update.listen(syn:'copula') { copula, upd2 ->
        def time = copula['time']
        if (time) {
          upd2.enrich rel, time:time.value, sem:'degree'
        }
        upd2.listen(phon: ',') { comma, upd3 ->
          upd3.wrapUp copula
          update.findAllActiveAround(syn:'noun').each { upd3.wrapUp it }
        }
      }


    }
    if (aspect.ping('genitive') || aspect.role == 'case' && aspect.ping('gen') && host.ping(syn:'noun')) {
      update.findAround(syn:'noun') { noun ->
        update.newFrame([host, noun], sem:'with_respect_to')
      }
    }

    if (aspect.ping('prep_noun')) {
      Frame prep = host.children[0]
      Frame noun = host.children[1]
      if (!noun.strongUsages(syn:'theta')) {
        def role =
          prep['baseForm'].value == 'по' ? 'по+дат' :
          prep['baseForm'].value == 'с' ? 'с+тв' :
          prep['baseForm'].value == 'в' ? 'в+вин' :
          prep['baseForm'].value == 'к' ? 'к+дат' :
            'на+чём'
        update.findAround(syn:'verb') { verb ->
          if (!verb.strongAlternatives('sem')) {
            def subj = verb.opponent(theta: 'nom')
            if (subj) {
              update.newFrame([noun, subj], sem:'location')
            }
          }
          update.newFrame([noun, verb], syn: 'theta', theta: role)
        }
      }
    }

    if (aspect.ping('verb')) {
      update.findAllActiveAround(syn:'noun').each { update.wrapUp it }
      update.findAllActiveAround(syn:'noun').each { update.wrapUp it }

      if (host.ping(baseForm:'идти')) {
        update.listen('syn':'adverb', adv_kind:'scalar') { scalar, upd2 ->
          upd2.newFrame([scalar, host], syn:'adv_mod', sem:'scalar_end')
          upd2.enrich(host, baseForm:'идти', sem:'COME_SCALARLY')
        }
      }

      if (host.ping(baseForm:'случиться')) {
        update.listen('sem') { self, upd1 ->
          if (host.opponent(sem: 'experiencer')?.ping(sem:'THING')) {
            upd1.listen('phon':':') { colon, upd2 ->
              upd2.listen('syn':'verb') { verb, upd3 ->
                upd3.newFrame([verb, host.opponent(sem: 'experiencer')], sem:'elaboration')
              }
            }
            return true
          }
          return false
        }
      }

      verbChanged host, aspect, update
      update.listen('theta') { theta, upd2 -> verbChanged host, aspect, upd2 }

      if (host.ping(control: 'true')) {
        update.listen(syn: 'verb') { comp, upd2 ->
          upd2.newFrame([comp, host], sem: 'theme')
          def subj = host.opponent(theta: 'nom')
          if (subj) {
            upd2.newFrame([subj, comp], syn: 'theta', theta: 'nom')
          }
        }
      }

      if (host.ping(subcat_whq: 'true')) {
        update.listen('phon': ',') { comma, upd2 ->
          upd2.listen(syn:'noun', wh_word:'true') { wh, upd3 ->
            upd3.confirmChoice(wh, syn:'noun', wh_word:'true', sem:'WHAT')
          }

          def comp = upd2.newFrame([], syn: 'verb')
          upd2.anticipate(comp, syn: 'verb')
          upd2.newFrame([comp, host], syn: 'theta', theta: 'comp', sem: 'theme')
          upd2.wrapUp host
        }
      }
      else if (host.ping(subcat_comp: 'true')) {
        update.listen('phon': ',') { comma, upd2 ->
          upd2.listen(syn:'complementizer') { complementizer, upd3 ->
            upd3.confirmChoice(complementizer, syn:'complementizer')
            def comp = upd3.newFrame([], syn: 'verb')
            upd3.listen('syn') { real, upd4 ->
              if (real != comp && real.ping(syn: 'verb')) {
                upd4.merge(comp, real)
                if (!real.opponent(theta: 'nom')) {
                  def subj = host.opponent(theta: 'nom')
                  if (subj) {
                    upd4.newFrame([subj, real], syn: 'theta', theta: 'nom')
                  }
                }
                return true
              }
              return false
            }
            upd3.newFrame([comp, host], syn: 'theta', theta: 'comp', sem: 'theme')
            upd3.wrapUp host
          }
        }
      }
    }

    if (aspect.role == 'syn' && aspect.ping('prep')) {
      def caze = host.ping(baseForm:'с') ? 'instr' : host.ping(baseForm:'к') ? 'dat' : host.ping(baseForm:'в') ? 'acc' : 'prep'
      def arg = update.newFrame([], syn:"noun", case:caze)
      update.anticipate(arg, syn:'noun')
      update.newFrame([host, arg], syn:'prep_noun')
    }

    if (aspect.role == 'syn' && aspect.ping('complementizer')) {
      update.findAround(syn:'noun') { noun ->
        update.confirmChoice(host, syn:'complementizer')
        def clause = update.newFrame([], syn: 'verb')
        update.newFrame([noun, clause], syn: 'theta', theta:'nom')
      }
    }

    if (aspect.role == 'stem') {
      def stem = aspect.value
      if (stem == "люб") {
        update.enrich(host, aspect, subcat_acc: 'true', sem: "love", baseForm: 'любить', agr:'3sing')
      }
      else if (stem == "красив") {
        update.enrich(host, aspect, sem: "beautiful")
      }
      else if (stem == "Удивительн") {
        update.enrich(host, aspect, sem: "AMAZING")
      }
      else if (stem == "коммерческ") {
        update.enrich(host, aspect, sem: "COMMERCIAL")
      }
      else if (Character.isUpperCase(stem.charAt(0))) {
        update.enrich(host, aspect, sem: stem, name:'true')
      }
    }

    if ((aspect.role == 'theta' || aspect.role == 'syn' && aspect.value == 'degree') && host.strongAlternatives(aspect.role)[0] == aspect) {
      Frame arg = host.children[0]
      if (arg['wh_word']?.value == 'true') {
        host.strongAlternatives(aspect.role).each {
          update.enrich(host, it, wh_focus: 'true')
        }
        update.listen('phon': '-') { mdash, upd2 ->         //todo merge similar listeners from competitor aspects
          upd2.listen('syn': 'conj') { conj, upd3 ->
            upd3.newFrame([conj, arg], sem: 'alternatives')
          }
        }
      }
    }

    if (aspect.ping('conj')) {
      handleConj(host, update)
    }

    markThetaCases(aspect, host, update)

    if (aspect.ping('adverb') && !host.opponent(syn: 'adv_mod')) {
      Reference<Frame> select = [null]
      if (host.ping(wh_word: 'true')) {
        update.findAround(syn: 'degree') { rel -> select.set rel } //todo verb
      }

      update.listen('syn': 'verb') { verb, upd2 ->
        if (host.ping(adv_kind: 'scalar')) {
          def comes = upd2.newFrame([], sem: 'COME_SCALARLY')
          upd2.newFrame([host, comes], sem: 'scalar_end')

          def what = upd2.newFrame([], sem: 'WHAT')
          upd2.newFrame([what, comes], sem: 'agent', wh_focus:'true')
          upd2.newFrame([comes, verb], sem: 'theme')

          return
        }

        upd2.newFrame([host, verb], syn: 'adv_mod', sem: (host.ping(adv_kind: 'time') ? 'time' : 'mode'))
        if (select.get()) {
          upd2.newFrame([verb, select.get()], sem: 'time')
        }
      }
    }
    if (aspect.ping('neg')) {
      update.listen('syn': 'verb') { verb, upd2 -> upd2.enrich verb, neg:'true', syn:'verb' }
    }

    if (aspect.role == 'sem' && aspect.ping("NEIGHBOURS")) {
      def me = update.newFrame([], sem: 'I')
      update.newFrame([me, host], sem: 'with_respect_to')
    }

    if (aspect.role == 'syn' && aspect.ping('all')) {
      update.findAround(syn:'noun') {
        update.enrich(it, quant:'ALL', case:'nom')
      }
    }

  }

  private def handleConj(Frame host, Update update) {
    def hasEnum = update.findAround(sem: 'enumeration') { enm ->
      update.confirmChoice(host, sem: 'AND')
      update.newFrame([host, enm], sem: 'connective')
      def member = enm.opponent(sem: 'member')
      update.listen(syn: member['syn'].value) { next, upd2 ->
        upd2.newFrame([next, enm], sem: 'member')
        upd2.wrapUp member
      }
    }
    if (hasEnum) {
      return
    }

    update.findAround([phon: null, syn:null]) { left ->
      def leftLink = update.newFrame([left, host], sem:'conj_left')
      update.wrapUp left
      def noun = left.opponent(false, syn: 'adjective_noun')
      if (noun) {
        update.wrapUp noun //todo automatic level-based implicit noun weakening
      }
      update.listen('syn') { right, u2 ->
        def actualSyn = right['syn']?.value
        if (actualSyn) {
          if (left.ping(syn:actualSyn)) {
            u2.confirmChoice(left, syn:actualSyn)
            u2.newFrame([right, host], sem:'conj_right')
            return true
          } else {
            Collection<Frame> rels = left.strongUsages(syn: 'theta').findAll { left == it.children[0] }
            List<Frame> heads = rels.collect { it.children[1] }
            Frame parent = heads[0]
            if (parent) {
              u2.weaken leftLink
              u2.wrapUp parent
              u2.newFrame([parent, host], sem:'conj_left')
              u2.newFrame([right, host], sem:'conj_right')

              if (parent.ping(syn: 'verb') && right.ping(syn: 'verb') && !right.opponent(theta: 'nom')) {
                def subj = parent.opponent(theta: 'nom')
                if (subj) {
                  u2.newFrame([subj, right], syn:'theta', theta:'nom')
                }
              }

              return true
            }
          }
        }
        return false
      }
    }
  }

  private def markThetaCases(Aspect aspect, Frame host, Update update) {
    if (aspect.role == 'case' && host.ping(syn:'noun')) {
      def theta = host.strongUsages(syn: 'theta')[0]
      if (!theta) {
        update.listen('syn') { th, upd2 ->
          if (th.ping(syn:'theta') && host in th.children && !th.strongAlternatives('theta')) {
            upd2.enrich th, syn:'theta', theta:aspect.value
            return true
          }
          return false
        }
      }
    }
  }

  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.opponent(syn: 'theta')) {
      def found = update.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], syn:'theta')
      }
      if (!found) {
        update.listen('syn':'verb') { verb, upd2 -> upd2.newFrame([host, verb], syn:'theta') }
      }
    }
  }

  void verbChanged(Frame host, Aspect aspect, Update update) {
    if (host['sem']) {
      def subjTheta = subjRole(host)
      if (host.strongUsages(syn: 'theta').findAll { it['theta']?.value=='nom' && !it['sem'] }) {
        host.strongUsages(syn: 'theta', theta: 'nom').findAll { it['sem'] }.each { it.relax() }
      }

      List<Frame> toAssign = host.strongUsages(syn: 'theta').findAll { !it['sem'] }

      Frame covertSubj = host.strongUsages(covert:'true')[0]
      if (covertSubj) {
        def real = toAssign.find { it.ping(syn: 'theta', theta: 'nom') }
        if (real) {
          update.enrich(real, theta:'nom', sem:subjTheta)
          update.merge(covertSubj, real)
          update.merge(covertSubj.children[0], real.children[0])
          toAssign.remove(real)
        }
      } else if (!host.strongUsages(sem:subjTheta).findAll { it['sem']}) {
        def nom = toAssign.find { it['theta']?.value == 'nom' }
        if (!nom) nom = toAssign.find { it.ping(theta: 'nom') }
        if (nom) {
          update.enrich nom, theta:'nom', sem:subjTheta
          toAssign.remove nom
        } else {
          def agr = host['agr']?.value
          def subj = update.newFrame([], sem: (agr == 'pl' ? 'THEY' : 'HE'))
          update.newFrame([subj, host], sem: subjTheta, covert:'true')
        }
      }

      if (host.ping(subcat_acc: 'true')) {
        def objTheta = host.ping(baseForm:'спросить') ? 'addressee' : 'theme'
        if (!host.opponent(sem:objTheta)) {
          def acc = toAssign.find { it.ping(theta: 'acc') }
          if (acc) {
            update.enrich acc, theta:'acc', sem:objTheta
            toAssign.remove(acc)
          }
        }
      }

      def stv = toAssign.find { it.ping(theta: 'с+тв') }
      if (stv) {
        update.enrich(stv, theta: 'с+тв', sem:'theme')
        toAssign.remove stv
      }

      def podat = toAssign.find { it.ping(theta: 'по+дат') }
      if (podat) {
        update.enrich(podat, theta: 'по+дат', sem:'topic')
        toAssign.remove podat
      }

      def kdat = toAssign.find { it.ping(theta: 'к+дат') }
      if (kdat) {
        update.enrich(kdat, theta: 'к+дат', sem:'theme')
        toAssign.remove kdat
      }

      def vacc = toAssign.find { it.ping(theta: 'в+вин') }
      if (vacc) {
        update.enrich(vacc, theta: 'в+вин', sem:'theme')
        toAssign.remove vacc
      }
    }
  }

  private String subjRole(Frame verb) {
    switch (verb['baseForm']?.value) {
      case 'идти':
      case 'спросить':
      case 'отправиться': return 'agent'
      default: return 'experiencer'
    }
  }

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') }.each { generateSentence(it, to) }
  }

  private void addWord(Chart dst, String word) {
    dst.newFrame([]).enrich(['phon', word])
  }

  private void generateSentence(Frame verb, Chart dst) {
    generateNP(dst, verb.opponent(sem: 'experiencer'), 'nom')
    addWord dst, 'любит'
    generateNP(dst, verb.opponent(sem: 'theme'), 'acc')
  }

  private void generateNP(Chart dst, Frame noun, String caze) {
    noun.allOpponents(sem:'property_host').each {
      if (it.ping(sem:'beautiful')) {
        addWord dst, caze == 'nom' ? 'красивая' : 'красивую'
      }
    }
    if (noun.ping(sem:'mother')) {
      addWord dst, 'мать'
    } else if (noun.ping(sem:'daughter')) {
      addWord dst, 'дочь'
    } else if (noun.ping(sem:'father')) {
      addWord dst, caze == 'nom' ? 'отец' : 'отца'
    }
  }


}
