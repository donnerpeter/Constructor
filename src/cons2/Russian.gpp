package cons2

/**
 * @author peter
 */
class Russian implements Language {
  Inflection infl = new Inflection().
          wholeWord("мать", ["syn", "noun"], ['case', 'nom'], ["case", "acc"], ["sem", "mother"]).
          wholeWord("дочь", ["syn", "noun"], ['case', 'nom'], ["case", "acc"], ["sem", "daughter"]).
          wholeWord("отец", ["syn", "noun"], ['case', "nom"], ["sem", "father"]).
          wholeWord("отца", ["syn", "noun"], ['case', "acc"], ["sem", "father"]).
          wholeWord("случай", ["syn", "noun"], ['case', 'nom'], ["sem", "THING"], ['discourse', 'new']).
          wholeWord("случился", ["syn", "verb"], ['sem', 'HAPPEN'], ['time', 'PAST']).
          wholeWord("со", ["syn", "prep"]).
          wholeWord("мной", ["syn", "noun"], ['case', 'instr'],  ['sem', 'I']).
          wholeWord("забыл", ["syn", "verb"], ['sem', 'FORGET'], ['time', 'PAST'], ['subcat', '2whq']).
          wholeWord("вдруг", ["syn", "adverb"], ['sem', 'SUDDENLY']).
          wholeWord("я", ["syn", "noun"], ['case', 'nom'], ['sem', 'I']).
          wholeWord("что", ["syn", "noun", 'wh'], ['case', 'nom'], ['sem', 'WHAT']).
          wholeWord("идет", ["syn", "verb", "идти"], ['sem', 'GO']).
          wholeWord("раньше", ["syn", "adverb", 'scalar'], ['sem', 'EARLIER']).
          wholeWord("или", ["syn", "conj"], ['sem', 'OR']).
          suffix("ит", ['syn', 'verb']).
          suffix("ая", ['syn', 'adj', 'adj_nom']).
          suffix("ую", ['syn', 'adj', 'adj_acc']).
          suffix("ый", ['syn', 'adj', 'adj_nom'])

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update

      if (aspect.ping(':')) {
        host.findAround(syn:'verb') { verb -> update.wrapUp verb }
      }
      return
    }

    findTheta(aspect, host, update)

    if (aspect.ping('adj')) {
      def caze = aspect.ping('adj_nom') ? 'nom' : 'acc'
      def adj = new SimpleQuery(case:caze, ['syn', 'adjective_noun'], ['sem', 'property_host'])
      if (!adj.activate(host, update)) {
        def noun = update.newFrame([], new AnticipatingConstruct([syn:'noun', case:caze], [syn:"noun"]))
        update.newFrame([host, noun], ['syn', 'adjective_noun'], ['sem', 'property_host'])
      }
      return
    }

    if (aspect.ping('prep_noun')) {
      Frame noun = host.children[1]
      if (!noun.strongUsages(syn:'theta')) {
        noun.findAround(syn:'verb') { verb -> update.newFrame([noun, verb], ['syn', 'theta'], ['theta', 'с+тв']) }
      }
    }

    if (aspect.ping('verb')) {
      host.findAround(syn:'noun') { update.wrapUp it }
    }

    if (aspect.ping('prep')) {
      def caze = 'instr'
      def arg = update.newFrame([], new AnticipatingConstruct([syn:"noun", case:caze], [syn:"noun"]))
      update.newFrame([host, arg], ['syn', 'prep_noun'])
    }

    if (aspect.role == 'stem') {
      def stem = aspect.nicknames.iterator().next()
      if (stem == "люб") {
        update.enrich(host, ['subcat', '2acc'], ["sem", "love"])
      }
      if (stem == "красив") {
        update.enrich(host, ["sem", "beautiful"])
      }
      if (stem == "Удивительн") {
        update.enrich(host, ["sem", "AMAZING"])
      }
    }

    if (aspect.role == 'theta' && !host['wh_focus']) {
      Frame arg = host.children[0]
      if (arg.ping(syn:'wh')) {
        update.enrich(host, ['wh_focus', 'true'])
      }
    }

    if (aspect.ping('conj')) {
      host.findAround([syn:'number']) { left -> update.newFrame([host, left], ['sem', 'conj_left']); update.wrapUp left }
      update.listen('syn') { right, u2 ->
        if (right.ping(syn:'number')) {
          u2.newFrame([host, right], ['sem', 'conj_right'])
          return true
        }
        return false
      }
    }

    markThetaCases(aspect, host, update)


  }

  private def markThetaCases(Aspect aspect, Frame host, Update update) {
    if (aspect.role == 'case') {
      def theta = host.strongUsages(syn: 'theta')[0]
      if (theta && !theta.strongAlternatives('theta')) {
        update.enrich theta, ['theta', aspect.value]
      }
    }
  }

  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.opponent(syn: 'theta')) {
      def found = host.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], ['syn', 'theta'])
      }
      if (!found) {
        update.listen('syn') { verb, upd2 ->
          if (verb.ping(syn: 'verb')) {
            upd2.newFrame([host, verb], ['syn', 'theta'])
            return true
          }
          return false
        }
      }
    }
  }

  void contextChanged(Frame host, Aspect aspect, Update update) {
    markThetaCases(aspect, host, update)

    if (aspect.ping('verb') && !(aspect instanceof AnticipatingConstruct)) {
      def subj = host.ping(syn:'идти') ? 'agent' : 'experiencer'
      if (host.strongUsages(syn: 'theta').findAll { it['theta']?.value=='nom' && !it['sem'] }) {
        host.strongUsages(syn: 'theta', theta: 'nom').findAll { it['sem'] }.each { it.relax() }
      }

      Reference hasSubj = [!host.strongUsages(sem:subj).findAll { it['sem']}.isEmpty()]

      if (!hasSubj.get()) {
        host.strongUsages(syn: 'theta').findAll { it['theta']?.value=='nom' && !it['sem'] }.each { theta ->
          update.enrich theta, ['sem', subj]
          hasSubj.set true
        }
      }

      host.strongUsages(syn: 'theta').findAll { !it['sem'] }.each { theta ->
        if (theta.ping(theta: 'nom') && !hasSubj.get()) {
          update.enrich theta, ['sem', subj]
          hasSubj.set true
        }
        else if (host.ping(subcat: '2acc') && theta.ping(theta: 'acc') && !host.strongUsages(sem:'theme')) {
          update.enrich theta, ['sem', 'theme']
        }
      }

      if (host.ping(subcat:'2whq') && !host.strongUsages(theta:'comp')) {
        host.findAround(phon: ',') {
          def comp = update.newFrame([], new AnticipatingConstruct([syn: 'verb'], [syn: 'verb']))
          update.newFrame([comp, host], ['syn', 'theta'], ['theta', 'comp'], ['sem', 'theme'])
          update.wrapUp host
        }
      }

      def stv = host.strongUsages(theta:'с+тв')[0]
      if (stv && !stv['sem']) {
        update.enrich(stv, ['sem', 'theme'])
      }

      if (aspect.ping('идти') && !host.opponent(syn:'adv_mod')) {
        host.findAround(syn:['adverb', 'scalar']) { scalar ->
          update.newFrame([scalar, host], ['syn', 'adv_mod'], ['sem', 'scalar_end'])
          update.enrich(host, ['sem', 'COME_SCALARLY'])
          update.confirmChoice(host, sem:'COME_SCALARLY')
        }
      }

      return
    }

    if (aspect.ping('adverb') && !host.opponent(syn:'adv_mod')) {
      adverb.activate(host, false, update)
    }
  }

  boolean wrapUp(Frame host, Aspect aspect) {
    true
  }

  SimpleQuery adverb = [[syn:"verb"], ["syn", 'adv_mod'], ["sem", "mode"]]

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') }.each { generateSentence(it, to) }
  }

  private void generateSentence(Frame verb, Chart dst) {
    generateNP(dst, verb.opponent(sem:'experiencer'), 'nom')
    dst.newFrame([], ['phon', 'любит'])
    generateNP(dst, verb.opponent(sem:'theme'), 'acc')
  }

  private void generateNP(Chart dst, Frame noun, String caze) {
    noun.allOpponents(sem:'property_host').each {
      if (it.ping(sem:'beautiful')) {
        dst.newFrame([], ['phon', caze == 'nom' ? 'красивая' : 'красивую'])
      }
    }
    if (noun.ping(sem:'mother')) {
      dst.newFrame([], ['phon', 'мать'])
    } else if (noun.ping(sem:'daughter')) {
      dst.newFrame([], ['phon', 'дочь'])
    } else if (noun.ping(sem:'father')) {
      dst.newFrame([], ['phon', caze == 'nom' ? 'отец' : 'отца'])
    }
  }


}
