package cons2

/**
 * @author peter
 */
class Russian implements Language {
  Inflection infl = new Inflection().
          wholeWord("мать", ["syn", "noun"], ['case', 'nom'], ["case", "acc"], ["sem", "mother"]).
          wholeWord("дочь", ["syn", "noun"], ['case', 'nom'], ["case", "acc"], ["sem", "daughter"]).
          wholeWord("отец", ["syn", "noun"], ['case', "nom"], ["sem", "father"]).
          wholeWord("отца", ["syn", "noun"], ['case', "acc"], ["sem", "father"]).
          wholeWord("поводу", ["syn", "noun"], ['case', "dat"], ["sem", "MATTER"]).
          wholeWord("их", ["syn", "noun"], ['case', "acc"], ["sem", "THEY"]). //todo pronouns
          wholeWord("они", ["syn", "noun"], ['case', "nom"], ["sem", "THEY"]).
          wholeWord("случай", ["syn", "noun"], ['case', 'nom'], ["sem", "THING"], ['discourse', 'new']).
          wholeWord("соседям", ["syn", "noun"], ['case', 'dat'], ["sem", "NEIGHBOURS"], ['discourse', 'new']).

          wholeWord("случился", ["syn", "verb"], ['baseForm', 'случиться'], ['sem', 'HAPPEN'], ['time', 'PAST']).
          wholeWord("отправился", ["syn", "verb"], ['baseForm', 'отправиться'], ['sem', 'START_GO_TO'], ['time', 'PAST']).
          wholeWord("спросил", ["syn", "verb"], ['baseForm', 'спросить'], ['subcat', '2acc'], ['subcat', '2whq'], ['sem', 'ASK'], ['time', 'PAST']).
          wholeWord("думают", ["syn", "verb"], ['baseForm', 'думать'], ['subcat', '2acc'], ['sem', 'THINK'], ['time', 'PRESENT']).
          wholeWord("со", ["syn", "prep"], ['baseForm', 'с']).
          wholeWord("по", ["syn", "prep"], ['baseForm', 'по']).
          wholeWord("к", ["syn", "prep"], ['baseForm', 'к']).
          wholeWord("мной", ["syn", "noun"], ['case', 'instr'],  ['sem', 'I']).
          wholeWord("забыл", ["syn", "verb"], ['sem', 'FORGET'], ['time', 'PAST'], ['subcat', '2whq']).
          wholeWord("вдруг", ["syn", "adverb"], ['sem', 'SUDDENLY']).
          wholeWord("я", ["syn", "noun"], ['case', 'nom'], ['sem', 'I']).
          wholeWord("Я", ["syn", "noun"], ['case', 'nom'], ['sem', 'I']). //todo capitalization
          wholeWord("что", ["syn", "noun", 'wh'], ['case', 'nom'], ['case', 'acc'], ['sem', 'WHAT']).
          wholeWord("идет", ["syn", "verb"], ['baseForm', "идти"], ['sem', 'GO']).
          wholeWord("раньше", ["syn", "adverb", 'scalar'], ['sem', 'EARLIER']).
          wholeWord("или", ["syn", "conj"], ['sem', 'OR']).
          wholeWord("и", ["syn", "conj"], ['sem', 'AND_THEN']).
          wholeWord("этому", ["syn", "adj", 'adj_dat', 'det'], ['sem', 'THIS']).

          suffix("ит", ['syn', 'verb']).
          suffix("ая", ['syn', 'adj', 'adj_nom']).
          suffix("ую", ['syn', 'adj', 'adj_acc']).
          suffix("ый", ['syn', 'adj', 'adj_nom'])

  void aspectAppeared(Frame host, Aspect aspect, Update update) {
    if (aspect.role == 'phon') {
      infl.analyze host, aspect, update

      if (aspect.ping(':')) {
        host.findAround(syn:'verb') { verb -> update.wrapUp verb }
      }
      return
    }

    findTheta(aspect, host, update)

    if (aspect.ping('adj')) {
      def caze = aspect.ping('adj_nom') ? 'nom' : aspect.ping('adj_dat') ? 'dat' : 'acc'
      Aspect sem = ['sem', aspect.ping('det') ? 'determiner' : 'property_host']
      def adj = new SimpleQuery(case:caze, ['syn', 'adjective_noun'], sem)
      if (!adj.activate(host, update)) {
        def noun = update.newFrame([], new AnticipatingConstruct([syn:'noun', case:caze], [syn:"noun"]))
        update.newFrame([host, noun], ['syn', 'adjective_noun'], sem)
      }
      return
    }

    if (aspect.ping('prep_noun')) {
      Frame prep = host.children[0]
      Frame noun = host.children[1]
      if (!noun.strongUsages(syn:'theta')) {
        def role = prep['baseForm'].value == 'по' ? 'по+дат' : 'с+тв'
        noun.findAround(syn:'verb') { verb -> update.newFrame([noun, verb], ['syn', 'theta'], ['theta', role]) }
      }
    }

    if (aspect.ping('verb')) {
      host.findAllActiveAround(syn:'noun').each { update.wrapUp it }

      if (host.ping(baseForm:'идти')) {
        update.listen('syn') { scalar, upd2 ->
          if (scalar.ping(syn:['adverb', 'scalar']) && !host.opponent(syn:'adv_mod')) {
            upd2.newFrame([scalar, host], ['syn', 'adv_mod'], ['sem', 'scalar_end'])
            upd2.enrich(host, ['sem', 'COME_SCALARLY'])
            return true
          }
          return false
        }
      }

      if (host.ping(baseForm:'случиться')) {
        update.listen('sem') { self, upd1 ->
          if (host.opponent(sem: 'experiencer')?.ping(sem:'THING')) {
            upd1.listen('phon') { colon, upd2 ->
              if (colon.ping(phon: ':')) {
                upd2.listen('syn') { verb, upd3 ->
                  if (verb.ping(syn: 'verb')) {
                    upd3.newFrame([verb, host.opponent(sem: 'experiencer')], ['sem', 'elaboration'])
                    return true
                  }
                  return false
                }
                return true
              }
              return false
            }
            return true
          }
          return false
        }
      }

      verbChanged host, aspect, update
      update.listen('theta') { theta, upd2 -> verbChanged host, aspect, upd2 }

      if (host.ping(subcat:'2whq')) {
        update.listen('phon') { comma, upd2 ->
          if (comma.ping(phon:',') && !host.strongUsages(theta:'comp')) {
            def comp = upd2.newFrame([], new AnticipatingConstruct([syn: 'verb'], [syn: 'verb']))
            upd2.newFrame([comp, host], ['syn', 'theta'], ['theta', 'comp'], ['sem', 'theme'])
            upd2.wrapUp host
            return true
          }
          return false
        }
      }
    }

    if (aspect.ping('prep')) {
      def caze = 'instr'
      def arg = update.newFrame([], new AnticipatingConstruct([syn:"noun", case:caze], [syn:"noun"]))
      update.newFrame([host, arg], ['syn', 'prep_noun'])
    }

    if (aspect.role == 'stem') {
      def stem = aspect.nicknames.iterator().next()
      if (stem == "люб") {
        update.enrich(host, ['subcat', '2acc'], ["sem", "love"])
      }
      if (stem == "красив") {
        update.enrich(host, ["sem", "beautiful"])
      }
      if (stem == "Удивительн") {
        update.enrich(host, ["sem", "AMAZING"])
      }
    }

    if (aspect.role == 'theta' && !host['wh_focus'] && host.strongAlternatives(aspect.role)[0] == aspect) {
      Frame arg = host.children[0]
      if (arg.ping(syn:'wh')) {
        update.enrich(host, ['wh_focus', 'true'])
        update.listen('phon') { mdash, upd2 ->
          if (mdash.ping(phon: '-')) {
            upd2.listen('syn') { conj, upd3 ->
              if (conj.ping(syn: 'conj')) {
                upd3.newFrame([conj, arg], ['sem', 'alternatives'])
                return true
              }
              return false
            }
            return true
          }
          return false
        }
      }
    }

    if (aspect.ping('conj')) {
      handleConj(host, update)
    }

    markThetaCases(aspect, host, update)

    if (aspect.ping('adverb') && !host.opponent(syn:'adv_mod')) {
      update.listen('syn') { verb, upd2 ->
        if (verb.ping(syn: 'verb')) {
          upd2.newFrame([host, verb], ["syn", 'adv_mod'], ["sem", "mode"])
          return true
        }
        return false
      }
    }

    if (aspect.role == 'sem' && aspect.ping("NEIGHBOURS")) {
      def me = update.newFrame([], ['sem', 'I'])
      update.newFrame([me, host], ['sem', 'with_respect_to'])
    }

  }

  private def handleConj(Frame host, Update update) {
    host.findAround([phon: null]) { left ->
      def leftLink = update.newFrame([left, host], ['sem', 'conj_left'])
      update.wrapUp left
      update.listen('syn') { right, u2 ->
        def expectedSyn = left['syn']?.value
        def actualSyn = right['syn']?.value
        if (actualSyn) {
          if (expectedSyn == actualSyn) {
            u2.newFrame([right, host], ['sem', 'conj_right'])
            return true
          } else {
            Collection<Frame> rels = left.strongUsages(syn: 'theta').findAll { left == it.children[0] }
            List<Frame> heads = rels.collect { it.children[1] }
            Frame parent = heads[0]
            if (parent) {
              u2.weaken leftLink
              u2.wrapUp parent
              u2.newFrame([parent, host], ['sem', 'conj_left'])
              u2.newFrame([right, host], ['sem', 'conj_right'])

              if (parent.ping(syn: 'verb') && right.ping(syn: 'verb') && !right.opponent(theta: 'nom')) {
                def subj = parent.opponent(theta: 'nom')
                if (subj) {
                  u2.newFrame([subj, right], ['syn', 'theta'], ['theta', 'nom'])
                }
              }

              return true
            }
          }
        }
        return false
      }
    }
  }

  private def markThetaCases(Aspect aspect, Frame host, Update update) {
    if (aspect.role == 'case') {
      def theta = host.strongUsages(syn: 'theta')[0]
      if (theta) {
        if (!theta.strongAlternatives('theta')) {
          update.enrich theta, ['theta', aspect.value]
        }
      } else {
        update.listen('syn') { th, upd2 ->
          if (th.ping(syn:'theta') && host in th.children && !th.strongAlternatives('theta')) {
            upd2.enrich th, ['theta', aspect.value]
            return true
          }
          return false
        }
      }
    }
  }

  private def findTheta(Aspect aspect, Frame host, Update update) {
    if (aspect.ping('noun') && !host.opponent(syn: 'theta')) {
      def found = host.findAround(syn: 'verb') { verb ->
        update.newFrame([host, verb], ['syn', 'theta'])
      }
      if (!found) {
        update.listen('syn') { verb, upd2 ->
          if (verb.ping(syn: 'verb')) {
            upd2.newFrame([host, verb], ['syn', 'theta'])
            return true
          }
          return false
        }
      }
    }
  }

  void verbChanged(Frame host, Aspect aspect, Update update) {
    if (!(aspect instanceof AnticipatingConstruct)) {
      def subjTheta = subjRole(host)
      if (host.strongUsages(syn: 'theta').findAll { it['theta']?.value=='nom' && !it['sem'] }) {
        host.strongUsages(syn: 'theta', theta: 'nom').findAll { it['sem'] }.each { it.relax() }
      }

      List<Frame> toAssign = host.strongUsages(syn: 'theta').findAll { !it['sem'] }

      if (!host.strongUsages(sem:subjTheta).findAll { it['sem']}) {
        def nom = toAssign.find { it['theta']?.value == 'nom' }
        if (!nom) nom = toAssign.find { it.ping(theta: 'nom') }
        if (nom) {
          update.enrich nom, ['sem', subjTheta]
          toAssign.remove nom
        }
      }

      if (host.ping(subcat: '2acc')) {
        def objTheta = host.ping(baseForm:'спросить') ? 'addressee' : 'theme'
        if (!host.opponent(sem:objTheta)) {
          def acc = toAssign.find { it.ping(theta: 'acc') }
          if (acc) {
            update.enrich acc, ['sem', objTheta]
            toAssign.remove(acc)
          }
        }
      }

      def stv = toAssign.find { it.ping(theta: 'с+тв') }
      if (stv) {
        update.enrich(stv, ['sem', 'theme'])
        toAssign.remove stv
      }

      def podat = toAssign.find { it.ping(theta: 'по+дат') }
      if (podat) {
        update.enrich(podat, ['sem', 'topic'])
        toAssign.remove podat
      }
    }
  }

  private String subjRole(Frame verb) {
    switch (verb['baseForm']?.value) {
      case 'идти':
      case 'спросить':
      case 'отправиться': return 'agent'
      default: return 'experiencer'
    }
  }

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(sem:'love') }.each { generateSentence(it, to) }
  }

  private void generateSentence(Frame verb, Chart dst) {
    generateNP(dst, verb.opponent(sem:'experiencer'), 'nom')
    dst.newFrame([], ['phon', 'любит'])
    generateNP(dst, verb.opponent(sem:'theme'), 'acc')
  }

  private void generateNP(Chart dst, Frame noun, String caze) {
    noun.allOpponents(sem:'property_host').each {
      if (it.ping(sem:'beautiful')) {
        dst.newFrame([], ['phon', caze == 'nom' ? 'красивая' : 'красивую'])
      }
    }
    if (noun.ping(sem:'mother')) {
      dst.newFrame([], ['phon', 'мать'])
    } else if (noun.ping(sem:'daughter')) {
      dst.newFrame([], ['phon', 'дочь'])
    } else if (noun.ping(sem:'father')) {
      dst.newFrame([], ['phon', caze == 'nom' ? 'отец' : 'отца'])
    }
  }


}
