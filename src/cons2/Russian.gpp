package cons2

 /**
 * @author peter
 */
class Russian implements Language {
  Inflection infl = new Inflection().
          wholeWord("мать", ["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "mother"]).
          wholeWord("дочь", ["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "daughter"]).
          wholeWord("отец", ["syn", "noun", "nom"], ["sem", "father"]).
          wholeWord("отца", ["syn", "noun", "acc"], ["sem", "father"]).
          wholeWord("случай", ["syn", "noun", "nom"], ["sem", "THING"]).
          wholeWord("случился", ["syn", "verb"], ['sem', 'HAPPEN'], ['time', 'PAST']).
          wholeWord("со", ["syn", "prep"]).
          wholeWord("мной", ["syn", "noun", 'instr'], ['sem', 'I']).
          wholeWord("забыл", ["syn", "verb"], ['sem', 'FORGET'], ['time', 'PAST'], ['subcat', '2whq']).
          wholeWord("вдруг", ["syn", "adverb"], ['sem', 'SUDDENLY']).
          wholeWord("я", ["syn", "noun", 'nom'], ['sem', 'I']).
          wholeWord("что", ["syn", "noun", 'nom', 'wh'], ['sem', 'WHAT']).
          wholeWord("идет", ["syn", "verb", "идти"], ['sem', 'GO']).
          wholeWord("раньше", ["syn", "adverb", 'scalar'], ['sem', 'EARLIER']).
          wholeWord("или", ["syn", "conj"], ['sem', 'OR']).
          suffix("ит", ['syn', 'verb']).
          suffix("ая", ['syn', 'adj', 'adj_nom']).
          suffix("ую", ['syn', 'adj', 'adj_acc']).
          suffix("ый", ['syn', 'adj', 'adj_nom'])

  void aspectAppeared(Frame host, Aspect aspect) {
    if (aspect.role == 'phon') {
      infl.analyze host, aspect

      if (aspect.ping(':')) {
        def verb = host.findAround(false, 'verb')
        if (verb) {
          verb.chart.wrapUp verb
        }
      }
      return
    }

    if (aspect.ping('adj')) {
      def caze = aspect.ping('adj_nom') ? 'nom' : 'acc'
      def adj = new SimpleQuery(caze, false, ['syn', 'adjective_noun'], ['sem', 'property_host'])
      if (!adj.activate(host)) {
        def noun = host.chart.newFrame(new AnticipatingConstruct(["noun", caze], "noun"))
        host.chart.construction(-1, [host, noun], ['syn', 'adjective_noun'], ['sem', 'property_host'])
      }
      return
    }

    if (aspect.ping('prep_noun')) {
      Frame noun = host.children[1]
      if (!noun.strongUsages(['с+тв'])) {
        def verb = noun.findAround(false, 'verb')
        if (verb) {
          verb.chart.construction(-1, [verb, noun], ['syn', 'с+тв'])
        }
      }
    }

    if (aspect.ping('verb')) {
      subject.activate host, true
      object.activate host, true
      return
    }

    if (aspect.ping('prep')) {
      def caze = 'instr'
      def arg = host.chart.newFrame(new AnticipatingConstruct(["noun", caze], "noun"))
      host.chart.construction(1, [host, arg], ['syn', 'prep_noun'])
    }

    if (aspect.role == 'stem') {
      def stem = aspect.nicknames.iterator().next()
      if (stem == "люб") {
        host.enrich(['subcat', '2acc'], ["sem", "love"])
      }
      if (stem == "красив") {
        host.enrich(["sem", "beautiful"])
      }
      if (stem == "Удивительн") {
        host.enrich(["sem", "AMAZING"])
      }
    }

    if (aspect.ping('subject') && !host['sem']) {
      Frame verb = host.children[0]
      host.enrich(['sem', verb.ping(false, 'идти') ? 'agent' : 'state_experiencer'])
    }

    if (aspect.ping('verb_arg') && !host['wh_focus']) {
      Frame arg = host.children[1]
      if (arg.ping(false, 'wh')) {
        host.enrich(['wh_focus', 'true'])
      }
    }

    if (aspect.ping('conj')) {
      def left = host.findAround(true, [])
      if (left) {
        host.chart.construction(1, [host, left], ['sem', 'conj_left'])
      }
    }

  }

  void contextChanged(Frame host, Aspect aspect) {
    if (aspect.ping('verb')) {
      subject.activate host

      if (host.ping(false, '2acc')) {
        object.activate host
      }
      if (host.ping(false, '2whq')) {
        whComp.activate host
      }

      def stv = host.strongUsages('с+тв')[0]
      if (stv && !stv['sem']) {
        stv.enrich(['sem', 'theme'])
      }

      if (aspect.ping('идти')) {
        def scalar = host.findAround(true, ['adverb', 'scalar'])
        if (scalar) {
          host.chart.construction(1, [host, scalar], ['syn', 'adv_mod'], ['sem', 'scalar_end'])
          host.enrich(['sem', 'COME_SCALARLY'])
          host.chosenAs 'COME_SCALARLY'
        }
      }

      return
    }

    if (aspect.ping('conj') && !host.strongUsages('conj_right')) {
      def right = host.findAround(true, [])
      if (right) {
        host.chart.construction(1, [host, right], ['sem', 'conj_right'])
      }
    }

    if (aspect.ping('adverb')) {
      adverb.activate(host, false)
    }
  }

  boolean wrapUp(Frame host, Aspect aspect) {
    if (aspect.ping('love')) {
      if (subject.satisfied(host) && object.satisfied(host)) {
        return true
      }

      subject.weaken(host)
      object.weaken(host)

      def subjs = subject.allArgumentCandidates(host)
      def objs = object.allArgumentCandidates(host)

      if (objs.size() == 1) {
        subjs -= objs
        object.instantiate(host, objs[0])
      }
      if (subjs.size() == 1) {
        subject.instantiate(host, subjs[0])
      }

      return subject.satisfied(host) && object.satisfied(host)

    }
    true
  }

  SimpleQuery subject = ["nom", true, ["syn", 'subject', 'verb_arg']]
  SimpleQuery object = ["acc", true, ["syn", 'object', 'verb_arg'], ["sem", "state_theme"]]
  SimpleQuery whComp = ["verb", true, ["syn", 'comp', 'verb_arg'], ["sem", "theme"]]
  SimpleQuery adverb = ["verb", false, ["syn", 'adv_mod'], ["sem", "mode"]]

  void generate(Chart sem, Chart to) {
    sem.frames().findAll { it.ping(false, 'love') }.each { generateSentence(it, to) }
  }

  private void generateSentence(Frame verb, Chart dst) {
    generateNP(dst, verb.strongUsages('state_experiencer')[0].children[1], 'nom')
    dst.newFrame(['phon', 'любит'])
    generateNP(dst, verb.strongUsages('state_theme')[0].children[1], 'acc')
  }

  private void generateNP(Chart dst, Frame noun, String caze) {
    noun.strongUsages('property_host').each { rel ->
      Frame adj = rel.children[0]
      if (adj.ping(false, 'beautiful')) {
        dst.newFrame(['phon', caze == 'nom' ? 'красивая' : 'красивую'])
      }
    }
    if (noun.ping(false, 'mother')) {
      dst.newFrame(['phon', 'мать'])
    } else if (noun.ping(false, 'daughter')) {
      dst.newFrame(['phon', 'дочь'])
    } else if (noun.ping(false, 'father')) {
      dst.newFrame(['phon', caze == 'nom' ? 'отец' : 'отца'])
    }
    dst.update()
  }


}
