package cons2

/**
 * @author peter
 */
class Russian implements Language {
  void analyzeWord(Chart chart, String w) {
    if (w == "мать") {
      chart.newFrame(["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "mother"])
    }
    if (w == "любит") {
      def subject = new SimpleQuery("nom", true, ['super': ["syn", 'subject'], activate: { Frame f ->
        if (!f["sem"]) {
          f.addAlternative(["sem", "state_experiencer"])
        }
      }] as Construct)
      def object = new SimpleQuery("acc", true, ['super': ["syn", 'object'], activate: { Frame f ->
        if (!f["sem"]) {
          f.addAlternative(["sem", "state_theme"])
        }
      }] as Construct)

      def syn = ['super': ["syn", "verb"], activate: { Frame f ->
        subject.activate f
        object.activate f
      }, wrapUp: { Frame f ->
        if (subject.satisfied(f) && object.satisfied(f)) {
          return true
        }

        subject.weaken(f)
        object.weaken(f)

        def subjs = subject.allArgumentCandidates(f)
        def objs = object.allArgumentCandidates(f)

        if (objs.size() == 1) {
          subjs -= objs
          object.instantiate(f, objs[0])
        }
        if (subjs.size() == 1) {
          subject.instantiate(f, subjs[0])
        }

        return subject.satisfied(f) && object.satisfied(f)
      }] as Construct
      def frame = chart.newFrame(syn, ["sem", "love"])

      if (subject.activate(frame)) {
        chart.wrapUp subject.getArg(frame)
      }
      if (object.activate(frame)) {
        chart.wrapUp object.getArg(frame)
      }

    }
    if (w == "дочь") {
      chart.newFrame(["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "daughter"])
    }
    if (w == "красивая") {
      def adj = adjectiveNoun("nom")
      chart.newFrame(['super': ['syn', 'красивая'], activate: { Frame f -> adj.activate(f) }], ["sem", "beautiful"])
    }
    if (w == "красивую") {
      def adj = adjectiveNoun("acc")
      chart.newFrame(['super': ['syn', "красивая"], activate: { Frame f -> adj.activate(f) }], ["sem", 'beautiful'])
    }
    if (w == "отец") {
      chart.newFrame(["syn", "noun", "nom"], ["sem", "father"])
    }
    if (w == "отца") {
      chart.newFrame(["syn", "noun", "acc"], ["sem", "father"])
    }
  }

  private SimpleQuery adjectiveNoun(String caze) {
    Construct syn = ['super': ['syn', 'adjective_noun'], activate: { f ->
      if (!f["sem"]) {
        f.addAlternative(["sem", "property_host"])
      }
    }]
    return new SimpleQuery(caze, false, syn) {
      @Override
      protected Frame findArgument(Frame head) {
        def arg = super.findArgument(head)
        if (arg) {
          return arg
        }

        def choosingPattern = ["noun", caze]
        Construct mockSyn = [
                'super': ["syn", "noun", caze],
                adopt: { Frame f, boolean newTeam, Construct[] a ->
                  if (newTeam && a.any { it.ping("noun") }) {
                    f.removeAlternative((Construct) this)
                    a.each { f.addAlternative it }
                    f.chosenAs choosingPattern
                    return true
                  }
                  return false
                }]
        return head.chart.newFrame(mockSyn)
      }

    }
  }

}
