package cons2

/**
 * @author peter
 */
class Russian implements Language {
  void analyzeWord(Chart chart, String w) {
    if (w == "мать") {
      chart.newFrame(["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "mother"])
    }
    if (w == "любит") {
      def subject = new SimpleQuery("nom", true, ["syn", 'subject'], ["sem", "state_experiencer"])
      def object = new SimpleQuery("acc", true, ["syn", 'object'], ["sem", "state_theme"])

      Construct syn = ['super': ["syn", "verb"], activate: { Frame f ->
        subject.activate f
        object.activate f
      }, wrapUp: { Frame f ->
        if (subject.satisfied(f) && object.satisfied(f)) {
          return true
        }

        subject.weaken(f)
        object.weaken(f)

        def subjs = subject.allArgumentCandidates(f)
        def objs = object.allArgumentCandidates(f)

        if (objs.size() == 1) {
          subjs -= objs
          object.instantiate(f, objs[0])
        }
        if (subjs.size() == 1) {
          subject.instantiate(f, subjs[0])
        }

        return subject.satisfied(f) && object.satisfied(f)
      }]
      def frame = chart.newFrame(syn, ["sem", "love"])

      subject.activate(frame, true)
      object.activate(frame, true)
    }
    if (w == "дочь") {
      chart.newFrame(["syn", "noun", "nom"], ["syn", "noun", "acc"], ["sem", "daughter"])
    }
    if (w == "красивая") {
      def adj = adjectiveNoun("nom")
      chart.newFrame(['super': ['syn', 'красивая'], activate: { Frame f -> adj.activate(f) }], ["sem", "beautiful"])
    }
    if (w == "красивую") {
      def adj = adjectiveNoun("acc")
      chart.newFrame(['super': ['syn', "красивая"], activate: { Frame f -> adj.activate(f) }], ["sem", 'beautiful'])
    }
    if (w == "отец") {
      chart.newFrame(["syn", "noun", "nom"], ["sem", "father"])
    }
    if (w == "отца") {
      chart.newFrame(["syn", "noun", "acc"], ["sem", "father"])
    }
  }

  private SimpleQuery adjectiveNoun(String caze) {
    Construct syn = ['super': ['syn', 'adjective_noun'], activate: { f ->
      if (!f["sem"]) {
        f.addAlternative(["sem", "property_host"])
      }
    }]
    return new HeadConstructingQuery(caze, false, syn, ["noun", caze], "noun")
  }

}
