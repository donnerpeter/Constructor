package cons2

/**
 * @author peter
 */
class Russian implements Language {
  void analyzeWord(Chart chart, String w) {
    if (w == "мать") {
      def frame = chart.newFrame("syn", ["syn", "noun", "nom"], ["syn", "noun", "acc"])

      chart.newFrame(frame.team, "sem", ["sem", "mother"])
    }
    if (w == "любит") {
      def subject = new SimpleQuery("nom", "syn", true, ['super': ["syn", 'subject'], activate: { Frame f ->
        if (!f.team["sem"]) {
          def state = f.children[0].team["sem"]
          def experiencer = f.children[1].team["sem"]
          if (state && experiencer) {
            f.chart.construction(f.team, "sem", [state, experiencer], ["sem", "state_experiencer"] as Construct)
          }
        }
      }] as Construct)
      def object = new SimpleQuery("acc", "syn", true, ['super': ["syn", 'object'], activate: { Frame f ->
        if (!f.team["sem"]) {
          def state = f.children[0].team["sem"]
          def theme = f.children[1].team["sem"]
          if (state && theme) {
            f.chart.construction(f.team, "sem", [state, theme], ["sem", "state_theme"] as Construct)
          }
        }
      }] as Construct)

      def syn = ['super': ["syn", "verb"], activate: { Frame f ->
        subject.activate f
        object.activate f
      }, wrapUp: { Frame f ->
        if (subject.satisfied(f) && object.satisfied(f)) {
          return true
        }

        subject.weaken(f)
        object.weaken(f)

        def subjs = subject.allArgumentCandidates(f)
        def objs = object.allArgumentCandidates(f)

        if (objs.size() == 1) {
          subjs -= objs
          object.instantiate(f, objs[0])
        }
        if (subjs.size() == 1) {
          subject.instantiate(f, subjs[0])
        }

        return subject.satisfied(f) && object.satisfied(f)
      }] as Construct
      def frame = chart.newFrame("syn", syn)
      chart.newFrame(frame.team, "sem", ["sem", "love"])

      if (subject.activate(frame)) {
        chart.wrapUp subject.getArg(frame)
      }
      if (object.activate(frame)) {
        chart.wrapUp object.getArg(frame)
      }

    }
    if (w == "дочь") {
      def frame = chart.newFrame("syn", ["syn", "noun", "nom"], ["syn", "noun", "acc"])

      chart.newFrame(frame.team, "sem", ["sem", "daughter"])
    }
    if (w == "красивая") {
      def adj = adjectiveNoun("nom")
      def frame = chart.newFrame("syn", ['super': ['syn', 'красивая'], activate: { Frame f -> adj.activate(f) }])
      chart.newFrame(frame.team, "sem", ["sem", "beautiful"])
    }
    if (w == "красивую") {
      def adj = adjectiveNoun("acc")
      def frame = chart.newFrame("syn", ['super': ['syn', "красивая"], activate: { Frame f -> adj.activate(f) }])
      chart.newFrame(frame.team, "sem", ["sem", 'beautiful'])
    }
    if (w == "отец") {
      def frame = chart.newFrame("syn", ["syn", "noun", "nom"])
      chart.newFrame(frame.team, "sem", ["sem", "father"])
    }
    if (w == "отца") {
      def frame = chart.newFrame("syn", ["syn", "noun", "acc"])
      chart.newFrame(frame.team, "sem", ["sem", "father"])
    }
  }

  private SimpleQuery adjectiveNoun(String caze) {
    Construct syn = ['super': ['syn', 'adjective_noun'], activate: { f ->
      if (!f.team["sem"]) {
        def property = f.children[0].team["sem"]
        def host = f.children[1].team["sem"]
        if (property && host) {
          f.chart.construction(f.team, "sem", [property, host], ["sem", "property_host"] as Construct)
        }
      }
    }]
    return new SimpleQuery(caze, "syn", false, syn) {
      @Override
      protected Frame findArgument(Frame head) {
        def arg = super.findArgument(head)
        if (arg) {
          return arg
        }

        def choosingPattern = ["noun", caze]
        Construct mockSyn = [
                'super': ["syn", "noun", caze],
                adopt: { Frame f, boolean newTeam, Construct[] a ->
                  if (newTeam && a.any { it.ping("noun") }) {
                    f.removeAlternative((Construct) this)
                    a.each { f.addAlternative it }
                    f.chosenAs choosingPattern
                    return true
                  }
                  return false
                }]
        Construct mockSem = [
                'super': ["sem", "<contextual>"],
                adopt: { Frame f, boolean newTeam, Construct[] a ->
                  if (!newTeam) {
                    f.removeAlternative((Construct) this)
                    a.each { f.addAlternative it }
                    return true
                  }
                  return false
                }]
        def sem = head.chart.newFrame("sem", mockSem)
        return head.chart.newFrame(sem.team, "syn", mockSyn)
      }

    }
  }

}
