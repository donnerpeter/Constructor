package cons2

/**
 * @author peter
 */
class Update {
  Chart chart
  private Map<Frame, List<List<Aspect>>> newAspects = [:]
  private Map<Frame, Collection<Aspect>> justAppeared = [:]
  private Map<Frame, Map<String, Object>> confirmations = [:]
  private Map<Frame, Frame> merges = [:]
  private Set<Frame> wrapUps = []
  private Set<Frame> weakened = []
  private Frame beingProcessed
  private Map<Frame, Map<String, List<Function2<Frame, Update, Boolean>>>> newListeners = [:]
  private boolean dead

  Update(Chart chart, Map<Frame, Collection<Aspect>> justAppeared = [:], Set<Frame> wrapUps = []) {
    this.chart = chart
    this.justAppeared = justAppeared
    this.wrapUps.addAll wrapUps
  }

  static Aspect[] decodeAvm(Map<String, String> avm) {
    def aspects = []
    avm.each { role, value -> aspects << new Aspect(role, value) }
    return aspects as Aspect[]
  }

  void enrich(Map<String, String> avm, Frame host, Aspect aspect) {
    enrich(avm + [(aspect.role):aspect.value], host)
  }

  void enrich(Map<String, String> avm, Frame host) {
    enrich(host, decodeAvm(avm))
  }

  void enrich(Frame host, Aspect... aspects) {
    assert !dead
    assert host
    assert host.empty || aspects.any { it in host.strongAlternatives(it.role) }
    newAspects.get(host, []).add(aspects as List)
  }

  Frame newFrame(Map<String, String> avm, List<Frame> children) {
    assert !dead
    def frame = chart.newFrame(children)
    enrich avm, frame
    frame
  }

  void wrapUp(Frame frame) {
    assert !dead
    wrapUps << frame
  }

  void confirmChoice(Map<String, Object> pattern, Frame frame) {
    assert !dead
    confirmations.get(frame, [:]).putAll pattern
  }

  void weaken(Frame frame) {
    assert !dead
    weakened << frame
  }

  void listen(Map<String, Object> pattern, Function2<Frame, Update, Void> listener) {
    listen(pattern.keySet().iterator().next()) { f, u ->
      if (f.ping(pattern)) {
        listener(f, u)
        return true
      }
      return false
    }
  }

  void listen(String role, Function2<Frame, Update, Boolean> listener) {
    assert !dead
    assert beingProcessed != null
    def map = newListeners.get(beingProcessed, [:])
    map.get(role, []) << listener
  }

  void anticipate(Map<String, Object> pattern, Frame mock) {
    listen (pattern.keySet().iterator().next()) { real, upd2 ->
      if (real != mock && real.ping(pattern)) {
        upd2.merge(mock, real)
        return true
      }
      return false
    }
  }

  void apply() {
    weakened.each { chart.weaken it }
    confirmations.each { frame, pattern -> frame.chosenAs(pattern) }

    newListeners.each { frame, map ->
      def role2Listeners = chart.listeners.get(frame, [:])
      map.each { role, list ->
        role2Listeners.get(role, []).addAll(list)
      }
    }

    if (!newAspects && !justAppeared && !merges) {
      wrapUps.each { chart.wrapUp it }
      return
    }

    def reallyNewAspects = [:]
    def next = new Update(chart, reallyNewAspects, wrapUps)

    merges.each { loser, into -> chart.merge loser, into }

    justAppeared.each { frame, added ->
      added.each {
        if (!frame[it.role] || frame[it.role] == it) {
          next.beingProcessed = frame
          chart.language.aspectAppeared frame, it, next
          next.beingProcessed = null
        }                          
      }
    }

    Map<String, Set<Frame>> touched = [:]
    newAspects.each { frame, aspects ->
      def added = frame.richEnrich(aspects)
      reallyNewAspects[frame] = added
      added.each { touched.get(it.role, []) << frame }
    }

    chart.listeners.values().each { map ->
      map.each { role, actions ->
        if (role in touched.keySet()) {
          touched[role].each { def host ->
            List<Function2<Frame, Update, Boolean>> copy = [] + actions
            copy.each { action ->
              next.beingProcessed = host
              def satisfied = action.call(host, next)
              next.beingProcessed = null
              if (satisfied) {
                actions.remove action
              }
            }
          }
        }
      }
    }

    justAppeared.each { frame, added -> frame.initializeAspects added }

    dead = true

    next.apply()
  }

  def merge(Frame loser, Frame into) {
    merges[loser] = into
  }
}