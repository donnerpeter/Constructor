package cons2

/**
 * @author peter
 */
class Update {
  Chart chart
  private Map<Frame, Set<Aspect>> newAspects = [:]
  private Map<Frame, Set<Aspect>> justAppeared = [:]
  private Map<Frame, Map<String, Object>> confirmations = [:]
  private Set<Frame> wrapUps = []
  private Set<Frame> weakened = []
  private Frame beingProcessed
  private Map<Frame, Map<String, Function2<Frame, Update, Void>>> newListeners = [:]

  Update(Chart chart, Map<Frame, Set<Aspect>> justAppeared = [:], Set<Frame> wrapUps = []) {
    this.chart = chart
    this.justAppeared = justAppeared
    this.wrapUps.addAll wrapUps
  }

  void enrich(Frame host, Aspect... aspects) {
    newAspects.get(host, [] as LinkedHashSet).addAll(aspects)
  }

  Frame newFrame(List<Frame> children, Aspect... aspects) {
    def frame = chart.newFrame(children)
    enrich frame, aspects
    frame
  }

  void wrapUp(Frame frame) {
    wrapUps << frame
  }

  void confirmChoice(Map<String, Object> pattern, Frame frame) {
    frame.chosenAs pattern
    confirmations.get(frame, [:]).putAll pattern
  }

  void weaken(Frame frame) {
    weakened << frame
  }

  void listen(String role, Function2<Frame, Update, Void> listener) {
    assert beingProcessed
    def map = newListeners.get(beingProcessed, [:])
    assert !map[role]
    map[role] = listener
  }

  void apply() {
    weakened.each { chart.weaken it }
    confirmations.each { frame, pattern -> frame.chosenAs(pattern) }

    if (!newAspects && !justAppeared) {
      wrapUps.each { chart.wrapUp it }
      return
    }

    def next = new Update(chart, newAspects, wrapUps)

    justAppeared.each { frame, added ->
      added.each {
        if (!frame[it.role] || frame[it.role] == it) {
          beingProcessed = frame
          chart.language.aspectAppeared frame, it, next
          beingProcessed = null
        }                          
      }
    }

    Map<String, Set<Frame>> touched = [:]
    newAspects.each { frame, aspects ->
      aspects.each { touched.get(it.role, []) << frame }

      frame.enrich(aspects as Aspect[])
    }

    chart.contextChanged next

    chart.listeners.values().each { map ->
      map.each { role, action ->
        if (role in touched.keySet()) {
          touched[role].each { def host ->
            action.call(host, next)
          }
        }
      }
    }

    chart.listeners.putAll newListeners

    justAppeared.each { frame, added -> frame.initializeAspects added }

    next.apply()
  }

}