package cons3

import groovy.transform.EqualsAndHashCode

/**
 * @author peter
 */
@EqualsAndHashCode
class Chart {
  final List<Assignment<Variable>> __assignments
  private final FList<Object> currentMetas
  final IdentityHashMap<Assignment<Variable>, FList<Object>> __metas
  final FLinkedMap<Set<Variable>, Integer> __unifications
  private final Map<Variable, Variable> __baseVars
  private final FLinkedMap<Object, List<Set<Variable>>> metaUnifications
  final int section

  private Chart(Map args, Chart base) {
    __assignments = args.getOrElse('assignments', base?.__assignments)
    currentMetas = args.getOrElse('currentMetas', base?.currentMetas)
    __metas = args.getOrElse('metas', base?.__metas)
    __unifications = args.getOrElse('unifications', base?.__unifications)
    __baseVars = args.getOrElse('baseVars', base?.__baseVars)
    metaUnifications = args.getOrElse('metaUnifications', base?.metaUnifications)
    section = args.getOrElse('section', base?.section)
  }

  private static <T> T getOrElse(Map m, String key, T defaultValue) {
    def result = (T) m.containsKey(key) ? m[key] : defaultValue
    assert result != null
    return result
  }

  Chart() {
    this([assignments:[],
            currentMetas:FList.emptyList, metas:new IdentityHashMap(),
            metaUnifications:FLinkedMap.emptyMap,
            section:1,
            unifications:FLinkedMap.emptyMap, baseVars:[:]], null)
  }

  Chart clone(Map update) {
    return new Chart(update, this)
  }

  List<Assignment<Variable>> getActiveAssignments() {
    return __assignments
  }

  private List<Frame> cachedFrames

  List<Frame> getFrames() {
    if (cachedFrames == null) {
      cachedFrames = new ArrayList<Frame>(new LinkedHashSet<Frame>(vars.collect { it.frame(this) }))
    }
    return cachedFrames
  }


  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    List<Assignment<Frame>> assignments = allAssignments
    Assignment<Frame> i1 = assignments.find { Assignment it -> it.frame == f1 && it.property == a1 }
    Assignment<Frame> i2 = assignments.find { Assignment it -> it.frame == f2 && it.property == a2 }
    if (!i1 || !i2) return false
    return i1.generation < i2.generation
  }

  List<Variable> getVars() {
    Set<Variable> set = [] as LinkedHashSet
    for (assignment in activeAssignments) {
      set << assignment.frame
      if (assignment.value instanceof Variable) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  private List<Assignment<Frame>> assignmentCache

  List<Assignment<Frame>> getAllAssignments() {
    def result = assignmentCache
    if (result != null) {
      return result
    }

    result = activeAssignments.collect { framify(it) }
    assignmentCache = result
    return result
  }

  Assignment<Frame> framify(Assignment<Variable> it) {
    def oldValue = it.value
    def newValue = oldValue instanceof String ? oldValue : ((Variable) (Object) oldValue).frame(this)
    Frame newFrame = it.frame.frame(this)
    return new Assignment<Frame>(newFrame, it.property, newValue, it.generation, it.section)
  }

  Chart advanceSection() {
    clone(section:section+1)
  }

  Chart assign(Variable var, String property, def value, int generation) {
    assert value instanceof String || value instanceof Variable
    assert var

    def assignment = new Assignment(var, property, value, generation, section)
    if (getActiveAssignments().contains(assignment)) {
      return this
    }

    List<Assignment<Variable>> newAsss = __assignments + assignment

    def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>(__metas)
    newMetas[assignment] = currentMetas
    return clone(assignments:newAsss, metas:newMetas)
  }

  private Function2<Variable, Integer, String> createNamer() {
    Map<Variable, String> shortNames = [:]
    Map<Variable, Integer> sections = [:]
    Map<Integer, Character> nextShortName = [:]
    return { Variable var, Integer currentSection ->
      var = getUnifiedVar(var)
      if (!(var in shortNames)) {
        def ch = nextShortName.get(currentSection, 'A' as Character)
        shortNames[var] = String.valueOf(ch)
        nextShortName[currentSection] = (ch + 1) as Character
        sections[var] = currentSection
      }
      if (currentSection == sections[var]) return shortNames[var]
      return shortNames[var] + "@" + sections[var]
    }
  }

  String presentable() {

    Function2<Variable, Integer, String> namer = createNamer()

    Set<Assignment<Frame>> handled = []
    Set<Variable> prevMetas = []
    List<String> lines = []
    int curSection = 1

    for (eq in activeAssignments) {
      if (curSection != eq.section) {
        lines << "-- ${eq.section}:"
        curSection = eq.section
      }
      if (!handled.add(framify(eq))) {
        continue
      }

      Set<Variable> metas = __metas[eq].findAll { it instanceof Variable } as Set
      for (finished in (prevMetas - metas)) {
        lines << "</${namer(finished, curSection)}>"
      }
      for (started in (metas - prevMetas)) {
        lines << "<${namer(started, curSection)}>"
      }
      prevMetas = metas
      lines << "${namer(eq.frame, curSection)}.$eq.property=${ eq.value instanceof String ? eq.value : namer((Variable)eq.value, curSection)}"
    }
    for (finished in prevMetas) {
      lines << "</${namer(finished, curSection)}>"
    }
    return lines.join("\n")
  }

  Chart startMeta(meta) {
    return clone(currentMetas: currentMetas + meta)
  }

  Chart finishMeta(meta) {
    return clone(currentMetas: currentMetas - meta)
  }

  Chart removeDifference(diffMeta) {
    List<Assignment<Variable>> newAssignments = __assignments
    newAssignments = newAssignments.findAll { __metas[it] != [diffMeta] }
    def sets = metaUnifications[diffMeta]
    def result = clone(metaUnifications:metaUnifications.removeKey(diffMeta))
    if (sets) {
      for (pair in sets) {
        result = result.removeUnificationConstraint(pair.iterator().next(), (pair as List<Variable>)[1])
      }
    }

    final def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>()
    for (a in __metas.keySet()) {
      newMetas[a] = __metas[a] - diffMeta
    }
    if (newMetas != __metas) {
      result = result.clone(metas:newMetas)
    }

    if (newAssignments == __assignments) {
      return result
    }
    return result.clone(assignments:newAssignments)
  }

  private void fillGroup(List<Set<Variable>> pairs, Variable current, LinkedHashSet<Variable> result) {
    if (!result.add(current)) {
      return
    }

    for (p in pairs) {
      if (current in p) {
        for (var in p) {
          fillGroup(pairs, var, result)
        }
      }
    }
  }

  private Map<Variable, Variable> updateGroup(FLinkedMap<Set<Variable>, Integer> newUnifications, Variable var1, Map<Variable, Variable> newBaseVars) {
    LinkedHashSet<Variable> group = []
    fillGroup(newUnifications.keyList(), var1, group)
    Variable base = group.iterator().next()
    for (var in group) {
      assert !var.light
      newBaseVars = newBaseVars + [(var):base]
    }
    return newBaseVars
  }

  Chart addUnificationConstraint(Variable var1, Variable var2) {
    assert var1 != var2
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair] ?: 0
    def newUnifications = __unifications.putValue(pair, oldCount + 1)
    Map<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 0) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
    }

    def newMetaUnifications = metaUnifications
    for (meta in currentMetas) {
      List<Set<Variable>> newValue = new ArrayList<Set<Variable>>(newMetaUnifications[meta] ?: [])
      newValue.add(pair)
      newMetaUnifications = newMetaUnifications.putValue(meta, newValue)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars, metaUnifications:newMetaUnifications)
  }

  Chart removeUnificationConstraint(Variable var1, Variable var2) {
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair]
    assert oldCount : "$pair $__unifications"
    def newUnifications = oldCount > 1 ? __unifications.putValue(pair, oldCount - 1) : __unifications.removeKey(pair)
    Map<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 1) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
      newBaseVars = updateGroup(newUnifications, var2, newBaseVars)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars)
  }

  Variable getUnifiedVar(Variable var) {
    return __baseVars[var.base] ?: var.base
  }

}
