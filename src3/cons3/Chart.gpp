package cons3

/**
 * @author peter
 */
class Chart {
  final Map<Situation, LinkedHashSet<Assignment<Variable>>> __assignments
  final Map<Variable, Situation> __vars
  private final FList<Variable> currentMetas
  final FLinkedMap<Assignment<Variable>, FList<Variable>> __metas
  private final FLinkedMap<Set<Variable>, Integer> __unifications
  private final FLinkedMap<Variable, Variable> __baseVars

  private Chart(Map args) {
    __assignments = args.assignments
    __vars = args.vars
    currentMetas = args.currentMetas
    __metas = args.metas
    __unifications = args.unifications
    __baseVars = args.baseVars
  }

  Chart() {
    this(assignments:[:], vars:[:], currentMetas:FList.emptyList, metas:FLinkedMap.emptyMap, unifications:FLinkedMap.emptyMap, baseVars:FLinkedMap.emptyMap)
  }

  Chart clone(Map update) {
    Map current = [assignments:__assignments, vars:__vars, currentMetas:currentMetas, metas:__metas, unifications:__unifications, baseVars:__baseVars]
    current.putAll(update)
    return new Chart(current)
  }

  List<Situation> getSituations() {
    def result = (__assignments.keySet()) as LinkedHashSet
    __assignments.values().each {
      it.each {
        if (it.value instanceof Situation) {
          result << (Situation) it.value
        }
      }
    }
    return result as List
  }

  List<Frame> frames(Situation situation) {
    vars(situation).collect { it.frame(this) }
  }

  List<Frame> getFrames() {
    situations.collect { frames(it) }.flatten() as List
  }


  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    assert f1.situation == f2.situation
    List<Assignment<Variable>> assignments = __assignments[f1.situation] as List
    Assignment<Variable> i1 = assignments.find { Assignment it -> it.frame == f1.var && it.property == a1 }
    Assignment<Variable> i2 = assignments.find { Assignment it -> it.frame == f2.var && it.property == a2 }
    if (!i1 || !i2) return false
    return i1.generation < i2.generation
  }

  List<Variable> vars(Situation situation) {
    Set<Variable> set = [] as LinkedHashSet
    for (assignment in __assignments[situation]) {
      if (assignment.frame != situation) {
        set << assignment.frame
      }
      if (assignment.value instanceof Variable && !(assignment.value instanceof Situation)) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  List<Assignment<Frame>> allAssignments(Situation situation) {
    __assignments[situation].collect {
      def oldValue = it.value
      def newValue = oldValue instanceof String ? oldValue : ((Variable) (Object)oldValue).frame(this) //todo alex
      Frame newFrame = it.frame.frame(this)
      new Assignment<Frame>(newFrame, it.property, newValue, it.generation)
    }
  }

  Chart assign(Variable var, Situation situation, String property, def value, int generation) {
    assert value instanceof String || value instanceof Variable
    assert var

    def assignment = new Assignment(var, property, value, generation)
    if (__assignments[situation]?.contains(assignment)) {
      return this
    }

    Map<Situation, LinkedHashSet<Assignment<Variable>>> newAsss = [:] + __assignments
    newAsss[situation] = newAsss.get(situation, [] as LinkedHashSet) + [assignment]

    Map<Variable, Situation> newVars = [:] + __vars
    newVars[var] = situation
    if (value instanceof Variable && !newVars[value]) {
      newVars[value] = situation
    }
    
    return clone(assignments:newAsss, vars:newVars, metas:__metas + [(assignment):currentMetas])
  }

  String presentable() {
    situations.collect { it.presentable(this) }.findAll { it.trim().size() > 0 }.join("\n--\n")
  }

  Chart startMeta(Variable meta) {
    return clone(currentMetas: currentMetas + meta)
  }

  Chart finishMeta(Variable meta) {
    return clone(currentMetas: currentMetas - meta)
  }

  Chart removeDifference(Pair<Chart, Chart> diff) {
    def before = diff.first
    def after = diff.second

    final def newAssignments = new LinkedHashMap<Situation, LinkedHashSet<Assignment<Variable>>>(__assignments)
    for (sit in after.__assignments.keySet()) {
      if (!(sit in before.__assignments)) {
        newAssignments.remove(sit)
      } else if (newAssignments[sit]) {
        LinkedHashSet<Assignment<Variable>> af = after.__assignments[sit]
        def bef = before.__assignments[sit]
        if (af.size() > bef.size()) {
          def delta = new LinkedHashSet<Assignment<Variable>>(af)
          delta.removeAll(bef)
          newAssignments[sit] = new LinkedHashSet<Assignment<Variable>>(newAssignments[sit])
          newAssignments[sit].removeAll(delta)
        }
      }
    }
    if (newAssignments == __assignments) {
      return this
    }
    return clone(assignments:newAssignments)
  }

  Chart addUnificationConstraint(Variable var1, Variable var2) {
    this
  }
}
