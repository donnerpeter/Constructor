package cons3

import groovy.transform.EqualsAndHashCode

/**
 * @author peter
 */
@EqualsAndHashCode
class Chart {
  final List<Assignment<Variable>> __assignments
  private final FList<Object> currentMetas
  final IdentityHashMap<Assignment<Variable>, FList<Object>> __metas
  final FLinkedMap<Set<Variable>, Integer> __unifications
  private final Map<Variable, Variable> __baseVars
  private final FLinkedMap<Object, List<Set<Variable>>> metaUnifications

  private Chart(Map args) {
    __assignments = args.assignments
    currentMetas = args.currentMetas
    __metas = args.metas
    __unifications = args.unifications
    __baseVars = args.baseVars
    metaUnifications = args.metaUnifications
  }

  Chart() {
    this(assignments:[],
            currentMetas:FList.emptyList, metas:new IdentityHashMap(),
            metaUnifications:FLinkedMap.emptyMap,
            unifications:FLinkedMap.emptyMap, baseVars:[:])
  }

  Chart clone(Map update) {
    Map current = [assignments:__assignments,
            currentMetas:currentMetas, metas:__metas,
            metaUnifications:metaUnifications,
            unifications:__unifications, baseVars:__baseVars]
    current.putAll(update)
    return new Chart(current)
  }

  List<Assignment<Variable>> getActiveAssignments() {
    return __assignments
  }

  private List<Frame> cachedFrames

  List<Frame> getFrames() {
    if (cachedFrames == null) {
      cachedFrames = (vars.collect { it.frame(this) } as LinkedHashSet) as List
    }
    return cachedFrames
  }


  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    List<Assignment<Frame>> assignments = allAssignments
    Assignment<Frame> i1 = assignments.find { Assignment it -> it.frame == f1 && it.property == a1 }
    Assignment<Frame> i2 = assignments.find { Assignment it -> it.frame == f2 && it.property == a2 }
    if (!i1 || !i2) return false
    return i1.generation < i2.generation
  }

  List<Variable> getVars() {
    Set<Variable> set = [] as LinkedHashSet
    for (assignment in activeAssignments) {
      set << assignment.frame
      if (assignment.value instanceof Variable) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  private List<Assignment<Frame>> assignmentCache

  List<Assignment<Frame>> getAllAssignments() {
    def result = assignmentCache
    if (result != null) {
      return result
    }

    result = activeAssignments.collect {
      def oldValue = it.value
      def newValue = oldValue instanceof String ? oldValue : ((Variable) (Object)oldValue).frame(this) //todo alex
      Frame newFrame = it.frame.frame(this)
      new Assignment<Frame>(newFrame, it.property, newValue, it.generation)
    }
    assignmentCache = result
    return result
  }

  Chart assign(Variable var, String property, def value, int generation) {
    assert value instanceof String || value instanceof Variable
    assert var

    def assignment = new Assignment(var, property, value, generation)
    if (getActiveAssignments().contains(assignment)) {
      return this
    }

    List<Assignment<Variable>> newAsss = __assignments + assignment

    def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>(__metas)
    newMetas[assignment] = currentMetas
    return clone(assignments:newAsss, metas:newMetas)
  }

  String presentable() {
    Map<Variable, String> naming = [:]

    (vars.collect { getUnifiedVar(it) } as LinkedHashSet<Variable>).eachWithIndex { Variable var, int i ->
      naming[var] = String.valueOf((char)(i + (int)'A'.charAt(0)))
    }
    vars.each {
      naming[it] = naming[getUnifiedVar(it)]
    }

    Set<Variable> prevMetas = []
    LinkedHashSet<String> lines = []
    for (eq in activeAssignments) {
      Set<Variable> metas = __metas[eq].findAll { it instanceof Variable } as Set
      for (finished in (prevMetas - metas)) {
        lines << "</${naming[finished]}>"
      }
      for (started in (metas - prevMetas)) {
        lines << "<${naming[started]}>"
      }
      prevMetas = metas
      lines << "${naming[eq.frame]}.$eq.property=${ eq.value instanceof String ? eq.value : naming[(Variable)eq.value]}"
    }
    for (finished in prevMetas) {
      lines << "</${naming[finished]}>"
    }
    return lines.join("\n")
  }

  Chart startMeta(meta) {
    return clone(currentMetas: currentMetas + meta)
  }

  Chart finishMeta(meta) {
    return clone(currentMetas: currentMetas - meta)
  }

  Chart removeDifference(diffMeta) {
    List<Assignment<Variable>> newAssignments = __assignments
    newAssignments = newAssignments.findAll { __metas[it] != [diffMeta] }
    def sets = metaUnifications[diffMeta]
    def result = clone(metaUnifications:metaUnifications.removeKey(diffMeta))
    if (sets) {
      for (pair in sets) {
        result = result.removeUnificationConstraint(pair.iterator().next(), (pair as List<Variable>)[1])
      }
    }

    final def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>()
    for (a in __metas.keySet()) {
      newMetas[a] = __metas[a] - diffMeta
    }
    if (newMetas != __metas) {
      result = result.clone(metas:newMetas)
    }

    if (newAssignments == __assignments) {
      return result
    }
    return result.clone(assignments:newAssignments)
  }

  private void fillGroup(List<Set<Variable>> pairs, Variable current, LinkedHashSet<Variable> result) {
    if (!result.add(current)) {
      return
    }

    for (p in pairs) {
      if (current in p) {
        for (var in p) {
          fillGroup(pairs, var, result)
        }
      }
    }
  }

  private Map<Variable, Variable> updateGroup(FLinkedMap<Set<Variable>, Integer> newUnifications, Variable var1, Map<Variable, Variable> newBaseVars) {
    LinkedHashSet<Variable> group = []
    fillGroup(newUnifications.keyList(), var1, group)
    Variable base = group.iterator().next()
    for (var in group) {
      assert !var.light
      newBaseVars = newBaseVars + [(var):base]
    }
    return newBaseVars
  }

  Chart addUnificationConstraint(Variable var1, Variable var2) {
    assert var1 != var2
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair] ?: 0
    def newUnifications = __unifications.putValue(pair, oldCount + 1)
    Map<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 0) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
    }

    def newMetaUnifications = metaUnifications
    for (meta in currentMetas) {
      List<Set<Variable>> newValue = new ArrayList<Set<Variable>>(newMetaUnifications[meta] ?: [])
      newValue.add(pair)
      newMetaUnifications = newMetaUnifications.putValue(meta, newValue)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars, metaUnifications:newMetaUnifications)
  }

  Chart removeUnificationConstraint(Variable var1, Variable var2) {
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair]
    assert oldCount : "$pair $__unifications"
    def newUnifications = oldCount > 1 ? __unifications.putValue(pair, oldCount - 1) : __unifications.removeKey(pair)
    Map<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 1) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
      newBaseVars = updateGroup(newUnifications, var2, newBaseVars)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars)
  }

  Variable getUnifiedVar(Variable var) {
    return __baseVars[var.base] ?: var.base
  }

}
