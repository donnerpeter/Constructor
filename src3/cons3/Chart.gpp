package cons3

import groovy.transform.EqualsAndHashCode

/**
 * @author peter
 */
@EqualsAndHashCode
class Chart {
  final Map<Situation, List<Assignment<Variable>>> __assignments
  final Map<Variable, Situation> __vars
  private final FList<Object> currentMetas
  final IdentityHashMap<Assignment<Variable>, FList<Object>> __metas
  private final FLinkedMap<Set<Variable>, Integer> __unifications
  private final FLinkedMap<Variable, Variable> __baseVars
  private final FLinkedMap<Object, List<Set<Variable>>> metaUnifications

  private Chart(Map args) {
    __assignments = args.assignments
    __vars = args.vars
    currentMetas = args.currentMetas
    __metas = args.metas
    __unifications = args.unifications
    __baseVars = args.baseVars
    metaUnifications = args.metaUnifications
  }

  Chart() {
    this(assignments:[:], vars:[:], 
            currentMetas:FList.emptyList, metas:new IdentityHashMap(),
            metaUnifications:FLinkedMap.emptyMap,
            unifications:FLinkedMap.emptyMap, baseVars:FLinkedMap.emptyMap)
  }

  Chart clone(Map update) {
    Map current = [assignments:__assignments, vars:__vars, 
            currentMetas:currentMetas, metas:__metas,
            metaUnifications:metaUnifications,
            unifications:__unifications, baseVars:__baseVars]
    current.putAll(update)
    return new Chart(current)
  }

  List<Assignment<Variable>> getActiveAssignments(Situation situation) {
    def all = (__assignments[situation] ?: []) as List
    return all
  }

  List<Situation> getSituations() {
    def result = (__assignments.keySet()) as LinkedHashSet
    __assignments.values().each {
      it.each {
        if (it.value instanceof Situation) {
          result << (Situation) it.value
        }
      }
    }
    return result as List
  }

  LinkedHashSet<Frame> frames(Situation situation) {
    new LinkedHashSet<Frame>(vars(situation).collect { it.frame(this) })
  }

  List<Frame> getFrames() {
    situations.collect { frames(it) }.flatten() as List
  }


  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    assert f1.situation == f2.situation
    List<Assignment<Frame>> assignments = allAssignments(f1.situation)
    Assignment<Frame> i1 = assignments.find { Assignment it -> it.frame == f1 && it.property == a1 }
    Assignment<Frame> i2 = assignments.find { Assignment it -> it.frame == f2 && it.property == a2 }
    if (!i1 || !i2) return false
    return i1.generation < i2.generation
  }

  List<Variable> vars(Situation situation) {
    Set<Variable> set = [] as LinkedHashSet
    for (assignment in getActiveAssignments(situation)) {
      if (assignment.frame != situation) {
        set << assignment.frame
      }
      if (assignment.value instanceof Variable && !(assignment.value instanceof Situation)) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  List<Assignment<Frame>> allAssignments(Situation situation) {
    getActiveAssignments(situation).collect {
      def oldValue = it.value
      def newValue = oldValue instanceof String ? oldValue : ((Variable) (Object)oldValue).frame(this) //todo alex
      Frame newFrame = it.frame.frame(situation, this)
      new Assignment<Frame>(newFrame, it.property, newValue, it.generation)
    }
  }

  Chart assign(Variable var, Situation situation, String property, def value, int generation) {
    assert value instanceof String || value instanceof Variable
    assert var

    def assignment = new Assignment(var, property, value, generation)
    if (getActiveAssignments(situation).contains(assignment)) {
      return this
    }

    Map<Situation, List<Assignment<Variable>>> newAsss = [:] + __assignments
    newAsss[situation] = newAsss.get(situation, []) + assignment

    Map<Variable, Situation> newVars = [:] + __vars
    newVars[var] = situation
    if (value instanceof Variable && !newVars[value]) {
      newVars[value] = situation
    }

    def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>(__metas)
    newMetas[assignment] = currentMetas
    return clone(assignments:newAsss, vars:newVars, metas:newMetas)
  }

  String presentable() {
    situations.collect { it.presentable(this) }.findAll { it.trim().size() > 0 }.join("\n--\n")
  }

  Chart startMeta(meta) {
    return clone(currentMetas: currentMetas + meta)
  }

  Chart finishMeta(meta) {
    return clone(currentMetas: currentMetas - meta)
  }

  Chart removeDifference(diffMeta) {
    final def newAssignments = new LinkedHashMap<Situation, List<Assignment<Variable>>>()
    for (sit in __assignments.keySet()) {
      List<Assignment<Variable>> assignments = __assignments[sit]
      def filtered = assignments.findAll { __metas[it] != [diffMeta] }
      if (filtered) {
        newAssignments[sit] = filtered
      }
    }
    def sets = metaUnifications[diffMeta]
    def result = clone(metaUnifications:metaUnifications.removeKey(diffMeta))
    if (sets) {
      for (pair in sets) {
        result = result.removeUnificationConstraint(pair.iterator().next(), (pair as List<Variable>)[1])
      }
    }
    
    final def newMetas = new IdentityHashMap<Assignment<Variable>, FList<Object>>()
    for (a in __metas.keySet()) {
      newMetas[a] = __metas[a] - diffMeta
    }
    if (newMetas != __metas) {
      result = result.clone(metas:newMetas)
    }
    
    if (newAssignments == __assignments) {
      return result
    }
    return result.clone(assignments:newAssignments)
  }

  private void fillGroup(List<Set<Variable>> pairs, Variable current, LinkedHashSet<Variable> result) {
    if (!result.add(current)) {
      return
    }

    for (p in pairs) {
      if (current in p) {
        for (var in p) {
          fillGroup(pairs, var, result)
        }
      }
    }
  }

  private FLinkedMap<Variable, Variable> updateGroup(FLinkedMap<Set<Variable>, Integer> newUnifications, Variable var1, FLinkedMap<Variable, Variable> newBaseVars) {
    LinkedHashSet<Variable> group = []
    fillGroup(newUnifications.keyList(), var1, group)
    Variable base = group.iterator().next()
    for (var in group) {
      assert !var.light
      newBaseVars = newBaseVars.putValue(var, base)
    }
    return newBaseVars
  }

  Chart addUnificationConstraint(Variable var1, Variable var2) {
    assert var1 != var2
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair] ?: 0
    def newUnifications = __unifications.putValue(pair, oldCount + 1)
    FLinkedMap<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 0) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
    }
    
    def newMetaUnifications = metaUnifications
    for (meta in currentMetas) {
      List<Set<Variable>> newValue = new ArrayList<Set<Variable>>(newMetaUnifications[meta] ?: [])
      newValue.add(pair)
      newMetaUnifications = newMetaUnifications.putValue(meta, newValue)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars, metaUnifications:newMetaUnifications)
  }

  Chart removeUnificationConstraint(Variable var1, Variable var2) {
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair]
    assert oldCount : "$pair $__unifications"
    def newUnifications = oldCount > 1 ? __unifications.putValue(pair, oldCount - 1) : __unifications.removeKey(pair)
    FLinkedMap<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 1) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
      newBaseVars = updateGroup(newUnifications, var2, newBaseVars)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars)
  }

  Variable getUnifiedVar(Variable var) {
    return __baseVars[var] ?: var.base
  }

  Chart separateUnifications(Set<Variable> oldVars, Set<Variable> withVariables) {
    Chart result = this
    Set<Set<Variable>> toRemove = []
    for (pair in __unifications.keySet()) {
      Variable fst = (pair as List)[0]
      Variable snd = (pair as List)[1]
      if (fst in withVariables && snd in oldVars || snd in withVariables && fst in oldVars) {
        result = result.removeUnificationConstraint(fst, snd)
        toRemove << pair
      }
    }
    FLinkedMap<Object, List<Set<Variable>>> newMetaUnifications = FLinkedMap.emptyMap
    for (meta in metaUnifications.keySet()) {
      newMetaUnifications = newMetaUnifications + [(meta):metaUnifications[meta] - toRemove]
    }
    result.clone(metaUnifications:newMetaUnifications)
  }
}
