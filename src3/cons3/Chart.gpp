package cons3

/**
 * @author peter
 */
class Chart {
  final Map<Situation, LinkedHashSet<Assignment<Variable>>> __assignments
  final Map<Variable, Situation> __vars
  private final FList<Object> currentMetas
  final FLinkedMap<Assignment<Variable>, FList<Object>> __metas
  private final FLinkedMap<Set<Variable>, Integer> __unifications
  private final FLinkedMap<Variable, Variable> __baseVars

  private Chart(Map args) {
    __assignments = args.assignments
    __vars = args.vars
    currentMetas = args.currentMetas
    __metas = args.metas
    __unifications = args.unifications
    __baseVars = args.baseVars
  }

  Chart() {
    this(assignments:[:], vars:[:], currentMetas:FList.emptyList, metas:FLinkedMap.emptyMap, unifications:FLinkedMap.emptyMap, baseVars:FLinkedMap.emptyMap)
  }

  Chart clone(Map update) {
    Map current = [assignments:__assignments, vars:__vars, currentMetas:currentMetas, metas:__metas, unifications:__unifications, baseVars:__baseVars]
    current.putAll(update)
    return new Chart(current)
  }

  List<Situation> getSituations() {
    def result = (__assignments.keySet()) as LinkedHashSet
    __assignments.values().each {
      it.each {
        if (it.value instanceof Situation) {
          result << (Situation) it.value
        }
      }
    }
    return result as List
  }

  List<Frame> frames(Situation situation) {
    (vars(situation).collect { it.frame(this) } as LinkedHashSet<Frame>) as List<Frame>
  }

  List<Frame> getFrames() {
    situations.collect { frames(it) }.flatten() as List
  }


  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    assert f1.situation == f2.situation
    List<Assignment<Frame>> assignments = allAssignments(f1.situation)
    Assignment<Frame> i1 = assignments.find { Assignment it -> it.frame == f1 && it.property == a1 }
    Assignment<Frame> i2 = assignments.find { Assignment it -> it.frame == f2 && it.property == a2 }
    if (!i1 || !i2) return false
    return i1.generation < i2.generation
  }

  List<Variable> vars(Situation situation) {
    Set<Variable> set = [] as LinkedHashSet
    for (assignment in __assignments[situation]) {
      if (assignment.frame != situation) {
        set << assignment.frame
      }
      if (assignment.value instanceof Variable && !(assignment.value instanceof Situation)) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  List<Assignment<Frame>> allAssignments(Situation situation) {
    __assignments[situation].collect {
      def oldValue = it.value
      def newValue = oldValue instanceof String ? oldValue : ((Variable) (Object)oldValue).frame(this) //todo alex
      Frame newFrame = it.frame.frame(this)
      new Assignment<Frame>(newFrame, it.property, newValue, it.generation)
    }
  }

  Chart assign(Variable var, Situation situation, String property, def value, int generation) {
    assert value instanceof String || value instanceof Variable
    assert var

    def assignment = new Assignment(var, property, value, generation)
    if (__assignments[situation]?.contains(assignment)) {
      return this
    }

    Map<Situation, LinkedHashSet<Assignment<Variable>>> newAsss = [:] + __assignments
    newAsss[situation] = newAsss.get(situation, [] as LinkedHashSet) + [assignment]

    Map<Variable, Situation> newVars = [:] + __vars
    newVars[var] = situation
    if (value instanceof Variable && !newVars[value]) {
      newVars[value] = situation
    }
    
    return clone(assignments:newAsss, vars:newVars, metas:__metas + [(assignment):currentMetas])
  }

  String presentable() {
    situations.collect { it.presentable(this) }.findAll { it.trim().size() > 0 }.join("\n--\n")
  }

  Chart startMeta(meta) {
    return clone(currentMetas: currentMetas + meta)
  }

  Chart finishMeta(meta) {
    return clone(currentMetas: currentMetas - meta)
  }

  Chart removeDifference(Pair<Chart, Chart> diff) {
    def before = diff.first
    def after = diff.second

    final def newAssignments = new LinkedHashMap<Situation, LinkedHashSet<Assignment<Variable>>>(__assignments)
    for (sit in after.__assignments.keySet()) {
      if (!(sit in before.__assignments)) {
        newAssignments.remove(sit)
      } else if (newAssignments[sit]) {
        LinkedHashSet<Assignment<Variable>> af = after.__assignments[sit]
        def bef = before.__assignments[sit]
        if (af.size() > bef.size()) {
          def delta = new LinkedHashSet<Assignment<Variable>>(af)
          delta.removeAll(bef)
          newAssignments[sit] = new LinkedHashSet<Assignment<Variable>>(newAssignments[sit])
          newAssignments[sit].removeAll(delta)
        }
      }
    }
    if (newAssignments == __assignments) {
      return this
    }
    return clone(assignments:newAssignments)
  }

  private void fillGroup(List<Set<Variable>> pairs, Variable current, LinkedHashSet<Variable> result) {
    if (!result.add(current)) {
      return
    }

    for (p in pairs) {
      if (current in p) {
        for (var in p) {
          fillGroup(pairs, var, result)
        }
      }
    }
  }

  private FLinkedMap<Variable, Variable> updateGroup(FLinkedMap<Set<Variable>, Integer> newUnifications, Variable var1, FLinkedMap<Variable, Variable> newBaseVars) {
    LinkedHashSet<Variable> group = []
    fillGroup(newUnifications.keyList(), var1, group)
    Variable base = group.iterator().next()
    for (var in group) {
      assert !var.light
      newBaseVars = newBaseVars.putValue(var, base)
    }
    return newBaseVars
  }

  Chart addUnificationConstraint(Variable var1, Variable var2) {
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair] ?: 0
    def newUnifications = __unifications.putValue(pair, oldCount + 1)
    FLinkedMap<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 0) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars)
  }

  Chart removeUnificationConstraint(Variable var1, Variable var2) {
    def pair = [var1, var2] as LinkedHashSet<Variable>
    def oldCount = __unifications[pair]
    assert oldCount
    def newUnifications = oldCount > 1 ? __unifications.putValue(pair, oldCount - 1) : __unifications.removeKey(pair)
    FLinkedMap<Variable, Variable> newBaseVars = __baseVars
    if (oldCount == 1) {
      newBaseVars = updateGroup(newUnifications, var1, newBaseVars)
      newBaseVars = updateGroup(newUnifications, var2, newBaseVars)
    }
    clone(unifications:newUnifications, baseVars:newBaseVars)
  }

  Variable getUnifiedVar(Variable var) {
    return __baseVars[var] ?: var
  }

}
