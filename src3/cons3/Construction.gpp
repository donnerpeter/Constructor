package cons3

/**
 * @author peter
 */
class Construction {
  final Function2<ParsingState, Map, ParsingState> action
  final String name
  final List<String> requiredAttrs
  String headAttr
  String beingMissedAttr
  Function2<Mite, Screen, Screen> displayAction = { mite, screen ->
    return screen.hideObscuredByHead(mite)
  }
  Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> enrichAction = { mite, contribution, state ->
    return mite.unifyWherePossible(contribution)
  }

  private Construction(String name, Function2<ParsingState, Map, ParsingState> action, List<String> requiredAttrs) {
    this.action = action
    this.name = name
    this.requiredAttrs = []
    for (attr in requiredAttrs) {
      if (attr.startsWith('+')) {
        headAttr = attr
        attr = attr.substring(1)
      }
      if (attr.startsWith('*')) {
        beingMissedAttr = attr
        attr = attr.substring(1)
      }
      this.requiredAttrs << attr
    }
  }

  Construction screeningMites(Function2<Mite, Screen, Screen> action) {
    displayAction = action
    return this
  }

  Construction enrichingMites(Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> action) {
    enrichAction = action
    return this
  }

  Mite call(Map miteContents) {
    return new Mite(miteContents, this)
  }

  @Override
  String toString() {
    return name
  }

  boolean isExecutable(Collection<Mite> mites) {
    if (!requiredAttrs) return true
    
    Set<String> absent = requiredAttrs as Set
    for (mite in mites) {
      absent.removeAll(Util.intersect(absent, mite.contents.keyList()))
      if (!absent) {
        return true
      }
    }

    return false
  }

  static Construction cxt(String name, List<String> requiredAttrs = [], Function2<ParsingState, Map, ParsingState> cl) {
    new Construction(name, cl, requiredAttrs)
  }
  static Construction cxt(String name, List<String> requiredAttrs = [], Closure cl) {
    new Construction(name, cl as Function2, requiredAttrs)
  }

}
