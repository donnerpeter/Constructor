package cons3

/**
 * @author peter
 */
class Construction {
  private Function2<ParsingState, Map, ParsingState> action = { state, args -> state }
  final String name
  private final List<String> requiredAttrs
  private String headAttr
  private String beingMissedAttr
  private Function4<Mite, ParsingState, Mite, Boolean, List<ParsingState>> showPrev = { mite, state, via, up -> null }
  Function2<Mite, ParsingState, Boolean> wrongRoute = { mite, update -> false }
  private Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> enrichAction = { mite, contribution, state ->
    return mite.unifyWherePossible(contribution)
  }
  Predicate1<Mite> isSatisfied = { mite ->
    def cxt = mite.cxt
    return !(cxt.beingMissedAttr && !mite.contents[cxt.beingMissedAttr] ||
             cxt.headAttr && (!mite.contents[cxt.headAttr] || ((Variable) mite.contents[cxt.headAttr]).light))
  }

  protected Construction(String name, List<String> requiredAttrs) {
    this.action = action
    this.name = name
    this.requiredAttrs = []
    for (attr in requiredAttrs) {
      if (attr.startsWith('+')) {
        attr = attr.substring(1)
        headAttr = attr
      }
      if (attr.startsWith('*')) {
        attr = attr.substring(1)
        beingMissedAttr = attr
      }
      this.requiredAttrs << attr
    }
  }

  ParsingState applySemantics(Mite mite, ParsingState state) { action(state, mite.contents) }

  Collection<Mite> enrichUpdate(Mite self, List<Mite> update, ParsingState state) { enrichAction(self, update, state) }

  List<ParsingState> showPreviousHierarchy(Mite self, ParsingState state, boolean up) { showPrev(self, state, null, up) }

  Construction withAction(Function2<ParsingState, Map, ParsingState> action) {
    this.action = action
    return this
  }
  Construction enrichingMites(Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> action) {
    enrichAction = action
    return this
  }

  Construction structural(Function4<Mite, ParsingState, Mite, Boolean, List<ParsingState>> action, Function2<Mite, Mite, Boolean> filterUpdate = { mite, update -> true }) {
    showPrev = action
    return this
  }

  Construction routeWrong(Function2<Mite, ParsingState, Boolean> condition) {
    wrongRoute = condition
    return this
  }

  Construction satisfiedWhen(Predicate1<Mite> condition) {
    isSatisfied = condition
    return this
  }

  Mite call(Map miteContents) {
    return new Mite(miteContents, this)
  }

  @Override
  String toString() {
    return name
  }

  boolean isExecutable(Mite mite) {
    if (!requiredAttrs) return true

    for (attr in requiredAttrs) {
      if (!mite.contents[attr]) {
        return false
      }
    }
    return true
  }

  static Construction cxt(String name, List<String> requiredAttrs = [], Function2<ParsingState, Map, ParsingState> cl) {
    new Construction(name, requiredAttrs).withAction(cl)
  }
  static Construction cxt(String name, List<String> requiredAttrs = [], Closure cl) {
    new Construction(name, requiredAttrs).withAction(cl as Function2)
  }

}
