package cons3

/**
 * @author peter
 */
class Construction {
  final Function2<ParsingState, Map, ParsingState> action
  final String name
  final List<String> requiredAttrs
  String headAttr
  String beingMissedAttr
  Function4<Mite, ParsingState, Mite, Boolean, ParsingState> showPrev = { mite, state, via, up -> null }
  Function2<Mite, Mite, Boolean> filterUpdate = { mite, update -> true }
  Function2<Mite, ParsingState, Boolean> wrongRoute = { mite, update -> false }
  Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> enrichAction = { mite, contribution, state ->
    return mite.unifyWherePossible(contribution)
  }
  Predicate1<Mite> isSatisfied = { mite ->
    def cxt = mite.cxt
    return !(cxt.beingMissedAttr && !mite.contents[cxt.beingMissedAttr] ||
             cxt.headAttr && (!mite.contents[cxt.headAttr] || ((Variable) mite.contents[cxt.headAttr]).light))

  }

  private Construction(String name, Function2<ParsingState, Map, ParsingState> action, List<String> requiredAttrs) {
    this.action = action
    this.name = name
    this.requiredAttrs = []
    for (attr in requiredAttrs) {
      if (attr.startsWith('+')) {
        attr = attr.substring(1)
        headAttr = attr
      }
      if (attr.startsWith('*')) {
        attr = attr.substring(1)
        beingMissedAttr = attr
      }
      this.requiredAttrs << attr
    }
  }

  Construction enrichingMites(Function3<Mite, List<Mite>, ParsingState, Collection<Mite>> action) {
    enrichAction = action
    return this
  }

  Construction structural(Function4<Mite, ParsingState, Mite, Boolean, ParsingState> action, Function2<Mite, Mite, Boolean> filterUpdate = { mite, update -> true }) {
    showPrev = action
    this.filterUpdate = filterUpdate
    return this
  }

  Construction routeWrong(Function2<Mite, ParsingState, Boolean> condition) {
    wrongRoute = condition
    return this
  }

  Construction satisfiedWhen(Predicate1<Mite> condition) {
    isSatisfied = condition
    return this
  }

  Mite call(Map miteContents) {
    return new Mite(miteContents, this)
  }

  @Override
  String toString() {
    return name
  }

  boolean isExecutable(Mite mite) {
    if (!requiredAttrs) return true

    for (attr in requiredAttrs) {
      if (!mite.contents[attr]) {
        return false
      }
    }
    return true
  }

  static Construction cxt(String name, List<String> requiredAttrs = [], Function2<ParsingState, Map, ParsingState> cl) {
    new Construction(name, cl, requiredAttrs)
  }
  static Construction cxt(String name, List<String> requiredAttrs = [], Closure cl) {
    new Construction(name, cl as Function2, requiredAttrs)
  }

}
