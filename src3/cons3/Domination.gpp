package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Domination {
  private static final Set<String> nonHumanVerbs = ['COME_SCALARLY', 'fact', 'question']
  ParsingState self
  ParsingState other

  private Pair<Frame, Frame> findPair(Predicate2<Frame, Frame> condition) {
    for (frame in self.chart.frames) {
      Frame alternative = frame.unifiedVar.frame(other.chart)
      if (condition(frame, alternative)) {
        return new Pair(frame, alternative)
      }
    }
    return null
  }

  boolean dominatesSemantically() {
    if (checkIncompleteSequences() || checkIncompleteQuantifier()) {
      return false
    }

    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && verb.f('anchor')?.definitelyNonHuman() && verb.f('arg1')?.definitelyNonHuman() && alternative.type == 'GO'
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && alternative.type == 'GO' && verb.f('anchor')?.type && !verb.f('anchor').canBeHuman()
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'FORGET' && verb.f('arg2') && !alternative.f('arg2')
    }) {
      return true
    }
    if (findPair { noun, alternative ->
      String attr = noun.type == 'WORDS' ? 'author' : noun.type == 'OPINION' ? 'arg1' : null
      return attr &&
             noun.f(attr)?.flatten()?.every { it.type } &&
             !alternative.f(attr  )?.flatten()?.every { it.type }
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.allAssignments('opinion_of').size() == 1 && alternative.allAssignments('opinion_of').size() > 1
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      if (verb.type == 'question' && alternative.type == 'fact') {
        def controller = alternative.findClauseController()
        if (!controller || controller.type == 'ASK') {
          return true
        }
      }
    }) {
      return true
    }

    for (verb in self.chart.frames.findAll { it.humanAction || it.type in nonHumanVerbs }) {
      def alternative = verb.unifiedVar.frame(other.chart)

      if (verb.humanAction ||
          verb.type == 'COME_SCALARLY' && verb.f('anchor')?.canBeHuman() && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        boolean meHuman = !verb.f('arg1')?.definitelyNonHuman()
        def otherHuman = !alternative.f('arg1')?.definitelyNonHuman()
        if (meHuman != otherHuman &&
            verb.f('arg1')?.type && alternative.f('arg1')?.type &&
            self.network.chosenUnsatisfied.size() <= other.network.chosenUnsatisfied.size()) {
          return meHuman
        }
      }

      if (verb.type && alternative.type &&
          ((Frame) verb?.definedAttributeValue('arg1'))?.definedAttributeValue('type') &&
          !((Frame) alternative?.definedAttributeValue('arg1'))?.definedAttributeValue('type')) {
        return true
      }

    }

    return false
  }

  private boolean checkIncompleteQuantifier() {
    return findPair { frame, alternative -> !frame.type && alternative.type && frame.f('quantifier')?.type } != null
  }

  private boolean checkIncompleteSequences() {
    return findPair { frame, alternative ->
      frame.f('member') && alternative.flatten().every { it.type != null } && !frame.flatten().every { it.type != null }
    } != null
  }
}
