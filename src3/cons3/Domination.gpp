package cons3

import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString
import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Domination {
  private static final Set<String> nonHumanVerbs = ['COME_SCALARLY', 'fact', 'question']
  ParsingState self
  ParsingState other

  private Pair<Frame, Frame> findPair(Predicate2<Frame, Frame> condition) {
    for (frame in self.chart.frames) {
      Frame alternative = frame.unifiedVar.frame(other.chart)
      if (condition(frame, alternative)) {
        return new Pair(frame, alternative)
      }
    }
    return null
  }

  private static List<Problem> getProblems(ParsingState state) {
    def result = []
    for (frame in state.chart.frames) {
      if (frame.allAssignments('opinion_of').size() > 1) {
        result << problem(frame, 'several accordingTo assignments')
      }
    }

    result
  }

  private static Problem problem(Frame frame, String description) {
    return new Problem(frame, description)
  }

  boolean dominatesSemantically() {
    if (checkIncompleteSequences()) {
      return false
    }

    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && verb.f('anchor')?.definitelyNonHuman() && verb.f('arg1')?.definitelyNonHuman() && alternative.type == 'GO'
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && alternative.type == 'GO' && verb.f('anchor')?.type && !verb.f('anchor').canBeHuman()
    }) {
      return true
    }

    if (getProblems(self).size() < getProblems(other).size()) {
      return true
    }

    for (verb in self.chart.frames.findAll { it.humanAction || it.type in nonHumanVerbs }) {
      def alternative = verb.unifiedVar.frame(other.chart)

      if (verb.humanAction ||
          verb.type == 'COME_SCALARLY' && verb.f('anchor')?.canBeHuman() && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        boolean meHuman = !verb.f('arg1')?.definitelyNonHuman()
        def otherHuman = !alternative.f('arg1')?.definitelyNonHuman()
        if (meHuman != otherHuman &&
            verb.f('arg1')?.type && alternative.f('arg1')?.type &&
            self.network.chosenUnsatisfied.size() <= other.network.chosenUnsatisfied.size()) {
          return meHuman
        }
      }

      if (verb.type && alternative.type &&
          ((Frame) verb?.definedAttributeValue('arg1'))?.definedAttributeValue('type') &&
          !((Frame) alternative?.definedAttributeValue('arg1'))?.definedAttributeValue('type')) {
        return true
      }

    }

    return false
  }

  private boolean checkIncompleteSequences() {
    return findPair { frame, alternative ->
      frame.f('member') && alternative.flatten().every { it.type != null } && !frame.flatten().every { it.type != null }
    } != null
  }
}

@TupleConstructor
@EqualsAndHashCode
@ToString
class Problem {
  Frame frame
  String description
}
