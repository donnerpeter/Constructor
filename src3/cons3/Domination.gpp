package cons3

import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString
import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Domination {
  private static final Set<String> nonHumanVerbs = ['COME_SCALARLY', 'fact', 'question']
  ParsingState self
  ParsingState other

  private Pair<Frame, Frame> findPair(Predicate2<Frame, Frame> condition) {
    for (frame in self.chart.frames) {
      Frame alternative = frame.unifiedVar.frame(other.chart)
      if (condition(frame, alternative)) {
        return new Pair(frame, alternative)
      }
    }
    return null
  }

  private static List<Problem> getProblems(ParsingState state) {
    def result = []
    for (frame in state.chart.frames) {
      if (frame.allAssignments('opinion_of').size() > 1) {
        result << problem(frame, 'several accordingTo assignments')
      }
      if (frame.type == 'CASHIER' && frame.f('arg1')?.s('number') == 'true') {
        result << problem(frame, 'cashier of a number')
      }
      if (frame.f('member') && frame.flatten().any { it.s('number') == 'true' } && frame.flatten().any { !it.s('number') }) {
        result << problem(frame, 'number and non-number conjunction')
      }
      if (frame.type == 'COME_SCALARLY' && frame.f('arg1')?.canBeHuman() && frame.f('anchor')?.definitelyNonHuman()) {
        result << problem(frame, 'human comes after non-human')
      }
    }

    result
  }

  private static Problem problem(Frame frame, String description) {
    return new Problem(frame, description)
  }

  boolean dominatesSemantically() {
    if (checkIncompleteSequences()) {
      return false
    }

    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && verb.f('anchor')?.definitelyNonHuman() && verb.f('arg1')?.definitelyNonHuman() && alternative.type == 'GO'
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()
    }) {
      return true
    }
    if (findPair { verb, alternative ->
      verb.type == 'COME_SCALARLY' && alternative.type == 'GO' && verb.f('anchor')?.type && !verb.f('anchor').canBeHuman()
    }) {
      return true
    }

    if (getProblems(self).size() < getProblems(other).size()) {
      return true
    }

    for (verb in self.chart.frames.findAll { it.humanAction }) {
      def alternative = verb.unifiedVar.frame(other.chart)

      boolean meHuman = !verb.f('arg1')?.definitelyNonHuman()
      def otherHuman = !alternative.f('arg1')?.definitelyNonHuman()
      if (meHuman != otherHuman && verb.f('arg1')?.type && alternative.f('arg1')?.type) {
        return meHuman
      }

    }

    return false
  }

  private boolean checkIncompleteSequences() {
    return findPair { frame, alternative ->
      frame.f('member') && alternative.flatten().every { it.type != null } && !frame.flatten().every { it.type != null }
    } != null
  }
}

@TupleConstructor
@EqualsAndHashCode
@ToString
class Problem {
  Frame frame
  String description
}
