package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class EllipsisInterceptor extends Interceptor implements RussianConstructions {
  final ParsingState beforeDash

  ParsingState intercept(List<Mite> constructions, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    Mite self = state.visibleMites[clauseEllipsis].find { state.network.isChosen(it) && it.contents.interceptor == (Interceptor) this }
    final ParsingState prevHistory = self.contents.prevHistory
    if (!prevHistory || state[clauseEllipsis].finished || state.visibleMites[questionVariants]?.find { it.contents.questioned }) {
      return base(constructions, state)
    }

    Update update = new Update(constructions)

    List<ParsingState> old = prevHistory.history
    def endPrecedent = old.findIndexOf { ParsingState it -> Similarity.areSimilar(it.contribution, update.mites) }
    if (endPrecedent >= 0) {
      List<ParsingState> beforeGap = beforeDash.history[0..<beforeDash.history.size() - old.size()]
      def lcs = Util.lcs(old.subList(endPrecedent + 1, old.size()), beforeGap) { a, b -> Similarity.areSimilar(a.contribution, b.contribution) }
      if (lcs) {
        def startPrecedent = old.indexOf(lcs[0])
        FList<ParsingState> precedent = FList.fromList(old[0..startPrecedent-1])

        Map<Variable, Variable> mapping = buildMapping(lcs, precedent, update)
        Map<Object, Object> xorMapping = [:]

        def ellipsis = new Variable()
        state = state.
                assign(ellipsis, 'type', 'ellipsis').startMeta(ellipsis)

        for (i in 0..<precedent.size()) {
          if (i == precedent.size() - endPrecedent - 1) continue

          ParsingState oldContribution = precedent[i]
          List<Mite> mapped = applyMapping(oldContribution, mapping, xorMapping) + [clauseEllipsis(guard:true)]
          state = base(mapped, state)
          def cs = mapped.find { it.cxt == comeScalarly && it.contents.verb }
          if (cs && prevHistory[comeScalarly]?.verb) {
            def seq = new Variable()
            state = state.assign(seq, 'member', prevHistory[comeScalarly].verb).assign(seq, 'member', cs.contents.verb)
            if (prevHistory[elaboration]?.head) {
              state = state.assign(prevHistory[elaboration].head, 'elaboration', seq)
            }
          }
        }

        state = state.finishMeta(ellipsis).apply((clauseEllipsis):[finished:true])
      }
    }

    return base(constructions, state)
  }

  static List<Mite> applyMapping(ParsingState oldContribution, Map<Variable, Variable> mapping, Map<Object, Object> xorMapping) {
    List<Mite> newContribution = []
    for (mite in oldContribution.contribution) {
      def newArgs = [:]
      mite.contents.each { k, v ->
        newArgs[k] = v instanceof Variable ? mapping[(Variable) v] : v
      }
      if (mite.contents.xor) {
        newArgs.xor = ((Set) mite.contents.xor).collect { xorMapping.get(it, new TokenWrapper(it)) } as LinkedHashSet
      }
      newContribution = newContribution + mite.cxt(newArgs)
    }
    return newContribution
  }

  static Map<Variable, Variable> buildMapping(List<ParsingState> lcs, List<ParsingState> template, Update update) {
    Map<Variable, Variable> mapping = [:]
    lcs.each { contribution ->
      contribution.contribution.each { mite ->
        mite.contents.each { val ->
          if (val instanceof Variable && !mapping[val]) {
            def newVar = new Variable()
            mapping[val.base] = newVar
            mapping[val.base.lightVar] = newVar.lightVar
          }
        }
      }
    }
    template.each { ParsingState oldContribution ->
      oldContribution.contribution.each { mite ->
        mite.contents.each { k, v ->
          if (v instanceof Variable && !mapping[v]) {
            List<Mite> candidateMites = update.mites.findAll { it.isSimilarTo(mite) }
            List values = candidateMites.collect { it.contents[k] }
            Variable newVar = values[0] ?: mapping[v] ?: new Variable()
            mapping[v.base] = newVar.base
            mapping[v.base.lightVar] = newVar.base.lightVar
          }
        }
      }
    }
    return mapping
  }

}