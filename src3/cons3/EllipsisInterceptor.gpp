package cons3

/**
 * @author peter
 */
class EllipsisInterceptor implements Interceptor, RussianConstructions {
  final ParsingState prevHistory
  final ParsingState beforeDash

  EllipsisInterceptor(ParsingState prevHistory, ParsingState beforeDash) {
    this.prevHistory = prevHistory
    this.beforeDash = beforeDash
  }

  ParsingState intercept(Map<Construction, Map> constructions, ParsingState state, Function2<Map<Construction, Map>, ParsingState, ParsingState> base) {
    Update update = new Update(constructions)

    FList<Contribution> old = prevHistory.history
    def endPrecedent = old.findIndexOf { Contribution it -> Parser.areSimilar(it.apps, update.map) }
    if (endPrecedent >= 0) {
      List<Contribution> beforeGap = beforeDash.history[0..beforeDash.history.size - old.size]
      def lcs = Util.lcs(old.subList(endPrecedent + 1), beforeGap) { a, b -> Parser.areSimilar(a.apps, b.apps) }
      if (lcs) {
        def startPrecedent = old.indexOf(lcs[0])
        FList<Contribution> precedent = FList.fromList(old[0..startPrecedent-1])

        Map<Variable, Variable> mapping = buildMapping(lcs, precedent, update)

        def ellipsis = new Variable()
        state = state.satisfied(clauseEllipsis).inhibit(comeScalarly).assign(ellipsis, 'type', 'ellipsis').startMeta(ellipsis)

        for (i in 0..<precedent.size()) {
          if (i == precedent.size() - endPrecedent - 1) continue

          Contribution oldContribution = precedent[i]
          //todo a normal condition for ellipsis participation
          if (!oldContribution.apps.keySet().intersect(Parser.importantForSimilarity - [parenthetical])) continue

          def mapped = applyMapping(oldContribution, mapping)
          state = base(mapped, state)
          //todo a generic conjunctless 'but'
          if (mapped[comeScalarly]?.verb && prevHistory[comeScalarly]?.verb) {
            def seq = new Variable()
            state = state.assign(seq, 'member', prevHistory[comeScalarly].verb).assign(seq, 'conj', 'but').assign(seq, 'member', mapped[comeScalarly].verb)
          }
        }

        state = state.finishMeta(ellipsis)
      }
    }

    return base(constructions, state)
  }

  FLinkedMap<Construction, Map> applyMapping(Contribution oldContribution, Map<Variable, Variable> mapping) {
    FLinkedMap<Construction, Map> newContribution = FLinkedMap.emptyMap
    for (cxt in oldContribution.apps.keySet()) {
      def newArgs = [:]
      oldContribution.apps[cxt].each { k, v ->
        newArgs[k] = v instanceof Variable ? mapping[(Variable) v] : v
      }
      newContribution = newContribution.putValue(cxt, newArgs)
    }
    return newContribution.reverse()
  }

  Map<Variable, Variable> buildMapping(List<Contribution> lcs, FList<Contribution> template, Update update) {
    Map<Variable, Variable> mapping = [:]
    lcs.each { contribution ->
      contribution.apps.values().each { val ->
        if (val instanceof Variable && !mapping[(Variable) val]) { //todo alex cast
          mapping[(Variable) val] = new Variable()
        }
      }
    }
    template.each { Contribution oldContribution ->
      oldContribution.apps.each { cxt, upd ->
        upd.each { k, v ->
          if (v instanceof Variable) {
            mapping[v] = update.map[cxt]?.get(k) ?: mapping[v] ?: new Variable()
          }
        }
      }
    }
    return mapping
  }

  Map<String, Object> getArgs(Construction construction, ParsingState state) {
    null
  }

}