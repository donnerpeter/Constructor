package cons3

/**
 * @author peter
 */
class EllipsisInterceptor implements Interceptor, RussianConstructions {
  final ParsingState prevHistory
  final ParsingState beforeDash

  EllipsisInterceptor(ParsingState prevHistory, ParsingState beforeDash) {
    this.prevHistory = prevHistory
    this.beforeDash = beforeDash
  }

  ParsingState intercept(List<Mite> constructions, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    Update update = new Update(constructions)

    FList<Contribution> old = prevHistory.history
    def endPrecedent = old.findIndexOf { Contribution it -> Parser.areSimilar(it.apps, update.mites) }
    if (endPrecedent >= 0) {
      List<Contribution> beforeGap = beforeDash.history[0..beforeDash.history.size - old.size]
      def lcs = Util.lcs(old.subList(endPrecedent + 1), beforeGap) { a, b -> Parser.areSimilar(a.apps, b.apps) }
      if (lcs) {
        def startPrecedent = old.indexOf(lcs[0])
        FList<Contribution> precedent = FList.fromList(old[0..startPrecedent-1])

        Map<Variable, Variable> mapping = buildMapping(lcs, precedent, update)

        def ellipsis = new Variable()
        state = state.satisfied(clauseEllipsis).
                inhibit(comeScalarly, nom, advObj, elaboration). //todo inhibit/satisfy should also be replicated
                assign(ellipsis, 'type', 'ellipsis').startMeta(ellipsis)

        for (i in 0..<precedent.size()) {
          if (i == precedent.size() - endPrecedent - 1) continue

          Contribution oldContribution = precedent[i]
          def mapped = applyMapping(oldContribution, mapping)
          state = base(mapped, state)
          //todo a generic conjunctless 'but'
          def cs = mapped.find { it.cxt == comeScalarly && it.contents.verb }
          if (cs && prevHistory[comeScalarly]?.verb) {
            def seq = new Variable()
            state = state.assign(seq, 'member', prevHistory[comeScalarly].verb).assign(seq, 'conj', 'but').assign(seq, 'member', cs.contents.verb)
            if (prevHistory[elaboration]?.head) {
              state = state.assign(prevHistory[elaboration].head, 'elaboration', seq)
            }
          }
        }

        state = state.finishMeta(ellipsis)
      }
    }

    return base(constructions, state)
  }

  List<Mite> applyMapping(Contribution oldContribution, Map<Variable, Variable> mapping) {
    List<Mite> newContribution = []
    for (mite in oldContribution.apps) {
      def newArgs = [:]
      mite.contents.each { k, v ->
        newArgs[k] = v instanceof Variable ? mapping[(Variable) v] : v
      }
      newContribution = newContribution + mite.cxt(newArgs)
    }
    return newContribution
  }

  Map<Variable, Variable> buildMapping(List<Contribution> lcs, FList<Contribution> template, Update update) {
    Map<Variable, Variable> mapping = [:]
    lcs.each { contribution ->
      contribution.apps.each { mite ->
        mite.contents.each { val ->
          if (val instanceof Variable && !mapping[(Variable) val]) { //todo alex cast
            mapping[(Variable) val] = new Variable()
          }
        }
      }
    }
    template.each { Contribution oldContribution ->
      oldContribution.apps.each { mite ->
        mite.contents.each { k, v ->
          if (v instanceof Variable) {
            List<Mite> candidateMites = update.mites.findAll { it.cxt == mite.cxt }
            List values = candidateMites.collect { it.contents[k] }
            mapping[v] = values[0] ?: mapping[v] ?: new Variable()
          }
        }
      }
    }
    return mapping
  }

  Map<String, Object> getArgs(Construction construction, ParsingState state) {
    null
  }

}