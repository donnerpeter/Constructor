package cons3

/**
 * @author peter
 */
class EllipsisInterceptor extends Interceptor implements RussianConstructions {
  final ParsingState prevHistory
  final ParsingState beforeDash

  EllipsisInterceptor(ParsingState prevHistory, ParsingState beforeDash) {
    this.prevHistory = prevHistory
    this.beforeDash = beforeDash
  }

  ParsingState intercept(List<Mite> constructions, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    Update update = new Update(constructions)

    FList<Contribution> old = prevHistory.history
    def endPrecedent = old.findIndexOf { Contribution it -> Similarity.areSimilar(it, update.mites) }
    if (endPrecedent >= 0) {
      List<Contribution> beforeGap = beforeDash.history[0..beforeDash.history.size - old.size]
      def lcs = Util.lcs(old.subList(endPrecedent + 1), beforeGap) { a, b -> Similarity.areSimilar(a, b.apps) }
      if (lcs) {
        def startPrecedent = old.indexOf(lcs[0])
        FList<Contribution> precedent = FList.fromList(old[0..startPrecedent-1])

        Map<Variable, Variable> mapping = buildMapping(lcs, precedent, update)

        def ellipsis = new Variable()
        state = state.
                assign(ellipsis, 'type', 'ellipsis').startMeta(ellipsis)

        for (i in 0..<precedent.size()) {
          if (i == precedent.size() - endPrecedent - 1) continue

          Contribution oldContribution = precedent[i]
          def mapped = applyMapping(oldContribution, mapping)
          state = base(mapped, state)
          //todo a generic conjunctless 'but'
          def cs = mapped.find { it.cxt == comeScalarly && it.contents.verb }
          if (cs && prevHistory[comeScalarly]?.verb) {
            def seq = new Variable()
            state = state.assign(seq, 'member', prevHistory[comeScalarly].verb).assign(seq, 'conj', 'but').assign(seq, 'member', cs.contents.verb)
            if (prevHistory[elaboration]?.head) {
              state = state.assign(prevHistory[elaboration].head, 'elaboration', seq)
            }
          }
        }

        state = state.finishMeta(ellipsis)
      }
    }

    return base(constructions, state)
  }

  List<Mite> applyMapping(Contribution oldContribution, Map<Variable, Variable> mapping) {
    List<Mite> newContribution = []
    for (mite in oldContribution.apps) {
      def newArgs = [:]
      mite.contents.each { k, v ->
        newArgs[k] = v instanceof Variable ? mapping[(Variable) v] : v
      }
      newContribution = newContribution + mite.cxt(newArgs)
    }
    return newContribution
  }

  Map<Variable, Variable> buildMapping(List<Contribution> lcs, FList<Contribution> template, Update update) {
    Map<Variable, Variable> mapping = [:]
    lcs.each { contribution ->
      contribution.apps.each { mite ->
        mite.contents.each { val ->
          if (val instanceof Variable && !mapping[val]) {
            def newVar = new Variable()
            mapping[val.base] = newVar
            mapping[val.base.lightVar] = newVar.lightVar
          }
        }
      }
    }
    template.each { Contribution oldContribution ->
      oldContribution.apps.each { mite ->
        mite.contents.each { k, v ->
          if (v instanceof Variable && !mapping[v]) {
            List<Mite> candidateMites = update.mites.findAll { it.isSimilarTo(mite) }
            List values = candidateMites.collect { it.contents[k] }
            Variable newVar = values[0] ?: mapping[v] ?: new Variable()
            mapping[v.base] = newVar.base
            mapping[v.base.lightVar] = newVar.base.lightVar
          }
        }
      }
    }
    return mapping
  }

}