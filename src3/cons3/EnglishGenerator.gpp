package cons3

/**
 * @author peter
 */
class EnglishGenerator {
  List<String> output = []
  Set<Situation> handled = []
  boolean past

  String generate(Chart chart) {
    chart.situations.each {
      if (!(it in handled) && chart.__assignments[it]) {
        new SituationGenerator(chart, it, true).sentence(true)
      }
    }

    String result = ""
    for (w in output) {
      if (!result.empty && !(w in ['.', ',', ';', ':', '\n-', "'s", '?'])) {
        result += " "
      }
      result += w
    }
    if (result.endsWith(',')) {
      result = result[0..-2]
    }

    return result
  }

  private class SituationGenerator {
    final Chart chart
    final Situation situation
    boolean capitalize

    SituationGenerator(Chart chart, Situation situation, boolean capitalize) {
      this.chart = chart
      this.situation = situation
      this.capitalize = capitalize
    }
    
    private void out(String word) {
      if (word == ',') {
        if (output.empty || output[-1] == ',') return
      }

      output << (capitalize ? word.capitalize() : word)
      capitalize = false
    }

    private class ClauseGenerator {
      Frame frame
      Frame bg
      boolean topLevel
      Frame comp
      Frame copula

      ClauseGenerator(Frame frame, Frame bg, boolean topLevel, Frame comp) {
        this.frame = frame
        this.bg = bg
        this.topLevel = topLevel
        this.comp = comp

        copula = chart.frames(situation).find { it.type in ['location', 'degree'] }

      }

      def generate(boolean last) {
        if (frame && frame.usages('topic').find { it.type == 'LUCK' }) {
          out 'by some sheer luck,'
        }

        if (frame?.s('emphasis')) {
          out 'there'
        } else if (frame?.s('relTime') == 'AFTER') { //todo a generic situation time frame
          out 'then'
        } else if (frame?.s('relTime') == 'BEFORE') {
          out 'before'
          out ','
        } else if (frame?.f('relTime_after')) {
          out 'after'
          np(frame?.f('relTime_after'), false)
          out ','
        }

        if (bg) {
          if (bg.type == 'MOVE') {
            out 'moving'
            np(bg.f('arg2'), false)
            emitMoveTail(bg)
          } else if (bg.type == 'THINK') {
            out ','
            out 'thinking'
            out 'carefully'
            out 'about'
            np(bg.f('theme'), false)
          } else if (bg.type == 'COME_TO') {
            out 'reaching'
            np(bg.f('goal'), false)
            if (bg.f('domain')?.type == 'COUNTING') {
              out 'in'
              out 'count'
            }
          }
          out ','
        }

        if (frame) {
          Frame subj = clauseInner(frame, true, bg != null, topLevel)
          if (last) {
            generateCondition(frame)
            generateElaboration(frame)
            generateReason(frame)
            generateQuestionVariants(subj)
            generateDirectSpeech(frame)
          }
        }

        if (comp) {
          out 'to'
          out 'consult'
          np(comp.f('arg2'), false)
          out 'on'
          np(comp.f('topic'), false)
        }

        if (!frame && !bg) {
          if (copula?.type == 'location') {
            def subj = copula.f('arg1')
            if (subj.s('relativized') == 'true') {
              out(copula.s('time') == 'PAST' ? 'that was' : "that's")
            } else {
              np(subj, true)
              out 'was'
            }
            out 'on'
            np(copula.f('arg2'), false)
          } else if (copula?.type == 'degree') {
            out 'great'
            out 'was'
            np(copula.f('arg1'), true)
            generateCondition(copula)
          }
        }

      }

    }

    private def sentence(boolean topLevel) {
      handled << situation

      List<ClauseGenerator> conjuncts = planConjuncts(topLevel)

      if (conjuncts[0]?.frame?.s('butEmphasis')) {
        out 'but'
      }
      else if (conjuncts[0]?.frame?.s('andEmphasis')) {
        out 'and'
      }

      generateConjuncts(conjuncts) { conj, last -> conj.generate(last) }

      if (conjuncts) {
        def last = conjuncts[-1].frame ?: conjuncts[-1].copula
        while (true) {
          if (last?.type in ['CAN', 'FORGET', 'DISCOVER'] && last.f('theme')) {
            last = last.f('theme')
          }
          else if (last?.type in ['ASK']) {
            last = last.f('question')
          }
          else if (last?.type == 'modality') {
            last = last.f('arg1')
          }
          else if (last?.f('member')) {
            last = last.f('member')
          }
          else break
        }
        if (last?.s('dot') == 'true') {
          out '.'
          return
        }
      }
      if ((conjuncts[0]?.frame?.type == 'modality' || findQuestioned(conjuncts[0]?.frame) && !isExclamation()) && topLevel) {
        out '?'
      }
    }

    private boolean generateConjuncts(List<ClauseGenerator> conjuncts, Function2<ClauseGenerator,Boolean,Void> generator) {
      boolean wasBut = false

      for (int j in 0..<conjuncts.size()) {
        def last = j == conjuncts.size() - 1
        if (j > 0) {
          def prev = conjuncts[j - 1]
          def cur = conjuncts[j]
          List<Frame> seqs = prev.frame?.usages('member') ?: [] //todo infer
          def but = seqs.any { conj -> conj.s('conj') == 'but' && conj.allAssignments('member')[-1].value == cur.frame }
          wasBut |= but
          if (last && (!cur.bg || cur.frame) || but) {
            if (but) {
              out(prev.frame?.f('opinion_of') ? ';' : ',')
            }
            else if (!wasBut && j > 1 || cur.bg) out ","

            out(but ? (prev.frame?.s('irrealis') == 'true' ? 'when' : 'but') : "and")
          } else {
            out ","
          }
        }
        generator(conjuncts[j], last)
      }
      return wasBut
    }

    Frame isExclamation() {
      return chart.frames(situation).find { it.type == 'degree' }
    }

    private List<ClauseGenerator> planConjuncts(boolean topLevel) {
      List<Frame> allVerbs = chart.frames(situation).findAll {
        it.type in ['HAPPEN', 'FORGET', 'COME_SCALARLY',
                'GO_OFF', 'ASK',
                'DISCOVER', 'REMEMBER',
                'GO', 'SMILE', 'TAKE_OUT', 'SAY', 'MOVE',
                'THANK', 'RUN_OUT',
                'GET_SAD', 'SEEM', 'THINK',
                'modality', 'DO', 'NEED',
                'BEGIN', 'STOP', 'COME_TO',
                'ARGUE', 'FALL', 'BREAK',
                'DISTRACT', 'DISPERSE'
        ]
      }

      if (allVerbs.size() > 1) {
        for (i in 1..<allVerbs.size()) {
          def prev = allVerbs[i-1]
          def cur = allVerbs[i]
          if (chart.earlier(cur, 'type', prev, 'type') || cur.type == 'modality' && prev == cur.f('arg1')) {
            allVerbs[i-1] = cur
            allVerbs[i] = prev
          }
        }
      }

      List<ClauseGenerator> conjuncts = []
      if (!allVerbs) {
        conjuncts << new ClauseGenerator(null, null, topLevel, null)
      } else {
        int i = 0
        int mainVerbs = 0
        while (i < allVerbs.size()) {
          Frame bg = null
          if (allVerbs[i].s('background')) {
            bg = allVerbs[i++]
          }

          def cur = allVerbs[i++]
          def lastCur = cur
          if (cur) {
            mainVerbs++
            if (cur.type == 'BEGIN') {
              mainVerbs++
              lastCur = allVerbs[i++]
            }
          }
          Frame comp = null
          def next = allVerbs[i]
          if (cur?.type == 'GO' && next?.type == 'ASK') {
            comp = next
            i++
          }
          while (next &&
                 (next == lastCur.f('theme') ||
                  next in (lastCur.f('elaboration')?.flatten() ?: []) ||
                  next in (lastCur.f('theme')?.flatten() ?: []) ||
                  next.usages('theme') ||
                  next.usages('arg1')[0]?.type == 'modality' ||
                  next.usages('question'))) {
            next = allVerbs[++i]
          }
          conjuncts << new ClauseGenerator(cur, bg, topLevel, comp)
        }
      }
      return conjuncts
    }

    private def emitMoveTail(Frame verb) {
      if (verb.s('manner') == 'SLIGHTLY') {
        out 'slightly'
      }
      out 'back'
      out 'and'
      out 'forth'
    }

    private String opinionOf(Frame opinion, String prevOpinion, Frame parent) {
      if (opinion.f('member')) {
        groovy.lang.Reference prev = [null]
        seq(opinion) {
          String p = prev.get()
          prev.set(opinionOf(it, p, opinion))
        }
        return true
      }

      if (opinion.type == 'OPINION') {
        if (prevOpinion != 'OPINION' || opinion.f('distinguished_in')) {
          out 'in'
        }
        np(opinion, false)
      }
      else if (opinion.type == 'WORDS') {
        out 'according'
        out 'to'
        if (parent) {
          //todo generic right periphery ellipsis
          List<Frame> members = parent.allAssignments('member').collect { it.value } as List
          def i = members.indexOf(opinion)
          if (i < members.size() - 1 && members[i + 1].type == 'OPINION' && members[i + 1].f('arg1') == opinion.f('author')) {
            return opinion.type
          }
        }
        np(opinion.f('author'), false)
      }
      return opinion.type
    }

    private String aux(Frame verb, Frame subj, boolean imperative) {
      def sitPast = past
      if (imperative && subj) {
        if (subj.type == 'WE') {
          return sitPast ? 'were': 'are'
        }
        return sitPast ? 'was': 'am'
      }
      def questioned = findQuestioned(verb)
      if (questioned && questioned != subj) {
        return sitPast ? 'did' : 'do'
      }

      return null
    }

    Frame findQuestioned(Frame verb) {
      if (!verb) return null
      if (verb.f('arg1')?.type == 'wh') return verb.f('arg1')
      if (verb.f('arg2')?.type == 'wh') return verb.f('arg2')
      return null
    }

    private Frame clauseInner(Frame verb, boolean shouldHaveSubject, boolean forceSubject, boolean topLevel) {
      assert verb
      if (verb.s('time') == 'PAST') {
        past = true //todo maintain a tense for the whole discourse
      }

      def opinion = verb.f('opinion_of')
      if (opinion) {
        opinionOf(opinion, null, null)
        if (!verb.findMeta('type', 'ellipsis')) {
          out ','
        }
      }

      def imperative = verb.type == 'modality'
      if (imperative) {
        verb = verb.f('arg1')
        shouldHaveSubject = verb.f('arg1') != null
      }


      def subj = verb.f('arg1')

      if (findQuestioned(verb)) {
        out 'what'
      }

      if (topLevel && subj) {
        def aux = aux(verb, subj, imperative)
        if (aux) {
          out aux
        }
      }

      generateSubject(shouldHaveSubject, forceSubject, verb, subj)

      if (verb.findMeta('type', 'ellipsis')) {
        out(past ? 'did' : 'does')
        return
      }

      if (verb.s('manner') == 'SUDDENLY') {
        out 'suddenly'
      }
      def type = verb.type
      if (type == 'SMILE') {
        out 'gave'
        out 'us'
        out 'a'
        if (verb.s('manner') == 'SADLY') {
          out 'sad'
        }
        out 'smile'
      }
      else if (type == 'COME_SCALARLY') {
        out(verb.s('time') == 'PAST' ? 'went' : 'comes')
        def anchor = verb.f('anchor')
        if (verb.s('order') == 'EARLIER') {
          if (anchor) {
            out 'before'
            np(anchor, false)
          } else {
            out 'first'
          }
        } else if (verb.s('order') == 'AFTER') {
          if (anchor) {
            out 'after'
            np(anchor, false)
          } else {
            out 'next'
          }
        }
      }
      else if (type == 'SEEM') {
        out 'were'
        def theme = verb.f('theme')
        if (theme?.type == 'LACK') {
          out 'void'
          out 'of'
          np(theme.f('arg2'), false)
        } else if (theme?.type == 'MEANINGLESS') {
          out 'meaningless'
        }
      }
      else {
        if (imperative) {
          if (subj) {
            out 'supposed'
          }
          out 'to'
        }

        out(mainVerb(verb))
      }

      def dobj = verb.f('arg2')
      if (dobj && dobj.type != 'wh') {
        np(dobj, false, !isNumber(dobj))
      }

      def mood = verb.f('mood')
      def cheerfully = mood?.type == 'JOY' && !mood.s('size')
      def simpleMood = cheerfully && chart.earlier(mood, 'type', verb, 'type')
      if (simpleMood) {
        out 'cheerfully'
      }

      if (verb.type == 'MOVE') {
        emitMoveTail(verb)
      }

      if (verb.type == 'DISPERSE' && verb.f('goal')?.type == 'HOMES') {
        out 'home'
      } else {
        def io = verb.type == 'HAPPEN' ? verb.f('experiencer') :
          verb.type in ['GO_OFF', 'GO', 'DISPERSE'] ? verb.f('goal') :
            verb.type in ['ASK', 'THINK'] ? verb.f('topic') :
              verb.type in ['DISTRACT'] ? verb.f('theme') :
                verb.type == 'FALL' ? verb.f('source') : null
        if (io) {
          out(verb.type == 'DISTRACT' ? 'from' : verb.type == 'FALL' ? 'off' : verb.type in ['ASK', 'THINK'] ? 'on' : "to")
          np(io, false)
        }
      }


      if (verb.type in ['TAKE_OUT', 'RUN_OUT']) {
        out 'out'
        out 'of'
        np(verb.f('source'), false)
      }

      if (mood && !simpleMood) {
        if (cheerfully) {
          out 'cheerfully'
        } else {
          out 'with'
          np(mood, false)
        }
      }


      if (verb.type == 'HAPPEN') {
        out "today"
      }
      if (verb.s('anchor') == 'AGAIN') {
        out 'again'
      }

      if (verb.s('duration') == 'LONG') {
        out 'for a long time'
      }

      def question = verb.f('question')
      if (question) {
        if (question.type == 'THINK') {
          out 'about'
          def exp = question.f('arg1')
          if (exp?.type == 'THEY') {
            out 'their'
          }
          out 'opinion'
          out 'on'
          np(question.f('topic'), false)
        } else {
          new ClauseGenerator(question, null, false, null).generate(true)
        }
      }

      def theme = verb.f('theme')
      if (theme && verb.type in ['FORGET', 'DISCOVER']) {
        def that = !findQuestioned(theme)
        if (that) {
          out ","
        }
        List<ClauseGenerator> clauses = theme.flatten().collect { new ClauseGenerator(it, null, false, null) }
        generateConjuncts(clauses)  { conj, last ->
          if (that) {
            out 'that'
          }
          conj.generate(last)
        }
      } else if (theme && verb.type in ['CAN']) {
        clauseInner(theme, false, false, false)
      } else if (theme && verb.type == 'BEGIN') {
        out(theme.type == 'TO_WATER' ? 'watering' : theme.type == 'DANCE' ? 'dancing' : theme.type == 'ARGUE' ? 'arguing' : 'counting')
        def dObj = theme.f('arg2')
        if (dObj) {
          np(dObj, false)
        }
      }
      return subj
    }

    private def generateSubject(boolean shouldHaveSubject, boolean forceSubject, Frame verb, Frame subj) {
      if (skipAlreadyMentionedArgument(verb, 'arg1')) {
        if (forceSubject) {
          out(subj.s('gender') == 'fem' ? 'she' : 'he')
        }
        return
      }

      if (!shouldHaveSubject) {
        return
      }

      if (!subj) {
        println "No subject: $verb"
        return
      }
      if (subj.type != 'wh') {
        np(subj, true)
      }
    }


    private def generateQuestionVariants(Frame subj) {
      def variants = subj?.f('variants')
      if (variants) {
        out '-'
        npseq(variants)
      }
    }

    private def generateDirectSpeech(Frame verb) {
      if (verb.type == 'SAY') {
        out ':'
        def message = (Situation) verb.f('message').var
        if (chart.__assignments[message]) {
          out '\n-'
          new SituationGenerator(chart, message, true).sentence(true)
        }
      }
    }

    private def generateReason(Frame verb) {
      def reason = verb.f('reason')
      if (reason) {
        out 'because'
        new SituationGenerator(chart, (Situation) reason.var, false).sentence(false)
      }
    }

    private def generateCondition(Frame verb) {
      def condition = verb.f('condition')
      if (condition) {
        out ','
        out 'only'
        out 'if'
        def content = condition.f('whenCondition') ?: condition.f('ifCondition')
        if (!content) {
          println "No condition: " + chart.presentable()
          return
        }

        new SituationGenerator(chart, (Situation) content.var, false).sentence(false)
      }

      def condComp = verb.f('ifCondition') ?: verb.f('whenCondition')
      if (condComp) {
        out ','
        out(verb.f('ifCondition') ? 'if' : 'when')
        new SituationGenerator(chart, (Situation) condComp.var, false).sentence(false)
      }
    }

    private def generateElaboration(Frame verb) {
      def elaboration = verb.f('elaboration')
      if (!elaboration && verb.type == 'BEGIN') {
        elaboration = verb.f('theme').f('elaboration')
      }
      
      if (elaboration) {
        def commaStyle = verb.type == 'HAPPEN'
        out(commaStyle ? ',' : ":")
        def sameSentence = commaStyle || verb.type == 'BEGIN'
        List<ClauseGenerator> clauses = elaboration.flatten().collect { new ClauseGenerator(it, null, !sameSentence, null) }
        generateConjuncts(clauses) { conj, last -> conj.generate(last) }
      }
    }

    private String mainVerb(Frame verb) {
      def type = verb.type
      def verbs = [HAPPEN: 'happened', FORGET: 'forgot', GO_OFF: 'went',
              ASK: (verb.f('topic')?.type == 'PREDICAMENT' ? 'consulted' : (past ? 'asked' : 'ask')),
              DISCOVER: 'discovered', CAN: "couldn't", RECALL: 'recall', TAKE_OUT: "took", SAY: 'said',
              REMEMBER: (past ? 'remembered' : verb.f('arg1')?.type in ['HE', 'SHE'] ? 'remembers' : 'remember'), GO: (past ? 'went' : 'goes'),
              RUN_OUT: 'ran', THANK: 'thanked',
              GET_SAD: 'got sad', DO: 'do', NEED:'need',
              BEGIN:'started', STOP:'stopped',
              MOVE:'moved',
              ARGUE:'were arguing', 'FALL':'fell', BREAK:'broke',
              THINK:'think',
              DISTRACT:'distracted',
              DISPERSE:'went'
      ]
      return verbs[type]
    }

    def npseq(Frame _seq) {
      seq(_seq) { np(it, true, !isNumber(it)) }
    }

    def seq(Frame seq, Function1<Frame, Void> action) {
      def members = seq.allAssignments('member')
      members.eachWithIndex { Assignment<Frame> var, int index ->
        if (index == members.size() - 1) out seq.s('conj')
        else if (index > 0) out ','
        action((Frame) var.value)
      }

    }

    private def np(Frame n, boolean nom, boolean mayHaveDeterminer = true) {
      if (!n) {
        out '???'
        return
      }

      if (n.type == 'ME') {
        out (nom ? 'I' : "me")
        return
      }
      if (n.type == 'HE') {
        out (nom ? 'he' : "him")
        return
      }
      if (n.type == 'SHE') {
        out (nom ? 'she' : "her")
        return
      }
      if (n.type == 'WE') {
        out (nom ? 'we' : "us")
        if (n.s('quantifier') == 'ALL') {
          out 'all'
        }
        return
      }
      if (n.type == 'THEY') {
        out (nom ? 'they' : "them")
        if (n.s('quantifier') == 'ALL') {
          out 'all'
        }
        return
      }

      if (n.type == 'wh') {
        out 'what'
        return
      }
      if (n.type == 'THAT') {
        out 'that'
        return
      }

      if (n.type == 'NEXT') {
        out 'what comes next' //todo a non-hacky model for 'what comes next'
        return
      }

      if (n.findMeta('type', 'ellipsis')) {
        out 'it'
        return
      }

      if (!mayHaveDeterminer && isNumber(n)) {
        out n.type
        return
      }

      if (n.f('member')) { //todo a type for seq frames
        npseq(n)
        return
      }

      if (mayHaveDeterminer) {
        determiner(n, n.s('property') == 'AMAZING')
      }
      if (n.s('quality') == 'HUMBLE') {
        out "humble"
      }
      if (n.s('property') == 'AMAZING') {
        out "amazing"
      }
      if (n.s('kind') == 'COMMERCIAL') {
        out "commercial"
      }
      if (n.s('size') == 'LITTLE') {
        out "small"
      }
      if (n.s('size') == 'BIG') {
        out(n.type == 'GARDEN' ? 'big' : "great")
      }
      def criterion = n.f('criterion')
      if (criterion) {
        out noun(criterion)
      }

      if (n.type == 'SHOP') {
        if (n.s('name') == 'гастроном') {
          out 'grocery'
        }
        out('store')
      } else if (n.type == 'GARDEN') {
        out(n.s('name') == 'Летний сад' ? 'Summer Garden' : 'garden')
      }
      else if (isNumber(n)) {
        out n.type
      }
      else {
        out noun(n)
      }

      def location = n.f('location')
      if (location) {
        out 'on'
        np(location, false)
      }

      if (n.type == 'CORNER') {
        def arg1 = n.f('arg1')
        if (arg1) {
          out 'of'
          seq(arg1) { out it.s('name') == 'знаменская' ? 'Znamenskaya' : 'Basseinaya' }
          out 'streets'
        }
      }
      if (n.type == 'OPINION') {
        def arg1 = n.f('arg1')
        if (arg1 && arg1.type != 'ME' && arg1.type != 'THEY') {
          out 'of'
          np(arg1, false)
        }
      }

      def rel = n.f('relative')
      if (rel?.var instanceof Situation) {
        out ','
        out 'the'
        out 'one'
        new SituationGenerator(chart, (Situation) rel.var, false).sentence(false)

      }
    }

    private boolean isNumber(Frame n) {
      return n.s('number') == 'true' && Util.parseNumber(n.type)
    }

    private void determiner(Frame n, boolean an) {
      def det = n.s('determiner')
      if (det == 'THIS') {
        out 'this'
        return
      }
      if (det == 'ANY') {
        out 'any'
        return
      }
      if (det == 'SOME') {
        out 'a'
        return
      }

      boolean hasQuantifier = false
      if (n.f('quantifier')?.type == 'BOTH') {
        out 'both'
        hasQuantifier = true
      }
      else if (n.f('quantifier')?.type) {
        def quantifier = n.f('quantifier')
        out(quantifier.s('number') == 'true' ? quantifier.type : noun(quantifier))
        hasQuantifier = true
      }

      if (n.type in ['AMAZE', 'PREDICAMENT', 'NEIGHBOURS', 'MOUTH', 'NOSE', 'JAW', 'JAWS', 'FINGERS', 'ARGUE'] && n.f('arg1') && !skipAlreadyMentionedArgument(n, 'arg1')) {
        if (hasQuantifier) {
          out 'of'
        }
        possessive(n.f('arg1'), n)
        return
      }
      if (hasQuantifier) {
        return
      }

      if (n.type in ['OPINION'] && n.f('arg1')?.type in ['ME', 'THEY']) {
        possessive(n.f('arg1'), n)
        return
      }
      if (n.type == 'WORDS' && n.f('author')) {
        possessive(n.f('author'), n)
        return
      }
      if (n.type in ['ROOMS', 'APARTMENTS', 'OFFICES'] && n.f('owner')) {
        if (!skipAlreadyMentionedArgument(n, 'owner')) {
          possessive(n.f('owner'), n)
        }
        return
      }


      if (n.type in ['JOY', 'RELIEF', 'MEANING', 'MONEY', 'TREES', 'SOME', 'OTHERS']) { //abstract
        return
      }

      if (n.type == 'OPINION' && n.f('arg1')?.type == 'OTHERS') {
        return //a hack
      }

      if (n.type in ['1', '2', '3', '4', '5', '6', '7']) { out 'a'; return }
      if (n.type == '8') { out 'an'; return }

      if (n.s('given') != 'false') {
        out 'the'
        return
      }

      out(an ? "an" : "a")
    }

    private void possessive(Frame poss, Frame noun) {
      if (poss.f('member')) {
        seq(poss) { possessive(it, noun) }
        return
      }

      if (poss.type == 'ME') out 'my'
      else if (poss.type == 'WE') out 'our'
      else if (poss.type == 'THEY') out 'their'
      else if (poss.type == 'SHE') out 'her'
      else {
        if (poss.usages('arg1')) {
          out(poss.s('gender') == 'fem' ? 'her' : 'his')
          return
        }

        np(poss, false, false)
        out "'s"
      }
    }

    boolean skipAlreadyMentionedArgument(Frame frame, String attr) {
      Frame arg = frame.f(attr)
      def base = (frame.usages('member')[0] ?: frame).flatten()
      def i = base.indexOf(frame)
      if (i > 0) {
        List<Frame> frames = base[0..<i] //todo alex infer
        if (frames.any { it.f(attr) == arg }) {
          return true
        }
      }
      return false
    }

  }

  private String noun(Frame noun) {
    def type = noun.type
    switch (type) {
      case 'THING': return 'thing'
      case 'NEIGHBOURS': return 'neighbors'
      case 'MATTER': return 'matter'
      case 'AMAZE': return 'amazement'
      case 'COUNTING': return 'counting'
      case 'ORDER': return 'order'
      case 'CASHIER': return 'cashier'
      case 'CORNER': return 'corner'
      case 'PREDICAMENT': return 'predicament'
      case 'HAMMER': return 'hammer'
      case 'MOUTH': return 'mouth'
      case 'NOSE': return 'nose'
      case 'JAW': return 'jaw'
      case 'JAWS': return 'jaws'
      case '1': return 'one'
      case '2': return 'two'
      case '3': return 'three'
      case '4': return 'four'
      case '5': return 'five'
      case '6': return 'six'
      case '7': return 'seven'
      case '8': return 'eight'
      case '9': return 'nine'
      case 'JOY': return 'joy'
      case 'RELIEF': return 'relief'
      case 'WORDS': return 'words'
      case 'MEANING': return 'meaning'
      case 'TREES': return 'trees'
      case 'MONEY': return 'money'
      case 'OPINION': return 'opinion'
      case 'SOME': return 'some'
      case 'OTHERS': return 'others'
      case 'WORK': return 'work'
      case 'CHILD': return 'child'
      case 'BENCH': return 'bench'
      case 'FINGERS': return 'fingers'
      case 'FINGER': return 'finger'
      case 'ARGUE': return 'argument'
      case 'ROOMS': return 'rooms'
      case 'APARTMENTS': return 'apartments'
      case 'OFFICES': return 'offices'
      default: return type
    }

  }

}
