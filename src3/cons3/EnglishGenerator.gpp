package cons3

/**
 * @author peter
 */
class EnglishGenerator {
  List<String> output = []
  Set<Situation> handled = []
  boolean past

  String generate(Chart chart) {
    chart.situations.each {
      if (!(it in handled)) {
        new SituationGenerator(chart, it, true).sentence()
      }
    }

    String result = ""
    for (w in output) {
      if (!result.empty && !(w in ['.', ',', ':'])) {
        result += " "
      }
      result += w
    }
    return result
  }

  private class SituationGenerator {
    final Chart chart
    final Situation situation
    final Frame sitFrame
    boolean hasSubject
    boolean capitalize

    SituationGenerator(Chart chart, Situation situation, boolean capitalize) {
      this.chart = chart
      this.situation = situation
      this.capitalize = capitalize
      sitFrame = situation.frame(chart)
    }
    
    private void out(String word) {
      output << (capitalize ? word.capitalize() : word)
      capitalize = false
    }

    private def sentence() {
      handled << situation

      if (sitFrame.s('time') == 'PAST') {
        past = true //todo maintain a tense for the whole discourse
      }


      def excl = sitFrame.f('exclamation')
      if (excl) {
        out 'great'
        out 'was'
        def a = chart.allAssignments(situation).find { it.frame != sitFrame && it.value == excl }
        if (a) {
          np(a.frame, true)
        }
        return
      }

      List<Frame> allVerbs = chart.frames(situation).findAll { it.type in ['HAPPEN', 'FORGET', 'COME_SCALARLY', 'GO_OFF', 'ASK', 'DISCOVER', 'ALSO', 'REMEMBER', 'GO', 'SMILE', 'TAKE_OUT', 'SAY', 'MOVE'] }
      def verb = allVerbs[0]
      if (!verb) {
        def wh = sitFrame.f('wh')
        assert wh: situation.presentable(chart)
        out "that's"
        out 'on'
        def location = wh.f('location')
        np(location, false)
        return
      }

      int i = 0
      while (i < allVerbs.size()) {
        def bg = null
        if (allVerbs[i].s('background')) {
          bg = allVerbs[i++]
        }

        if (i > 0) {
          if (i == allVerbs.size() - 1) {
            if (i > 1) out ","
            out "and"
          } else {
            out ","
          }
        }

        if (bg) {
          out 'moving'
          out 'her'
          out 'nose'
          out 'slightly'
          out 'back'
          out 'and'
          out 'forth'
          out ','
          out 'she'
        }

        def cur = allVerbs[i++]
        clause(cur)
        def next = allVerbs[i]
        if (next) {
          if (cur.type == 'GO' && next.type == 'ASK') {
            out 'to'
            out 'consult'
            np(allVerbs[1].f('arg2'), false)
            out 'on'
            np(allVerbs[1].f('topic'), false)
            i++
          }
        }
      }


      if (sitFrame.f('but')) {
        out ','
        out 'but'
        def generator = new SituationGenerator(chart, (Situation) sitFrame.f('but').var, false)
        generator.hasSubject = true
        generator.sentence()
      }

      if (sitFrame.s('dot') == 'true') {
        out '.'
      }
    }

    private void clause(Frame verb) {
      def subj = verb.f('arg1')
      if (!hasSubject) {
        assert subj : "$verb; " + situation.presentable(chart)
        np(subj, true)
        hasSubject = true
      }

      if (verb.s('manner') == 'SUDDENLY') {
        out 'suddenly'
      }
      def type = verb.type
      if (type == 'SMILE') {
        out 'gave'
        out 'us'
        out 'a'
        if (verb.s('manner') == 'SADLY') {
          out 'sad'
        }
        out 'smile'
      }
      else if (type != 'ALSO') {
        def verbs = [HAPPEN: 'happened', FORGET: 'forgot', COME_SCALARLY: 'comes first', GO_OFF: 'went',
                ASK: 'asked', DISCOVER: 'discovered', CAN: "couldn't", RECALL:'recall', TAKE_OUT:"took", SAY: 'said',
                REMEMBER:(past ? 'remembered' : 'remember'), GO:'went']
        out(verbs[type])
      }

      def dobj = verb.f('arg2')
      if (dobj) {
        np(dobj, false)
      }

      def io = verb.type == 'HAPPEN' ? verb.f('experiencer') : verb.type in ['GO_OFF', 'GO'] ? verb.f('goal') : null
      if (io) {
        out "to"
        np(io, false)
      }

      if (verb.type == 'TAKE_OUT') {
        out 'out'
        out 'of'
        np(verb.f('source'), false)
      }

      if (verb.type == 'HAPPEN') {
        out "today"
      }

      def question = verb.f('question')
      if (question?.var instanceof Situation) {
        def questSituation = (Situation) question.var
        handled << questSituation
        out 'about'
        def think = chart.frames(questSituation).find { it.type == 'THINK' }
        def exp = think.f('arg1')
        if (exp?.type == 'THEY') {
          out 'their'
        }
        out 'opinion'
        out 'on'
        np(think.f('topic'), false)
      }

      def theme = verb.f('theme')
      if (theme?.var instanceof Situation) {
        if (!theme.f('questioned')) {
          out ","
          out "that"
        }

        new SituationGenerator(chart, (Situation)theme.var, false).sentence()
      } else if (theme && verb.type in ['CAN', 'ALSO']) {
        clause(theme)
      }

      def elaboration = sitFrame.f('elaboration')
      if (elaboration?.var instanceof Situation) {
        out ","
        new SituationGenerator(chart, (Situation)elaboration.var, false).sentence()
      }


      def variants = subj?.f('variants')
      if (variants) {
        out '-'
        npseq(variants)
      }

      if (verb.type == 'SAY') {
        out ':'
      }
    }

    def npseq(Frame _seq) {
      seq(_seq) { np(it, true) }
    }

    def seq(Frame seq, Function1<Frame, Void> action) {
      def members = seq.allAssignments('member')
      members.eachWithIndex { Assignment<Frame> var, int index ->
        if (index == members.size() - 1) out seq.s('conj')
        else if (index > 0) out ','
        action((Frame) var.value)
      }

    }

    private def np(Frame n, boolean nom) {
      if (!n) {
        out '???'
        return
      }

      if (n.s('type') == 'ME') {
        out (nom ? 'I' : "me")
        return
      }
      if (n.s('type') == 'WE') {
        out (nom ? 'we' : "us")
        if (n.s('quantifier') == 'ALL') {
          out 'all'
        }
        return
      }
      if (n.s('type') == 'THEY') {
        out (nom ? 'they' : "them")
        return
      }

      if (n == sitFrame.f('questioned')) { //todo a type for seq frames
        out 'what'
        return
      }

      if (n.type == 'NEXT') {
        out 'what comes next' //todo a non-hacky model for 'what comes next'
        return
      }

      if (n.s('number') == 'true') {
        out n.type
        return
      }

      if (n.f('member')) {
        npseq(n)
        return
      }

      determiner(n, n.s('property') == 'AMAZING')
      if (n.s('property') == 'AMAZING') {
        out "amazing"
      }
      if (n.s('kind') == 'COMMERCIAL') {
        out "commercial"
      }
      if (n.s('size') == 'LITTLE') {
        out "small"
      }
      def criterion = n.f('criterion')
      if (criterion) {
        out noun(criterion.type)
      }

      if (n.type == 'SHOP' && n.s('name') == 'Гастроном') {
        out 'grocery'
        out 'store'
      } else {
        out noun(n.type)
      }

      if (n.type == 'AMAZE') {
        def theme = n.f('theme')
        if (theme?.var instanceof Situation) {
          out ','
          out 'when'
          new SituationGenerator(chart, (Situation) theme.var, false).sentence()
        }
      }

      if (n.type == 'CORNER') {
        out 'of'
        seq(n.f('arg1')) { out it.s('name') == 'Знаменская' ? 'Znamenskaya' : 'Basseinaya' }
        out 'streets'
      }

      def rel = n.f('relative')
      if (rel?.var instanceof Situation) {
        out ','
        out 'the'
        out 'one'
        new SituationGenerator(chart, (Situation) rel.var, false).sentence()

      }
    }

    private void determiner(Frame n, boolean an) {
      def det = n.s('determiner')
      if (det == 'THIS') {
        out 'this'
        return
      }

      if (n.type in ['AMAZE', 'PREDICAMENT']) {
        def assignments = n.f('arg1')
        if (assignments) {
          possessive(assignments)
          return
        }
      }

      if (n.type == 'NEIGHBOURS') {
        out 'my' //todo using the actual inferred model information
        return
      }
      if (n.type == 'MOUTH') {
        out 'her'
        return
      }

      if (n.s('given') != 'false') {
        out 'the'
        return
      }

      out(an ? "an" : "a")
    }

    private void possessive(Frame poss) {
      if (poss.f('member')) {
        seq(poss) { possessive(it) }
        return
      }

      if (poss.type == 'ME') out 'my'
      else if (poss.type == 'WE') out 'our'
      else if (poss.type == 'THEY') out 'their'
      else out poss.type
    }

  }

  private String noun(String type) {
    switch (type) {
      case 'THING': return 'thing'
      case 'NEIGHBOURS': return 'neighbors'
      case 'MATTER': return 'matter'
      case 'AMAZE': return 'amazement'
      case 'COUNTING': return 'counting'
      case 'ORDER': return 'order'
      case 'CASHIER': return 'cashier'
      case 'CORNER': return 'corner'
      case 'PREDICAMENT': return 'predicament'
      case 'HAMMER': return 'hammer'
      case 'MOUTH': return 'mouth'
      case 'NOSE': return 'nose'
      default: return type
    }

  }

}
