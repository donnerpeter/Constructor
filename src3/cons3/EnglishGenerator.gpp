package cons3

/**
 * @author peter
 */
class EnglishGenerator {
  List<String> output = []

  String generate(Chart chart) {
    new SituationGenerator(chart, chart.situations[0]).sentence()
    String result = ""
    for (w in output) {
      if (!result.empty && !(w in ['.', ','])) {
        result += " "
      }
      result += w
    }
    return result
  }

  private class SituationGenerator {
    final Chart chart
    final Situation situation
    final Frame sitFrame
    boolean hasSubject

    SituationGenerator(Chart chart, Situation situation) {
      this.chart = chart
      this.situation = situation
      sitFrame = situation.frame(chart)
    }

    private def sentence() {
      def excl = sitFrame.f('exclamation')
      if (excl) {
        output << 'Great'
        output << 'was'
        def a = chart.allAssignments(situation).find { it.frame != sitFrame && it.value == excl }
        if (a) {
          np(a.frame, true)
        }
        return
      }

      List<Frame> allVerbs = chart.frames(situation).findAll { it.type in ['HAPPEN', 'FORGET', 'COME_SCALARLY', 'GO_OFF', 'ASK', 'DISCOVER', 'ALSO'] }
      def verb = allVerbs[0]
      assert verb : situation.presentable(chart)

      clause(verb)

      if (allVerbs.size() > 1) {
        output << "and"
        clause(allVerbs[1])
      }

      if (sitFrame.s('dot') == 'true') {
        output << '.'
      }
    }

    private void clause(Frame verb) {
      def subj = verb.f('arg1')
      if (!hasSubject) {
        assert subj : "$verb; " + situation.presentable(chart)
        np(subj, true)
        hasSubject = true
      }


      if (verb.s('manner') == 'SUDDENLY') {
        output << 'suddenly'
      }
      if (verb.type != 'ALSO') {
        output << [HAPPEN: 'happened', FORGET: 'forgot', COME_SCALARLY: 'comes first', GO_OFF: 'went', ASK: 'asked', DISCOVER: 'discovered', CAN: "couldn't", REMEMBER:'recall'][verb.type]
      }

      def dobj = verb.f('arg2')
      if (dobj) {
        np(dobj, false)
      }

      def io = verb.type == 'HAPPEN' ? verb.f('experiencer') : verb.type == 'GO_OFF' ? verb.f('goal') : null
      if (io) {
        output << "to"
        np(io, false)
      }

      if (verb.type == 'HAPPEN') {
        output << "today"
      }

      def question = verb.f('question')
      if (question?.var instanceof Situation) {
        output << 'about'
        def think = chart.frames((Situation)question.var).find { it.type == 'THINK' }
        def exp = think.f('arg1')
        if (exp?.type == 'THEY') {
          output << 'their'
        }
        output << 'opinion'
        output << 'on'
        np(think.f('topic'), false)
      }

      def theme = verb.f('theme')
      if (theme?.var instanceof Situation) {
        if (!theme.f('questioned')) {
          output << ","
          output << "that"
        }

        new SituationGenerator(chart, (Situation)theme.var).sentence()
      } else if (theme && verb.type in ['CAN', 'ALSO']) {
        clause(theme)
      }

      def elaboration = sitFrame.f('elaboration')
      if (elaboration?.var instanceof Situation) {
        output << ","
        new SituationGenerator(chart, (Situation)elaboration.var).sentence()
      }

      def variants = subj?.allAssignments('variant')
      if (variants) {
        output << '-'
        def first = true
        for (var in variants) {
          if (first) first = false
          else output << 'or'
          np((Frame) var.value, true)
        }
      }
    }

    private def np(Frame n, boolean nom) {
      if (!n) {
        output << '???'
        return
      }

      if (n.s('type') == 'ME') {
        output << (nom ? 'I' : "me")
        return
      }
      if (n.s('type') == 'THEY') {
        output << (nom ? 'they' : "them")
        return
      }

      if (n == sitFrame.f('questioned')) {
        output << 'what'
        return
      }

      if (n.s('number') == 'true') {
        output << n.type
        return
      }

      determiner(n)
      if (n.s('property') == 'AMAZING') {
        output << "amazing"
      }
      def criterion = n.f('criterion')
      if (criterion) {
        output << noun(criterion.type)
      }

      output << noun(n.type)

      if (n.type == 'AMAZE') {
        def theme = n.f('theme')
        if (theme?.var instanceof Situation) {
          output << ','
          output << 'when'
          new SituationGenerator(chart, (Situation) theme.var).sentence()
        }
      }
    }

    private String determiner(Frame n) {
      def det = n.s('determiner')
      if (det == 'THIS') {
        output << 'this'
        return
      }

      if (n.type == 'AMAZE') {
        def assignments = n.allAssignments('arg1')
        if (!assignments.empty) {
          possessive((Frame)assignments[0].value)
          if (assignments.size() > 1) {
            output << 'and'
            possessive((Frame)assignments[1].value)
          }

          return
        }

      }

      if (n.type == 'NEIGHBOURS') {
        output << 'my' //todo using the actual inferred model information
        return
      }

      if (n.s('given') != 'false') {
        output << 'the'
        return
      }

      output << "An"
    }

    private void possessive(Frame poss) {
      if (poss.type == 'ME') output << 'my'
      else if (poss.type == 'THEY') output << 'their'
      else output << poss.type
    }

  }

  private String noun(String type) {
    switch (type) {
      case 'THING': return 'thing'
      case 'NEIGHBOURS': return 'neighbors'
      case 'MATTER': return 'matter'
      case 'AMAZE': return 'amazement'
      case 'COUNTING': return 'counting'
      case 'ORDER': return 'order'
      default: return type
    }

  }

}
