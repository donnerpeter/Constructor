package cons3

import groovy.transform.EqualsAndHashCode

/**
 * @author peter
 */
@EqualsAndHashCode
class Mite {
  final Construction cxt
  final FLinkedMap contents
  private final Map<Mite, Boolean> _contradictors = [:]

  Mite(Map contents, Construction cxt) {
    this.cxt = cxt
    this.contents = contents instanceof FLinkedMap ? contents : FLinkedMap.fromMap(contents)
  }

  boolean contradicts(Mite another) {
    if (another == this) return false

    if (!_contradictors.containsKey(another)) {
      boolean result
      if (another.cxt == cxt) {
        result = ParsingState.overwrites(another.contents, contents)
      } else {
        Set<Object> xor1 = contents.xor ?: [] as Set
        Set<Object> xor2 = another.contents.xor ?: [] as Set
        result = Util.intersects(xor1, xor2)
      }
      _contradictors[another] = result
    }
    return _contradictors[another]
  }

  List<Mite> findContradictors(Collection<Mite> mites) {
    mites.findAll { contradicts(it) } as List
  }

  @Override
  public String toString() {
    return "Mite{" +
           "cxt=" + cxt +
           ", contents=" + contents +
           '}';
  }

  boolean isSimilarTo(Mite another) {
    return cxt == another.cxt && contents.keySet() - 'xor' == another.contents.keySet() - 'xor'
  }

  Mite findSimilar(List<Mite> mites) {
    mites.find { isSimilarTo(it) }
  }


}
