package cons3

/**
 * @author peter
 */
class Mite {
  final Construction cxt
  final FLinkedMap contents
  final FList<Pair<Variable, Variable>> unifications
  private final Map<Mite, Boolean> _contradictors = [:]
  final Mite src1, src2

  Mite(Map contents, Construction cxt, FList<Pair<Variable, Variable>> unifications = FList.emptyList, Mite src1 = null, Mite src2 = null) {
    this.cxt = cxt
    this.contents = contents instanceof FLinkedMap ? contents : FLinkedMap.fromMap(contents)
    this.unifications = unifications
    this.src1 = src1
    this.src2 = src2
  }

  boolean contradicts(Mite another) {
    if (another == this) return false

    if (!_contradictors.containsKey(another)) {
      Set<Object> xor1 = contents.xor ?: [] as Set
      Set<Object> xor2 = another.contents.xor ?: [] as Set
      boolean result = Util.intersects(xor1, xor2)
      if (!result && another.cxt == cxt) {
        result = Util.intersects(primaries, another.primaries)
      }
      if (!result && another.cxt == cxt) {
        Set myVars = contents.values().findAll { it instanceof Variable }.collect { ((Variable) it).base } as Set
        Set anotherVars = another.contents.values().findAll { it instanceof Variable }.collect { ((Variable) it).base } as Set
        result = myVars == anotherVars
      }
      _contradictors[another] = result
    }
    return _contradictors[another]
  }

  List<Mite> findContradictors(Collection<Mite> mites) {
    List<Mite> result = []
    for (mite in mites) {
      if (contradicts(mite)) {
        result << mite
      }
    }
    result
  }

  @Override
  public String toString() {
    return "Mite{" +
           "cxt=" + cxt +
           ", contents=" + contents +
            (unifications ? ', uni=' + unifications : '') +
           '}';
  }

  boolean isSimilarTo(Mite another) {
    return cxt == another.cxt && contents.keySet() - 'xor' == another.contents.keySet() - 'xor'
  }

  Mite findSimilar(List<Mite> mites) {
    mites.find { isSimilarTo(it) }
  }

  Mite unify(Mite another) {
    def before = contents
    def newArgs = another.contents
    assert !ParsingState.overwrites(before, newArgs)
    def newUnifications = unifications.prependAll(another.unifications)
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      def val1 = before[arg]
      def val2 = newArgs[arg]
      if (ParsingState.areUnifiableVars(val1, val2)) {
        def pair = new Pair(val1, val2)
        if (!(pair in newUnifications)) {
          newUnifications = newUnifications.prepend(pair)
        }
      }
    }

    return new Mite(ParsingState.unify(before, newArgs), cxt, newUnifications, this, another)
  }

  LinkedHashSet<Mite> getPrimaries() {
    if (atom) {
      return [this]
    }
    return src1.primaries + src2.primaries
  }

  boolean isAtom() {
    src1 == null
  }

  boolean isPartOf(Mite another) {
    return another.cxt == cxt && another.primaries.containsAll(primaries)
  }

  List<Mite> unifyWherePossible(ParsingState state) {
    return unifyWherePossible(state.visibleMites[cxt], false, true)
  }

  List<Mite> unifyWherePossible(Collection<Mite> mites, boolean before, boolean includeSelf) {
    List<Mite> result = []
    if (includeSelf) {
      result << this
    }
    if (mites) {
      result.addAll mites.
              findAll { it.cxt == cxt && !ParsingState.overwrites(contents, it.contents) }.
              collect { before ? this.unify(it) : it.unify(this) }
    }
    return result
  }

  boolean contains(Mite another) {
    if (cxt != another.cxt) return false
    if (ParsingState.overwrites(contents, another.contents)) {
      return false
    }

    def unity = unify(another)
    if (unity.contents == contents && unity.unifications == unifications) {
      return true;
    } else {
      return false;
    }
  }

  boolean isMissingHead() {
    return cxt.headAttr && (!contents[cxt.headAttr] || ((Variable) contents[cxt.headAttr]).light)
  }

}
