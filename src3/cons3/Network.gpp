package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Network {
  final Map<Mite, Collection<Mite>> contradictors = [:]
  final Map<Object, Collection<Mite>> groups = [:]
  final LinkedHashSet<Mite> _chosen = []

  Network maximizeSatisfiedness() {
    Network net = this
    while (true) {
      Network better = tryMaximizeSatisfiedness(net, [])
      if (better == net) {
        return net
      }
      net = better
    }
  }
  private static Network tryMaximizeSatisfiedness(Network net, List<Mite> fixed) {
    Network best = net
    for (mite in net.chosenUnsatisfied) {
      for (alt in net.contradictors[mite]) {
        if (!alt.satisfied || fixed.find { net.contradict(it, alt) }) continue

        def appended = (fixed + [alt]) as List<Mite>

        def alternative = net.choose(appended)

        def unsatisfied1 = best.chosenUnsatisfied
        def unsatisfied2 = alternative.chosenUnsatisfied
        if (unsatisfied2.size() <= unsatisfied1.size()) {
          alternative = tryMaximizeSatisfiedness(alternative, appended)
          unsatisfied2 = alternative.chosenUnsatisfied
          if (unsatisfied2.size() < unsatisfied1.size()) {
            best = alternative
          }
        }
      }
    }
    return best
  }

  Network addMites(LinkedHashSet<Mite> mites) {
    Map<Mite, Collection<Mite>> newContradictors = [:] + contradictors
    Map<Object, Collection<Mite>> newGroups = [:] + groups

    for (mite in mites) {
      for (id in allGroups(mite)) {
        newGroups[id] = (newGroups[id] ?: []) + mite
      }
    }

    for (mite in mites) {
      LinkedHashSet<Mite> contras = []
      for (id in allGroups(mite)) {
        contras.addAll(newGroups[id])
      }
      contras.remove(mite)
      newContradictors[mite] = contras
      for (c in contras) {
        if (!(c in mites)) {
          newContradictors[c] = newContradictors[c] + mite
        }
      }
    }


    new Network(newContradictors, newGroups, _chosen)
  }

  boolean isChosen(Mite mite) {
    mite in _chosen
  }

  boolean contradict(Mite m1, Mite m2) {
    m1 != m2 && Util.intersects(allGroups(m1), allGroups(m2))
  }

  private Mite findChosenAncestor(Mite mite, Set<Mite> chosen) {
    while (mite) {
      if (mite in chosen) return mite
      mite = mite.src1
    }
    return null
  }

  private Set<Object> allGroups(Mite mite) {
    Set result = mite.primaries
    Set xor = mite.contents.xor
    if (xor) {
      result += xor
    }
    def prerequisites = mite.prerequisites
    for (p in prerequisites) {
      result += allGroups(p)
    }
    result
  }

  private Mite findMiteWithMostGroups(Collection<Mite> mites, LinkedHashSet<Object> queue) {
    Mite best = null
    for (mite in mites) {
      def groups = allGroups(mite)
      if (best == null || Util.intersect(groups, queue).size() > Util.intersect(allGroups(best), queue).size()) {
        best = mite
      }
    }
    return best
  }

  private Mite findBest(LinkedHashSet<Mite> unprocessed, LinkedHashSet<Mite> chosen, LinkedHashSet<Object> queue) {
    def best
    if (!best) {
      best = findMiteWithMostGroups(unprocessed.findAll { Mite mite -> !mite.atom && mite.satisfied }, queue)
    }
    if (!best) {
      best = findMiteWithMostGroups(unprocessed.findAll { Mite mite -> !mite.atom && contradictors[mite].every { !(it in chosen) } }, queue)
    }
    if (!best) {
      best = findMiteWithMostGroups(unprocessed.findAll { Mite mite -> !mite.atom }, queue)
    }
    if (!best) {
      best = findMiteWithMostGroups(unprocessed, queue)
    }
    return best
  }

  private LinkedHashSet<Mite> filterNonContradicting(LinkedHashSet<Mite> updated) {
    LinkedHashSet<Mite> filtered = []
    for (mite in updated) {
      if (!Util.intersects(contradictors[mite], filtered)) {
        filtered << mite
      }
    }
    return filtered
  }
  private LinkedHashSet<Mite> rearrangeUpdatedMites(List<Mite> updated) {
    LinkedHashSet<Mite> preferred = []
    preferred.addAll(updated.findAll { findChosenAncestor(it, _chosen) })
    preferred.addAll(updated.findAll { !it.atom && !hasChosenMergedContradictors(it) })
    preferred.addAll(updated)
    return preferred
  }

  private boolean hasChosenMergedContradictors(Mite mite) {
    return contradictors[mite].any { !it.atom && isChosen(it) }
  }


  Network choose(Collection<Mite> preferred) {
    LinkedHashSet<Mite> result = new LinkedHashSet<Mite>(_chosen)

    LinkedHashSet<Object> groupsToProcess = []
    LinkedHashSet<Object> processed = []

    for (mite in filterNonContradicting(rearrangeUpdatedMites(preferred as List))) {
      result << mite
      processed.addAll(allGroups(mite))
      for (displaced in Util.intersect(contradictors[mite], result)) {
        result.remove(displaced)
        groupsToProcess.addAll(allGroups(displaced))
      }
    }
    groupsToProcess.removeAll(processed)

    while (groupsToProcess) {
      LinkedHashSet<Mite> mitesToProcess = groupsToProcess.collect { groups[it] }.flatten() as LinkedHashSet
      LinkedHashSet<Mite> unprocessed = mitesToProcess.findAll { !Util.intersects(allGroups(it), processed) }

      Mite best = findBest(unprocessed, result, groupsToProcess)
      if (!best) {
         break
      }

      for (victim in Util.intersect(contradictors[best], result)) {
        result.remove(victim)
        def more = allGroups(victim)
        assert !Util.intersects(more, processed)
        groupsToProcess = new LinkedHashSet<Object>(more) + groupsToProcess
      }
      result << best
      groupsToProcess.removeAll(allGroups(best))
      processed.addAll(allGroups(best))
    }

    new Network(contradictors, groups, result)
  }

  LinkedHashSet<Mite> getChosenUnsatisfied() { return _chosen.findAll { !it.satisfied } }


}
