package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Node {
  static final Node EMPTY = new Node(Collections.emptyList(), Collections.emptySet())
  private static final Comparator nodeComparator = { ParsingState s1, ParsingState s2 ->
    s1.node.isMoreRecentThan(s2.node) ? -1 : s1 == s2 ? 0 : 1
  } as Comparator
  final List<Mite> ownMites
  final Set<Mite> _inhibited
  final Node before
  final ParsingState prevState
  private Map<Construction, List<Mite>> cache

  Map<Construction, List<Mite>> getAllMites() {
    Map<Construction, List<Mite>> result = cache
    if (result != null) {
      return result
    }

    result = [:]
    LinkedHashSet<Mite> toExclude = []

    if (_inhibited) {
      toExclude.addAll(_inhibited)
    }

    for (k in ownMites) {
      result[k.cxt] = (result[k.cxt] ?: []) + [k]
    }

    if (prevState && !ownMites) {
      result += prevState.visibleMites
    }

    for (k in ownMites) {
      Interceptor interceptor = k.contents.interceptor ?: new Interceptor()
      interceptor.getExtensionState(k, this).each { Construction c, List<Mite> oldMites ->
        result[c] = ((oldMites + (result[c] ?: [])) as LinkedHashSet) as List
      }
      toExclude.addAll(interceptor.getHiddenMites(k, prevState))
    }

    for (mite in toExclude) {
      def ms = (result[mite.cxt] ?: []) - mite
      if (!ms) {
        result.remove(mite.cxt)
      } else {
        result[mite.cxt] = ms
      }
    }
    cache = result
    return result
  }

  Node findNode(Mite mite) {
    if (mite in ownMites) {
      return this
    }
    return before.findNode(mite)
  }

  boolean isMoreRecentThan(Node node) {
    return node == this || before?.isMoreRecentThan(node)
  }

  LinkedHashSet<Mite> getFront() {
    if (ownMites) return ownMites as LinkedHashSet
    if (!before) return []
    return before.front - _inhibited
  }

}
