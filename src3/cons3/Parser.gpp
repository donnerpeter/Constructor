package cons3

import static cons3.Construction.cxt
import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Parser { //todo alex implements cons3.RussianConstructions
  public static final ArrayList<Construction> importantForSimilarity =
    [nom, acc, gen, dat, instr, prep, poDat,
            possessive, parenthetical, comeScalarly, elaboration, declOrQuestionComp, complementizer]
  String log = ""

  Chart parse(String text) {
    ParsingState state = new ParsingState()
    def tokenizer = new StringTokenizer(text, """ '":,.?!""", true)
    for (String w in tokenizer) {
      if (w != ' ') {
        state = handleWord(w.toLowerCase(), state)
        log += w + "\n"
        for (k in state.constructions.keySet()) {
          log += "  ${k in state.active ? '*' : ' '}$k -> ${state.constructions[k]}\n"
        }
      }
    }
    return state.chart
  }

  ParsingState conjWrap(Map<Construction, Map> constructions, ParsingState state) {
    return state.apply(constructions)
  }


  ParsingState handleWord(String word, ParsingState state) {
    Tokens t = new Tokens()
    if (Util.parseNumber(word) != null) { //todo generic noun treatment for numbers
      Variable noun = !state[gen]?.hasNoun && state[gen]?.noun ? state[gen].noun : new Variable()
      def num = new Variable()

      def sem = numberTypeCxt(noun, word)

      List<Construction> cases = [nom, acc, gen]

      def qv = state[questionVariants]
      if (qv) {
        def seqVar = new Variable()
        state = state.apply((questionVariants):[seq:seqVar], (nom):[:])
        def update = new Update((sem):[var:noun])
        for (caze in cases) {
          update = SeqInterceptor.joinSeq(state, caze, seqVar, noun: noun, [hasNoun: true, xor: t.a], 'noun', update)
        }
        state = update.apply(state)
      } else {
        state = conjWrap(cases.collectEntries { [it, [noun:noun, hasNoun:true, xor:t.a]] } +
                         [(sem):[var:noun, xor:t.bd],
                                 (numQuantifier):[num: num, xor:t.b, noun:noun, interceptor:new NumQuantifier(), prev:state, innerCase:(word == '1' ? acc : gen)],
                                 (numberTypeCxt(num, word)):[xor:t.d, var:num],
                                 (dativePart):[acc:noun]],
                state)
      }

      return state
    }

    if (state[quotedName]?.started && !state[quotedName].name) {
      state = state.apply(quotedName, name:word)
    }

    switch (word) {
      case "удивительный":
        def noun = new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'property', val:'AMAZING').apply(nom, noun:noun)
      case "знаменской": // todo a unified treatment for street names
      case "бассейной":
        def noun = new Variable()
        def init = { ParsingState it -> it.assign(noun, 'type', 'STREET') }
        state = conjWrap(state, (gen):[noun:noun, init:init], (adjective):[nounFrame:noun, rel:'name', val:word[0..-3]+"ая", init:init])
        return state
      case "коммерческий":
        def noun = state[acc]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'kind', val:'COMMERCIAL').apply(acc, noun:noun)
      case "маленький":
        def noun = state[acc]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'size', val:'LITTLE').apply(acc, noun:noun)
      case "летний":
        def noun = state[acc]?.noun ?: new Variable()
        return state.apply((adjective):[nounFrame:noun, rel:'timeAnchor', val:'SUMMER', xor:t.a], (acc):[noun:noun], (summerGarden):[summer:true, xor:t.a])
      case "какой-то":
        def noun = state[nom]?.noun ?: new Variable()
        return state.apply((adjective):[nounFrame:noun, rel:'determiner', val:'SOME'], (nom):[noun:noun])
      case "большим":
        def noun = state[instr]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'size', val:'BIG').apply(instr, noun:noun)
      case "большой":
        def noun = state[instr]?.noun ?: state[acc]?.noun ?: new Variable()
        return state.apply((adjective):[nounFrame:noun, rel:'size', val:'BIG'], (instr):[noun:noun], (acc):[noun:noun])
      case "нашем":
        def we = new Variable()
        state = state.assign(we, 'type', 'WE')
        return state.apply((possessive):[possessor:we])
      case "своим":
        def self = state[nom]?.noun ?: new Variable()
        return state.apply((nom):[noun:self], (possessive):[possessor:self])
      case "этому":
        def noun = state[dat]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'THIS').apply(dat, noun:noun)
      case "всякого":
        def noun = state[gen]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'ANY').apply(gen, noun:noun)
      case "скромному":
        def noun = state[dat]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'quality', val:'HUMBLE').apply(dat, noun:noun)
      case "том":
        def noun = state[prep]?.noun ?: new Variable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'THAT').apply(prep, noun:noun)
      case "случай": return noun(state, nom, 'THING') //todo случай=CASE or THING
      case "случае":
        def noun = state[prep]?.noun ?: new Variable()
        state = state.apply(prep, noun: noun, hasNoun:true) { ParsingState it ->it.assign(noun, 'type', 'CASE') }
        return state.apply(conditionComp, head:noun) //todo one noun frame - several cases
      case "удивление": return noun(state, nom, 'AMAZE')
      case "поводу": return noun(state, dat, 'MATTER')
      case "недоумении": return noun(state, prep, 'PREDICAMENT')
      case "рта": return noun(state, gen, 'MOUTH')
      case "смысла": return noun(state, gen, 'MEANING')
      case "молоточек": return noun(state, acc, 'HAMMER')
      case "радостью": return noun(state, instr, 'JOY')
      case "облегчением": return noun(state, instr, 'RELIEF')
      case "улицы": return noun(state, gen, 'STREET')
      case "скамейки": return noun(state, gen, 'BENCH')
      case "ребенок": return noun(state, nom, 'CHILD')
      case "углу":  //todo plain noun
        def noun = state[prep]?.noun ?: new Variable()
        state = state.apply(prep, noun: noun, hasNoun:true) {ParsingState it -> it.assign(noun, 'type', 'CORNER') }
        return state.apply(gen, head:noun) //todo one noun frame - several cases
      case "магазин":
        def noun = state[acc]?.noun ?: new Variable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'SHOP') }
        Update update = new Update([:])
        if (!state[preposition]?.hasNoun) {
          update = update.addCxt(nom, noun:noun, hasNoun:true, init:init, xor:t.a)
        }
        update = update.addCxt(acc, noun:noun, hasNoun:true, init:init, xor:t.a)
        update = update.addCxt(naPrep, head:noun)
        update = update.addCxt(quotedName, noun:noun)
        update = update.addCxt(relativeClause, noun:noun, save:state)
        return update.apply(state.satisfied(relativeClause))
      case "сад":
        def noun = state[acc]?.noun ?: new Variable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'GARDEN') }
        state = state.apply((nom):[noun:noun, hasNoun:true, init:init, xor:t.a], (acc):[noun:noun, hasNoun:true, init:init, xor:t.a], (summerGarden):[garden:noun])
        state = state.apply(naPrep, head:noun)
        state = state.satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
        return state //todo one noun frame - several cases
      case "сада": return noun(state, gen, 'GARDEN')
      case "магазина":
        def noun = state[gen]?.noun ?: new Variable()
        state = state.apply(gen, noun: noun, hasNoun:true) {ParsingState it -> it.assign(noun, 'type', 'SHOP') }
        state = state.apply(naPrep, head:noun)
        state = state.apply(quotedName, noun:noun).satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
        return state //todo one noun frame - several cases
      case "мнению":
        def noun = state[dat]?.noun && !state[dat]?.hasNoun ? state[dat].noun : new Variable()
        state = state.assign(noun, 'type', 'OPINION')
        return conjWrap(state, (gen):[head:noun], (possessive):[head:noun], (dat):[noun:noun, hasNoun:true],
                           (parenthetical):[:]) // todo common constructions in по-моему & по моему мнению
      case "словам":
        def noun = state[dat]?.noun ?: new Variable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'WORDS') }
        state = state.apply((dat):[noun:noun, hasNoun:true, init:init],
                            (gen):[head:noun, init:init],
                            (possessive):[head:noun, init:init])
        return state
      case "счастию":
        def noun = state[dat]?.noun ?: new Variable()
        return state.assign(noun, 'type', 'LUCK').apply((dat):[noun:noun, hasNoun:true])
      case "случился":
        Variable verb = new Variable()
        return finiteVerb(state, verb, 'HAPPEN', 'PAST', (sInstr):[head:verb], (nom):[head:verb])
      case 'со':
      case 'с':
        def noun = new Variable()
        return state.apply((preposition):[prep:'с'], (sInstr):[noun:noun, xor:t.b], (sGen):[noun:noun, xor:t.b])
      case 'по':
        return state.inhibit(gen, numQuantifier).apply((preposition):[prep:'по'], (poDat):[repeated:(state[seq] != null)])
      case 'о': return state.apply((preposition):[prep:'о'], (oPrep):[noun:new Variable()])
      case 'к': return state.apply((preposition):[prep:'к'], (kDat):[noun:new Variable()])
      case 'до':
        return state.apply((preposition):[prep:'до'], (doGen):[noun:new Variable()])
      case 'от':
        return state.apply((preposition):[prep:'от'], (otGen):[noun:new Variable()])
      case 'в':
        def noun = new Variable()
        return state.apply((preposition):[prep:'в'], (vAcc):[noun:noun, xor:t.b], (vPrep):[noun:noun, xor:t.b])
      case 'из':
      case 'изо': return state.apply((preposition):[prep:'из'], (izGen):[noun:new Variable()])
      case 'на': return state.apply((preposition):[prep:'на'], (naPrep):[noun:new Variable()])
      case "мной": return noun(state, instr, 'ME')
      case ":":
        if (state[directSpeech]) {
          //todo construction handling of elaboration and direct speech
          return state.apply(directSpeech, hasColon:true)
        }

        return state.clearConstructions().apply((elaboration):[head:state[verbHolder].head])
      case "я": return noun(state, nom, 'ME')
      case "мы": return noun(state, nom, 'WE')
      case "нам": return noun(state, dat, 'WE')
      case "нас": return noun(state, acc, 'WE')
      case "мое":
        def me = new Variable()
        return conjWrap(state, (possessive):[possessor:me, init:{ ParsingState it ->it.assign(me, 'type', 'ME') }])
      case "моему":
        def me = new Variable()
        return conjWrap(state, (possessive):[possessor:me, init:{ ParsingState it ->it.assign(me, 'type', 'ME') }])
      case "нашего":
        def me = new Variable()
        return conjWrap(state, (possessive):[possessor:me, init:{ ParsingState it ->it.assign(me, 'type', 'WE') }])
      case "и": return state.clearConstructions().apply(seq, conj:'and', interceptor:new SeqInterceptor(state, 'and'))
      case "или": return state.clearConstructions().apply(seq, conj:'or', interceptor:new SeqInterceptor(state, 'or'))
      case "а":
      case "но":
        def verb = new Variable()
        return state.clearConstructions().apply((seq):[conj:'but', interceptor:new SeqInterceptor(state, 'but')], (verbHolder):[head: verb], (prevHistory):[history:state]).
                assign(verb, word == 'а' ? 'andEmphasis' : 'butEmphasis', 'true')
      case "тут":
        def verb = state[verbHolder]?.head ?: new Variable()
        return state.assign(verb, 'emphasis', 'true').apply((verbHolder):[head:verb])
      case "потом":
        Update update = new Update((comeScalarly):[order:'AFTER', xor: t.a], (nom):[:])
        if (state[comeScalarly]?.order) {
          state = state.inhibit(comeScalarly)
        } else {
          update = update.addCxt(relTime, relTime:'AFTER', xor:t.a)
        }
        return conjWrap(update.map.reverse(), state)
      case "все":
        return state.assign(state[nom].noun, 'quantifier', 'ALL')
      case "дальше":
        def adv = new Variable()
        return state.apply((comeScalarly):[order:'AFTER', xor: t.a],  (advObj):[adv: adv, xor:t.a, init:{ ParsingState it ->it.assign(adv, 'type', 'NEXT') }])
      case "их":
        def they = new Variable()
        def init = {ParsingState st -> st.assign(they, 'type', 'THEY') }
        return conjWrap(state, (possessive):[possessor:they, init:init, xor:t.a], (acc):[noun:they, hasNoun:true, init:init, xor:t.a])
      case "они": return pronoun(state, nom, 'THEY')
      case "соседям": return noun(state, dat, 'NEIGHBOURS')
      case "кассир": return noun(state, nom) { ParsingState st, Variable n -> st.assign(n, 'type', 'CASHIER').assign(n, 'gender', 'masc') }
      case "кассиршу": return noun(state, acc, 'CASHIER')
      case "кассирша": return noun(state, nom) { ParsingState st, Variable n -> st.assign(n, 'type', 'CASHIER').assign(n, 'gender', 'fem') }
      case "кассирши": return noun(state, gen, 'CASHIER')
      case "одних": return noun(state, gen, 'SOME')
      case "других": return noun(state, gen, 'OTHERS')
      case "деревья": return noun(state, acc, 'TREES')
      case "деньги": return noun(state, acc, 'MONEY')
      case "спора": return noun(state, gen, 'ARGUE')
      case "ее":
      case "её":
        def she = new Variable()
        def init = {ParsingState st -> st.assign(she, 'type', 'SHE') }
        return conjWrap(state, (possessive):[possessor:she, init:init], (acc):[noun:she, hasNoun:true, init:init])
      case "носом": return noun(state, instr, 'NOSE')
      case "пальцев": return noun(state, gen, 'FINGERS')
      case "пальца": return noun(state, gen, 'FINGERS')
      case "палец": return noun(state, acc, 'FINGER')
      case "домам": return noun(state, dat, 'HOMES')
      case "комнатам": return noun(state, dat, 'ROOMS')
      case "квартирам": return noun(state, dat, 'APARTMENTS')
      case "офисам": return noun(state, dat, 'OFFICES')
      case "челюсти":
        Variable noun = state[gen]?.noun && !state[gen].hasNoun ? state[gen].noun : new Variable()
        return conjWrap(state, (gen):[noun: noun, hasNoun:true], (acc):[noun:noun, hasNoun:true], (dativePart):[acc: noun], (typeCxt(noun, 'JAWS')):[var:noun], (numQuantifier):[noun:noun])
      case "челюстью": return noun(state, instr, 'JAW')
      case "челюсть":
        def noun = new Variable()
        return conjWrap(state, (acc):[noun: noun, hasNoun:true], (dativePart):[acc: noun], (typeCxt(noun, 'JAW')):[var:noun])
      case "семь": return numeral(state, t, '7')
      case "семи": return noun(state, gen, '7')
      case "восемь": return numeral(state, t, '8')
      case "восьми": return noun(state, gen, '8')
      case "два": return numeral(state, t, '2')
      case "три": return numeral(state, t, '3')
      case "один": return numeral(state, t, '1')
      case "порядок":
        def noun = new Variable()
        state = state.apply(acc, noun: noun, hasNoun:true) { ParsingState it ->it.assign(noun, 'type', 'ORDER') }
        return state.apply(gen, head:noun) //todo one noun frame - several cases
      case "слова":
        def noun = state[acc]?.hasNoun ? new Variable() : state[acc]?.noun ?: new Variable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'WORDS') }
        Update update = new Update((acc):[noun:noun, hasNoun:true, init:init, xor:t.a],
                                   (gen):[head:noun, init:init],
                                   (possessive):[head:noun, init:init])
        if (!state[preposition]) {
          update = update.addCxt(nom, noun:noun, hasNoun:true, init:init, xor:t.a)
        }
        state = update.apply(state)
        return state
      case "счета": return noun(state, gen, 'COUNTING')
      case "счете": return noun(state, prep, 'COUNTING')
      case "работы":
        state = noun(state, gen, 'WORK')
        state = state.apply(absTime, noun:state[posleGen].noun)
        return state
      case "вдруг": return state.apply(adverb, adv:'SUDDENLY')
      case "опять":
        if (state[nom]) {
          def verb = state[verbHolder]?.head ?: new Variable()
          return state.assign(verb, 'anchor', 'AGAIN').apply(nom, head:verb)
        }
        return state
      case "слегка": return state.apply(adverb, adv:'SLIGHTLY')
      case "долго": return state.apply(adverb, adv:'LONG')
      case "грустно": return state.apply(adverb, adv:'SADLY')
      case "тоже":
        return state.apply(also, hasAlso:true)
      case "не":
        return state.apply(negation)
      case "забыл":
      case "забыла":
      case "забыли":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        state = finiteVerb(state.inhibit(declOrQuestionComp), verb, 'FORGET', 'PAST',
                (advObj):[head:verb, xor:t.a], (acc):[head:verb, xor:t.a], (declOrQuestionComp):[head:verb, xor:t.a]) //todo the order shouldn't matter for verb arguments
        return state.apply((nom):[head:verb, agr:(word == 'забыли' ? 'pl' : word == 'забыла' ? 'fem' : 'masc')], (adverb):[head:verb], (elaboration):[elaboration:verb])
      case "помнят":
      case "помнит":
        Variable verb = new Variable()
        state = finiteVerb(state, verb, 'REMEMBER', 'PRESENT', (acc):[head:verb])
        return state.apply((nom):[head:verb, agr:(word == 'помнят' ? '3pl' : '3sg')], (verbHolder):[head:verb])
      case "могут":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        def subj = state[nom]?.noun && SeqInterceptor.agree(state[nom].agr, 'pl') ? state[nom].noun : new Variable()
        if (state[negation] != null) {
          state = state.assign(verb, 'negated', 'true')
        }
        return finiteVerb(state, verb, 'CAN', 'PRESENT', (control):[subj:subj, head:verb], (nom):[noun:subj, agr:'pl', head:verb])
      case 'стали':
      case 'начали':
        Variable verb = state[verbHolder]?.head ?: new Variable()
        return finiteVerb(state.inhibit(preposition), verb, 'BEGIN', 'PAST', (control):[head:verb], (nom):[head:verb])
      case 'свалился':
        def verb = new Variable()
        return finiteVerb(state, verb, 'FALL', 'PAST', (nom):[head:verb, agr:'masc'], (sGen):[head:verb], (poDat):[head:verb])
      case 'сломал':
      case 'сломала':
        def verb = new Variable()
        return finiteVerb(state, verb, 'BREAK', 'PAST', (nom):[head:verb, agr: (word == 'сломал' ? 'masc' : 'fem')], (acc):[head:verb], (dat):[head:verb], (dativePart):[head:verb])
      case "отвлекло":
        def verb = new Variable()
        return finiteVerb(state, verb, 'DISTRACT', 'PAST', (otGen):[head:verb], (nom):[head:verb], (acc):[head:verb])
      case "отправился":
        def verb = new Variable()
        return finiteVerb(state, verb, 'GO_OFF', 'PAST', (kDat):[head:verb], (nom):[head:verb])
      case "пошли":
        def verb = new Variable()
        return finiteVerb(state, verb, 'GO', 'PAST', (nom):[head:verb], (vAcc):[head:verb])
      case "спорили":
        def verb = new Variable()
        return finiteVerb(state, verb, 'ARGUE', 'PAST', (nom):[head:verb, agr:'pl'], (adverb):[head:verb])
      case "обнаружили":
        def verb = new Variable()
        return finiteVerb(state, verb, 'DISCOVER', 'PAST', (declOrQuestionComp):[head:verb], (nom):[head:verb], (adverb):[head:verb])
      case "улыбнулась":
        def verb = new Variable()
        return finiteVerb(state, verb, 'SMILE', 'PAST', (nom):[head:verb], (adverb):[head:verb])
      case "сказал":
      case "сказала":
        def verb = new Variable()
        return finiteVerb(state, verb, 'SAY', 'PAST', (nom):[head:verb], (directSpeech):[head:verb])
      case "вынул":
      case "вынула":
        def verb = new Variable()
        return finiteVerb(state, verb, 'TAKE_OUT', 'PAST', (nom):[head:verb], (acc):[head:verb], (izGen):[head:verb])
      case "показались":
        def verb = new Variable()
        return finiteVerb(state, verb, 'SEEM', 'PAST', (nom):[head:verb], (dat):[head:verb], (participleArg):[head:verb])
      case "подвигав":
        def verb = new Variable()
        state = state.assign(verb, 'type', 'MOVE').assign(verb, 'background', 'perfect')
        return conjWrap(state, (instr):[head:verb], (adverb):[head:verb])
      case "подвигала":
        def verb = new Variable()
        return finiteVerb(state, verb, 'MOVE', 'PAST', (instr):[head:verb], (adverb):[head:verb], (nom):[head: verb])
      case "дойдя":
        def verb = state[instr]?.head ?: new Variable()
        state = state.assign(verb, 'type', 'COME_TO').assign(verb, 'background', 'perfect')
        return conjWrap(state, (vPrep):[head:verb], (doGen):[head:verb])
      case "вдумываясь":
        def verb = new Variable()
        state = state.assign(verb, 'type', 'THINK').assign(verb, 'background', 'present')
        return conjWrap(state, (vAcc):[head:verb])
      case "вспомнить":
        def verb = new Variable()
        return infinitive(state, verb, 'RECALL', [(acc):[head:verb]])
      case "делать":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        return infinitive(state, verb, 'DO', [(acc):[head:verb]])
      case "спорить":
        def verb = new Variable()
        return infinitive(state, verb, 'ARGUE', [:])
      case "считать":
        def verb = new Variable()
        return infinitive(state, verb, 'COUNT', [(acc):[head:verb]])
      case "поливать":
        def verb = new Variable()
        return infinitive(state, verb, 'TO_WATER', [(acc):[head:verb]])
      case "танцевать":
        def verb = new Variable()
        return infinitive(state, verb, 'DANCE', [:])
      case "нужно":
        def verb = new Variable()
        return state.assign(verb, 'type', 'NEED').apply((acc):[head:verb], (dat):[head:verb, infinitive:true], (adverbPred):[adverb:verb], (verbHolder):[head:verb])
      case "спросить":
        def verb = new Variable()
        return infinitive(state, verb, 'ASK', [(acc):[head:verb]])
      case "думают":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        return finiteVerb(state, verb, 'THINK', 'PRESENT', (poDat):[head:verb], (nom):[head:verb], (acc):[head:verb])
      case "спросил":
      case "спросили":
        def verb = new Variable()
        return finiteVerb(state, verb, 'ASK', 'PAST', (acc):[head:verb], (nom):[head:verb], (declOrQuestionComp):[head:verb], (oPrep):[head:verb])
      case "делал":
      case "делали":
        def verb = new Variable()
        return finiteVerb(state, verb, 'DO', 'PAST', (acc):[head:verb], (nom):[head:verb])
      case "поблагодарили":
        def verb = new Variable()
        return finiteVerb(state, verb, 'THANK', 'PAST', (acc):[head:verb], (nom):[head:verb])
      case "разошлись":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        return finiteVerb(state, verb, 'DISPERSE', 'PAST', (poDat):[head:verb], (nom):[head:verb])
      case "выбежали":
        def verb = new Variable()
        return finiteVerb(state, verb, 'RUN_OUT', 'PAST', (izGen):[head:verb], (nom):[head:verb], (sInstr):[head:verb])
      case "приуныли":
        Variable verb = state[nom]?.head ?: new Variable()
        return finiteVerb(state, verb, 'GET_SAD', 'PAST', (nom):[head:verb], (reasonComp):[head:verb])
      case "остановились":
        Variable verb = state[verbHolder]?.head ?: new Variable()
        return finiteVerb(state, verb, 'STOP', 'PAST', (nom):[head:verb])
      case ",":
        if (state[nestedClause]) {
          return state.withSituation((Situation)state[nestedClause].parent).clearConstructions().restore((ParsingState) state[nestedClause].save).satisfied(nestedClause)
        }
        Update update = new Update((conditionComp):[hasComma:true],
                                   (reasonComp):[hasComma:true],
                                   (declOrQuestionComp):[hasComma:true],
                                   (relativeClause):[hasComma:true, parentSituation: state.situation],
                                   (prevHistory):[history:state])
        if (!state[seq]?.conj) {
          update = update.addCxt(seq, interceptor:new SeqInterceptor(state, null))
        }
        return update.apply(state.inhibit(numQuantifier))
      case "если":
        return state.apply((conditionComp):[wh:'if'])
      case "когда":
        return state.apply((conditionComp):[wh:'when'])
      case "это":
        def noun = new Variable()
        return state.apply((nom):[noun:noun, hasNoun:true, xor:t.a], (acc):[noun:noun, hasNoun:true, xor:t.a], (typeCxt(noun, 'THAT')):[var:noun])
      case "что":
        def noun = new Variable()
        def verb = new Variable()
        state = state.inhibit(nom, acc, complementizer, advObj).
                apply((declOrQuestionComp):[comp: verb, questioned: noun], (verbHolder):[head:verb],
                        (acc):[noun:noun, hasNoun:true, xor:t.a], (nom):[noun:noun, hasNoun:true, xor:t.a, agr:'3sg'], (typeCxt(noun, 'wh')):[var:noun],
                        (complementizer):[xor:t.a, hasComplementizer:true]
                )
        if (state[relativeClause]?.hasComma) {
          def wh = new Variable()
          state = state.apply(relativeClause, wh:wh).apply(naPrep, head:wh, copula:new Variable()) //todo pp copula
        }
        return state
      case "идет":
      case "идёт":
        def verb = state[verbHolder]?.head ?: new Variable()
        state = state.assign(verb, 'time', 'PRESENT')
        def goes = cxt('идёт') { ParsingState st, Map args -> st.assign(args.verb, 'type', 'GO') }
        return state.inhibit(preposition, numQuantifier).apply((comeScalarly):[verb:verb, xor:t.ab], (goes):[verb:verb, xor:t.a],
                                                (vAcc):[head:verb, xor:t.b], (vPrep):[head:verb], (nom):[head:verb],
                (poDat):[head:verb], (verbHolder): [head:verb],
                                                (posleGen):[head:verb], (ransheGen):[head:verb],
                                                (conditionComp):[head:verb], (absTime):[head:verb])
      case "следовало":
        Variable verb = new Variable()
        state = state.assign(verb, 'time', 'PAST')
        return state.inhibit(preposition, numQuantifier).apply((nom):[head:verb],
                (comeScalarly):[verb:verb],
                (posleGen):[head:verb], (relTime):[head:verb], (poDat):[head:verb], (verbHolder):[head:verb], (elaboration):[elaboration:verb])
      case "раньше":
        return state.apply((comeScalarly):[order:'EARLIER', xor:t.a], (preposition):[prep:'ranshe'], (relTime):[relTime:'BEFORE', xor:t.a])
      case "после":
        return state.apply((comeScalarly):[order:'AFTER', xor:t.a], (preposition):[prep:'posle'], (absTime):[rel:'AFTER', xor:t.a])
      case "-":
        if (state[directSpeech]) {
          return state.apply(directSpeech, hasDash:true)
        }
        if (state[declOrQuestionComp]?.questioned) {
          state = state.clearConstructions().apply((questionVariants):[questioned:state[declOrQuestionComp].questioned], (verbHolder):[head:state[verbHolder]?.head])
        }
        if (state[prevHistory]) {
          state = state.apply(clauseEllipsis, interceptor:new EllipsisInterceptor((ParsingState) state[prevHistory].history, state))
        }
        return state
      case ".":
        return state.assign(state[verbHolder]?.head ?: new Variable(), 'dot', 'true').withSituation(new Situation())
      case 'каково':
        def degree = new Variable()
        return state.assign(degree, 'type', 'wh').apply(shortAdj, copula: new Variable(), value:degree)
      case 'бы':
        return state.apply((subjunctive):[subjunctive:true])
      case 'был':
        def subj = state[nom]?.noun ?: new Variable()
        def copula = new Variable()
        state = state.assign(copula, 'time', 'PAST')
        return state.apply((naPrep):[head: subj, copula: copula], (nom):[noun:subj], (verbHolder):[head:copula])
      case 'было':
        return state.apply((conditionComp):[head:state[shortAdj]?.copula], (shortAdj):[time:'PAST'], (declOrQuestionComp):[time:'PAST'], (adverbPred):[time:'PAST'])
      case 'так':
        return state.apply(reasonComp, active:true)
      case 'обе':
        def num = new Variable()
        def noun = new Variable()
        return state.inhibit(numQuantifier).assign(num, 'type', 'BOTH').apply((acc):[noun:noun, hasNoun:true], (numQuantifier):[num:num, interceptor:new NumQuantifier(), prev:state, noun:noun, innerCase:gen])
      case 'себе':
        def noun = state[nom]?.noun ?: new Variable()
        return state.apply((nom):[noun:noun], (dat):[noun:noun], (dativePart):[dat:noun])
      case 'мне':
        def noun = new Variable()
        return state.assign(noun, 'type', 'ME').apply((dat):[noun:noun], (dativePart):[dat:noun])
      case 'по-моему':
        def opinion = new Variable()
        def me = new Variable()
        def verb = state[verbHolder]?.head ?: new Variable()
        return state.assign(verb, 'opinion_of', opinion).assign(opinion, 'type', 'OPINION').assign(opinion, 'arg1', me).assign(me, 'type', 'ME').
                apply((verbHolder):[head:verb], (parenthetical):[:])
      case '?': return state.apply((declOrQuestionComp):[comp:state[verbHolder].head])
      case '"':
        if (state[quotedName]) {
          if (state[quotedName].started) {
            state = state.apply(quotedName, finished:true)
          } else {
            state = state.apply(quotedName, started:true)
          }
        }
        return state
      case 'лишенными':
        def lack = new Variable()
        state = state.assign(lack, 'type', 'LACK')
        return state.apply(participleArg, participle:lack).apply(gen, head:lack)
      case 'бессмысленными':
        def part = new Variable()
        state = state.assign(part, 'type', 'MEANINGLESS')
        return state.apply(participleArg, participle:part)
      case '6-ти':
      case 'шести':
        return noun(state, gen, '6')
      case '5-ти':
        return noun(state, gen, '5')
    }
    return state
  }

  ParsingState numeral(ParsingState state, Tokens t, String number) {
    def noun = new Variable()
    def num = new Variable()
    return state.inhibit(numQuantifier).
            apply((nom): [noun: noun, hasNoun:true, xor: t.ae], (acc): [noun: noun, hasNoun:true, xor: t.ae], (typeCxt(noun, number)): [xor: t.bd, var: noun], (dativePart):[acc:noun],
                  (numQuantifier): [num: num, xor: t.b, noun:noun, interceptor: new NumQuantifier(), prev: state, innerCase:(number == '1' ? acc : gen)], (typeCxt(num, number)): [xor: t.d, var: num])
  }

  private Construction numberTypeCxt(Variable var, String word) {
    return cxt("sem_number_${var}_$word") { ParsingState st, Map args -> st.assign(args.var, 'type', word).assign(args.var, 'number', 'true') }
  }

  static boolean areSimilar(Map<Construction, Map> c1, Map<Construction, Map> c2) {
    def common = Util.intersect(c1.keySet(), c2.keySet())
    common = Util.intersect(common, importantForSimilarity)
    def condition = { Construction cxt -> (c1[cxt].keySet() - 'init' - 'xor') == (c2[cxt].keySet() - 'init' - 'xor') }
    common = common.findAll(condition)

    if (!common) {
      return false
    }

    if (common.size() == 1 && possessive in common && c1[possessive].head) {
      return false
    }

    if (numQuantifier in c1 && numQuantifier in c2 && !condition(numQuantifier)) {
      return false
    }

    if ((complementizer in c1 || complementizer in c2) && !(complementizer in common)) {
      return false
    }

    return true
  }

  private ParsingState infinitive(ParsingState state, Variable verb, String type, Map<Construction, Map> args) {
    return state.assign(verb, 'type', type).apply(args +
            [(dat): [head: verb, infinitive: true], (control): [slave: verb], (declOrQuestionComp): [modality: new Variable(), mainVerb:verb], (verbHolder):[head:verb]])
  }

  private ParsingState finiteVerb(Map<Construction, Map> args, ParsingState state, Variable verb, String type, String tense) {
    return state.inhibit(preposition, declOrQuestionComp, relativeClause, numQuantifier).
            assign(verb, 'type', type).assign(verb, 'time', tense).
            apply(args + [(subjunctive):[head:verb], (verbHolder):[head:verb], (relTime):[head:verb], (also):[head: verb], (complementizer):[:]])
  }

  private ParsingState noun(ParsingState state, Construction caze, String type) {
    return noun(state, caze) { ParsingState st, Variable n -> st.assign(n, 'type', type) }
  }
  private ParsingState noun(ParsingState state, Construction caze, Closure init) {
    state = state.satisfied(relativeClause)

    Update update = _nounBase(state, caze, init)

    def noun = update.map[caze].noun
    update = update.addCxt(possessive, head: noun)

    update = update.addCxt(quotedName, noun:noun).addCxt(numQuantifier, noun:noun)

    return conjWrap(update.map.reverse(), state)
  }
  private ParsingState pronoun(ParsingState state, Construction caze, String type) {
    state = state.satisfied(relativeClause)

    Update update = _nounBase(state, caze, { ParsingState st, Variable n -> st.assign(n, 'type', type) })

    return conjWrap(update.map.reverse(), state)
  }

  private Update _nounBase(ParsingState state, Construction caze, Closure init) {
    Variable noun = state[caze]?.noun && !state[caze].hasNoun ? state[caze]?.noun : new Variable()

    def typeNoun = noun.frame(state.chart).f('member') ? noun.frame(state.chart).f('member').var : noun

    Update update = new Update([:])

    if (caze == nom) {
      update = update.addCxt(shortAdj, noun:noun)
    }

    update = update.addCxt(caze, noun:noun, hasNoun:true, init:{ init(it, typeNoun) })

    update = update.addCxt(relativeClause, noun:noun, save:state)
    return update
  }


  private Construction typeCxt(Variable var, String type) {
    return cxt("type_${var}_$type") { st, a -> st.assign(a.var, 'type', type) }
  }

}

