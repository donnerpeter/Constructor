package cons3

/**
 * @author peter
 */
class Parser {

  Chart parse(String text) {
    def chart = new Chart()
    ParsingState state = [chart.newSituation()]
    def tokenizer = new StringTokenizer(text, """ '":,.""", true)
    for (String w in tokenizer) {
      if (w != ' ') {
        state = handleWord(w, state)
      }
    }
    return chart
  }

  static class ParsingState {
    final Situation situation
    final Frame lastFrame
    private Map<String, Frame> participants = [:]

    ParsingState(Situation situation) {
      this(situation, null, [:])
    }

    private ParsingState(Situation situation, Frame lastFrame, Map<String, Frame> participants) {
      this.lastFrame = lastFrame
      this.situation = situation
      this.participants = participants
    }

    ParsingState withFrame(Frame frame) {
      assert frame
      [situation, frame, participants]
    }

    ParsingState withSituation(Situation situation) { [situation, null, [:]] }

    ParsingState withRole(String key, Frame frame = null) {
      if (!frame) {
        frame = getAt(key) ?: situation.newFrame()
      }
      [situation, frame, participants + [(key): frame]]
    }

    Frame getAt(String key) { participants[key] }

    Frame getVerb() { getAt('verb') }

  }

  ParsingState handleWord(String word, ParsingState state) {
    def situation = state.situation
    switch (word) {
      case "Удивительный": return adj(state, "property", "AMAZING", true, 'nom')
      case "этому": return adj(state, 'determiner', 'THIS', false, 'dat')
      case "случай": return noun(state, 'nom', "THING", true)
      case "поводу": return noun(state, 'dat', "MATTER", false)
      case "случился": return verb(state, "HAPPEN", "PAST", true)
      case "мной": return noun(state, 'instr', 'ME', false)
      case ":":
        def elaboration = situation.chart.newSituation()
        situation.assign(situation, 'elaboration', elaboration, true)
        return state.withSituation(elaboration)
      case "я":
      case "Я": return noun(state, 'nom', 'ME', false)
      case "их": return noun(state, 'acc', 'THEY', false)
      case "они": return noun(state, 'nom', 'THEY', false)
      case "соседям": return noun(state, 'dat', 'NEIGHBOURS', false)
      case "вдруг":
        state = state.withRole('verb')
        situation.assign(state.verb, "manner", "SUDDENLY", true)
        return state
      case "забыл": return verb(state, 'FORGET', 'PAST', true)
      case "отправился": return verb(state, 'GO_OFF', 'PAST', true)
      case "думают": return verb(state, 'THINK', 'PRESENT', false)
      case "спросил": return verb(state, 'ASK', 'PAST', true)
      case ",":
        def question = situation.chart.newSituation()
        def verb = state.verb
        def role = verb.type == 'FORGET' ? 'theme' : 'question'
        situation.assign(verb, role, question, true)
        return state.withSituation(question)
      case "что":
        state = state.withRole('nom')
        situation.assign(situation, "questioned", state.lastFrame, true)
        return state.withRole('questioned', state.lastFrame)
      case "идет": return verb(state, 'COME_SCALARLY', 'PRESENT', false)
      case "раньше":
        situation.assign(state.verb, 'order', 'EARLIER', false)
        return state
      case "-":
        return state.withFrame(state['nom'])
      case "7":
      case "8":
        situation.assign(state.lastFrame, 'variant', word, false)
        return state
    }
    return state
  }

  private ParsingState verb(ParsingState state, String type, String time, boolean rheme) {
    def situation = state.situation
    state = state.withRole('verb', !state.verb || state.verb.type ? situation.newFrame() : state.verb)
    situation.assign(state.verb, "type", type, rheme)
    if (!situation.s('time')) {
      situation.assign(situation, "time", time, false)
    }
    thetas(state)
    return state
  }

  private ParsingState noun(ParsingState state, String caze, String type, boolean rheme) {
    def existing = state[caze]
    if (existing && (existing.s('type') || existing == state['questioned'])) {
      state = state.withRole('acc', existing).withRole(caze, state.situation.newFrame())
    } else {
      state = state.withRole(caze)
    }

    state.situation.assign(state.lastFrame, "type", type, rheme)
    thetas(state)
    return state
  }

  private ParsingState adj(ParsingState state, String attr, String value, boolean rheme, String caze) {
    state = state.withRole(caze)
    state.situation.assign(state.lastFrame, attr, value, rheme)
    thetas(state)
    return state
  }

  private void thetas(ParsingState state) {
    def verb = state.verb
    def type = verb?.type
    if (!type) return


    if (type == 'THINK') {
      ensureTheta state, 'nom', 'experiencer', false
      ensureTheta state, 'acc', 'opinion', false
      ensureTheta state, 'dat', 'topic', false //todo poDat
    }
    if (type == 'HAPPEN') {
      ensureTheta state, 'nom', 'theme', true
      ensureTheta state, 'instr', 'experiencer', true //todo sInstr
    }
    if (type == 'COME_SCALARLY') {
      ensureTheta state, 'nom', 'theme', false
    }
    if (type == 'GO_OFF') {
      ensureTheta state, 'nom', 'agent', true
      ensureTheta state, 'dat', 'goal', true //todo kDat
    }
    if (type == 'ASK') {
      ensureTheta state, 'nom', 'agent', true
      ensureTheta state, 'acc', 'addressee', true
    }
    if (type == 'FORGET') {
      ensureTheta state, 'nom', 'experiencer', true
    }

  }

  private void ensureTheta(ParsingState state, String caze, String theta, boolean rheme) {
    if (state[caze] && !state.verb.f(theta)) {
      state.situation.assign(state.verb, theta, state[caze], rheme)
    }
  }

}