package cons3

import static cons3.Construction.cxt
import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Parser { //todo alex implements cons3.RussianConstructions
  String log = ""

  Chart parse(String text) {
    ParsingState state = new ParsingState()
    def tokenizer = new StringTokenizer(text, """ '":,.?!""", true)
    for (String w in tokenizer) {
      if (w != ' ') {
        state = handleWord(w.toLowerCase(), state)
        log += w + "\n" + state.presentable()
      }
    }
    return state.chart
  }

  ParsingState handleWord(String word, ParsingState state) {
    Update _update = Verbs.parseUpdate(word) ?: parseUpdate(word)
    if (_update) {
      return _update.apply(state)
    }

    Tokens t = new Tokens()
    Vars v = new Vars()
    Variable var = new Variable()
    if (Util.parseNumber(word) != null) { //todo generic noun treatment for numbers
      Variable noun = var
      Variable num = new Variable()

      def sem = numberTypeCxt(noun, word)

      List<Construction> cases = [nom, acc, gen]

      def qv = state[questionVariants]
      if (qv?.questioned && !qv?.seq) {
        def seqVar = new Variable()
        state = state.apply((questionVariants):[seq:seqVar])
        Update update = u(sem(var:noun), seq(multi:seqVar, second:noun))
        for (caze in cases) {
          update = update.addCxt(caze, noun:seqVar)
        }
        state = update.apply(state)
      } else {
        state = state.apply(cases.collectEntries { [it, [noun:noun, xor:t.a]] } +
                         [(sem):[var:noun, xor:t.bd],
                                 (numQuantifier):[num: num, xor:t.b, noun:noun.lightVar, outerNoun:noun, prev:state, innerCase:(word == '1' ? acc : gen)],
                                 (numberTypeCxt(num, word)):[xor:t.d, var:num]
                                 ])
      }

      return state
    }

    switch (word) {
      case "удивительный": return adj(state, nom, 'property', 'AMAZING')
      case "коммерческий": return adj(state, acc, 'kind', 'COMMERCIAL')
      case "маленький": return adj(state, acc, 'size', 'LITTLE')
      case "летний":
        return state.apply((adjective):[nounFrame:var.lightVar, rel:'timeAnchor', val:'SUMMER', xor:t.a], (acc):[noun:var.lightVar], (summerGarden):[summer:true, xor:t.a])
      case "какой-то": return adj(state, nom, 'determiner', 'SOME')
      case "большим": return adj(state, instr, 'size', 'BIG')
      case "большой":
        return state.apply((adjective):[nounFrame:var.lightVar, rel:'size', val:'BIG'], (instr):[noun:var.lightVar], (acc):[noun:var.lightVar])
      case "нашем":
        state = state.assign(var, 'type', 'WE')
        return state.apply((possessive):[possessor:var])
      case "своим":
        return state.apply((reflexiveHolder):[noun:var.lightVar], (possessive):[possessor:var])
      case "этому": return adj(state, dat, 'determiner', 'THIS')
      case "всякого": return adj(state, gen, 'determiner', 'ANY')
      case "скромному": return adj(state, dat, 'quality', 'HUMBLE')
      case "том": return adj(state, prep, 'determiner', 'THAT')
      case "случай": return noun(state, nom, 'THING') //todo случай=CASE or THING
      case "поводу": return noun(state, dat, 'MATTER')
      case "рта": return noun(state, gen, 'MOUTH')
      case "молоточек": return noun(state, acc, 'HAMMER')
      case "радостью": return noun(state, instr, 'JOY')
      case "облегчением": return noun(state, instr, 'RELIEF')
      //case "улицы": return noun(state, gen, 'STREET') todo улицы in conj
      case "скамейки": return noun(state, gen, 'BENCH')
      case "ребенок": return noun(state, nom, 'CHILD')
      case "гастроном": return state.apply((RussianConstructions.word):[word:word])
      case "сад":

        state = state.apply((typeCxt('GARDEN')):[var:var],
                (nom):[noun:var, xor:t.a], (acc):[noun:var, xor:t.a],
                (summerGarden):[garden:var], (naPrep):[head:var], (relativeClause):[noun:var])
        return state //todo one noun frame - several cases
      case "сада": return noun(state, gen, 'GARDEN')
      case "магазина":
        return state.apply((typeCxt('SHOP')):[var:var], (gen):[noun:var],
                (naPrep):[head:var], (quotedName):[noun:var], (relativeClause):[noun:var])
      case "случился":
        return finiteVerb(state, var, 'HAPPEN', 'PAST',
                (sInstr):[noun:v[sInstr].lightVar, head:var], (sInstrExperiencer):[head:var, noun:v[sInstr]],
                (nom):[noun:v[nom].lightVar], (nomSubject):[head:var, noun:v[nom]])
      case 'со':
      case 'с':
        return state.apply((preposition):[prep:'с'],
                (sInstr):[noun:var, xor:t.ac], (sGen):[noun:var, xor:t.ab],
                (instr):[noun:var.lightVar, xor:t.bd, head:var], (gen):[noun:var.lightVar, xor:t.cd, head:var])
      case 'по':
        return state.apply((preposition):[prep:'по'], (poDat):[noun:var], (dat):[noun:var.lightVar, head:var])
      case 'о': return state.apply((preposition):[prep:'о'], (oPrep):[noun:var], (prep):[noun:var.lightVar, head:var])
      case 'к': return state.apply((preposition):[prep:'к'], (kDat):[noun:var], (dat):[noun:var.lightVar, head:var])
      case 'у': return state.apply((preposition):[prep:'у'], (uGen):[noun:var], (gen):[noun:var.lightVar, head:var])
      case 'до':
        return state.apply((preposition):[prep:'до'], (doGen):[noun:var], (gen):[noun:var.lightVar, head:var])
      case 'от':
        return state.apply((preposition):[prep:'от'], (otGen):[noun:var], (gen):[noun:var.lightVar, head:var])
      case 'в':
        return state.apply((preposition):[prep:'в'],
                (vAcc):[noun:var, xor:t.ac], (vPrep):[noun:var, xor:t.ab],
                (acc):[noun:var.lightVar, xor:t.bd, head:var], (prep):[noun:var.lightVar, xor:t.cd, head:var])
      case 'из':
      case 'изо': return state.apply((preposition):[prep:'из'], (izGen):[noun:var], (gen):[noun:var.lightVar, head:var])
      case 'на': return state.apply((preposition):[prep:'на'], (naPrep):[noun:var], (prep):[noun:var.lightVar, head:var])
      case "мной":
        return noun(state, instr, 'ME')
      case "меня": return noun(state, gen, 'ME')
      case ":":
        Variable newVerb = new Variable()
        return state.apply(verbHolder(mustFinish:true, head:var.lightVar), sentenceHolder(mustStart:true, head:newVerb.lightVar),
                directSpeech(xor:t.a, message:newVerb), elaboration(head:var, xor:t.a)).advanceSection()
      case "я": return pronoun(state, nom, 'ME')
      case "нас": return pronoun(state, acc, 'WE')
      case "мое": return state.apply((typeCxt('ME')):[var:var], (possessive):[possessor:var, xor:t.a])
      case "моему": return state.apply((typeCxt('ME')):[var:var], (possessive):[possessor:var])
      case "нашего": return state.apply((typeCxt('WE')):[var:var], (possessive):[possessor:var])
      case "и": return state.apply((seq):[conj:'and'])
      case "или": return state.apply((seq):[conj:'or'])
      case "а":
      case "но":
        return state.apply((seq):[conj:'but'],
                (clauseEllipsis):[prevHistory:state],
                (verbEmphasis):[emphasis:word == 'а' ? 'andEmphasis' : 'butEmphasis', verb:var],
                (sentenceHolder):[head:var.lightVar])
      case "тут":
        return state.assign(var.lightVar, 'emphasis', 'true').apply((verbHolder):[head:var.lightVar])
      case "все":
        return state.apply((nom):[noun:v[nom].lightVar], (varCxt(quantifier:'ALL')):[var:v[nom]])
      case "дальше":
        return state.apply((comeScalarly):[order:'AFTER', xor: t.ab], (typeCxt('NEXT')):[var:var, xor:t.b], (advObj):[adv:var, xor:t.a])
      case "их":
        return state.apply((typeCxt('THEY')):[var:var], (possessive):[possessor:var, xor:t.a], (acc):[noun:var, xor:t.a])
      case "его":
        return state.apply((typeCxt('HE')):[var:var], (possessive):[possessor:var, xor:t.a], (acc):[noun:var, xor:t.a])
      case "он": return pronoun(state, nom, 'HE')
      case "она": return pronoun(state, nom, 'SHE')
      case "они": return pronoun(state, nom, 'THEY')
      case "соседям": return noun(state, dat, 'NEIGHBOURS')
      case "арбуз": return noun(state, nom, 'WATER_MELON')
      case "кассиршу": return noun(state, acc, 'CASHIER')
      case "деревья": return noun(state, acc, 'TREES')
      case "деньги": return noun(state, acc, 'MONEY')
      case "ее":
      case "её":
        return state.apply((typeCxt('SHE')):[var:var], (possessive):[possessor:var], (acc):[noun:var])
      case "носом": return noun(state, instr, 'NOSE')
      case "пальцев": return noun(state, gen, 'FINGERS')
      case "пальца": return noun(state, gen, 'FINGERS')
      case "палец": return noun(state, acc, 'FINGER')
      case "челюсти":
        return state.apply((gen):[noun:var, xor:t.ab], (acc):[noun:var, xor:t.a], (typeCxt('JAWS')):[var:var])
      case "челюстью": return noun(state, instr, 'JAW')
      case "челюсть":
        return state.apply((acc):[noun:var], (typeCxt('JAW')):[var:var])
      case "семь": return numeral(state, t, '7')
      case "семи": return noun(state, gen, '7')
      case "восемь": return numeral(state, t, '8')
      case "восьми":
        return noun(state, gen, '8')
      case "два": return numeral(state, t, '2')
      case "три": return numeral(state, t, '3')
      case "один": return numeral(state, t, '1')
      case "порядок":
        return state.apply((typeCxt('ORDER')):[var:var], (acc):[noun:var], (gen):[noun:v[gen].lightVar, head:var], (genCriterion):[head:var, noun:v[gen]])
      case "счете": return noun(state, prep, 'COUNTING')
      case "работы":
        state = noun(state, gen, 'WORK')
        return state//.apply(absTime, noun:state[posleGen].noun)
      case "тоже":
        return state.apply((also):[hasAlso:true])
      case "не":
        return state.apply((negation):[:])
      case "помнят":
      case "помнит":
        return finiteVerb(state, var, 'REMEMBER', 'PRESENT',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom], xor:t.a],
                (varCxt(rusNumber:(word == "помнят" ? 'pl' : 'sg'), person:'3')):[var:v[nom]],
                (verbHolder):[head:var],
                (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc], xor:t.b])
      case "может":
      case "могут":
        return finiteVerb(state, var, 'CAN', 'PRESENT', (control):[subj:v[nom], head:var],
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]])
      case 'стали':
      case 'начали':
        return finiteVerb(state, var, 'BEGIN', 'PAST', (control):[head:var],
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]])
      case 'свалился':
        return finiteVerb(state, var, 'FALL', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var, agrNumber:'sg'], (nomSubject):[head:var, noun:v[nom]],
                (sGen):[head:var, noun:v[sGen].lightVar], (sGenSource):[head:var, noun:v[sGen]])
      case "отправился":
        return finiteVerb(state, var, 'GO_OFF', 'PAST',
                (kDat):[noun:v[kDat].lightVar, head:var], (kDatGoal):[head:var, noun:v[kDat]],
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]])
      case "пошли":
        return finiteVerb(state, var, 'GO', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (vAcc):[noun:v[vAcc].lightVar, head:var], (vAccGoal):[head:var, noun:v[vAcc]])
      case "спорили":
        return finiteVerb(state, var, 'ARGUE', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var, agrNumber:'pl'], (nomSubject):[head:var, noun:v[nom]])
      case "обнаружил":
      case "обнаружила":
      case "обнаружили":
        return finiteVerb(state, var, 'DISCOVER', 'PAST', (declOrQuestionComp):[head:var],
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]])
      case "улыбнулась":
        return finiteVerb(state, var, 'SMILE', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]])
      case "сказал":
      case "сказала":
        def datNoun = new Variable().lightVar
        return finiteVerb(state, var, 'SAY', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (dat):[noun:datNoun, head:var], (datAddressee):[head:var, noun:datNoun],
                (directSpeech):[head:var, xor:t.a], (declOrQuestionComp):[head:var, xor:t.a])
      case "вынул":
      case "вынула":
        return finiteVerb(state, var, 'TAKE_OUT', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]],
                (izGen):[noun:v[izGen].lightVar, head:var], (izGenSource):[noun:v[izGen], head:var])
      case "показались":
        return finiteVerb(state, var, 'SEEM', 'PAST',
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (dat):[noun:v[dat].lightVar, head:var], (participleArg):[head:var])
      case "дойдя":
        state = state.assign(var, 'type', 'COME_TO')
        return state.apply(
                (vPrep):[head:var, noun:v[vPrep].lightVar], (vPrepDomain):[head:var, noun:v[vPrep]],
                (doGen):[head:var, noun:v[doGen].lightVar], (doGenGoal):[head:var, noun:v[doGen]],
                (adverbialPhrase):[content:var])
      case "вдумываясь":
        state = state.assign(var, 'type', 'THINK')
        return state.apply((vAcc):[noun:v[vAcc].lightVar, head:var],
                (vAccTheme):[head:var, noun:v[vAcc]],
                (adverbialPhrase):[content:var])
      case "вспомнить":
        return infinitive(state, var, 'RECALL', (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]])
      case "делать":
        return infinitive(state, var, 'DO', (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]])
      case "спорить":
        return infinitive([:], state, var, 'ARGUE')
      case "считать":
        return infinitive(state, var, 'COUNT', (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]])
      case "поливать":
        return infinitive(state, var, 'TO_WATER', (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]])
      case "танцевать":
        return infinitive([:], state, var, 'DANCE')
      case "нужно":
        return state.assign(var, 'type', 'NEED').apply((acc):[head:var],
                (datArg1):[head:var, noun:v[dat]], (dat):[noun:v[dat].lightVar],
                (adverbPred):[adverb:var],
                (verbHolder):[head:var], (question):[content:var])
      case "спросить":
        return infinitive(state, var, 'ASK', (acc):[noun:v[acc].lightVar, head:var], (accArg2):[head:var, noun:v[acc]])
      case ",":
        Variable before = new Variable().lightVar
        Variable after = new Variable().lightVar
        return state.apply(
                comma(hasComma:true), seq(conj:',', xor:t.a),
                verbHolder(mustFinish:true, head:before), verbHolder(mustStart:true, head:after),
                reasonComp(hasComma:true, xor:t.a),
                declOrQuestionComp(hasComma:true, xor:t.a),
                adverbialPhrase(comma1:true, head:before, xor:t.a), adverbialPhrase(comma2:true, head:after, xor:t.a),
                poDatLuck(comma1:true, head:before, xor:t.a), poDatLuck(comma2:true, head:after, xor:t.a),
                accordingTo(comma1:true, head:before, xor:t.a), accordingTo(comma2:true, head:after, xor:t.a),
                clauseEllipsis(prevHistory:state)
        ).advanceSection()
      case "если":
        return state.apply((conditionComp):[wh:'if', comp:v[verbHolder]], (verbHolder):[head:v[verbHolder].lightVar])
      case "когда":
        return state.apply((conditionComp):[wh:'when', comp:v[verbHolder]], (verbHolder):[head:v[verbHolder].lightVar])
      case "это":
        return state.apply((nom):[noun:var, xor:t.a], (acc):[noun:var, xor:t.a], (typeCxt('THAT')):[var:var])
      case "что":
        def comp = new Variable()
        Update update = u(acc(noun:var, xor:t.a, wh:true), nom(noun:var, xor:t.a, wh:true))
        update = update + [
                (declOrQuestionComp):[comp:comp], (relativeClause):[wh:var, relative:v[verbHolder]],
                (verbHolder):[head:v[verbHolder].lightVar], (naPrep):[head:var, copula:v[verbHolder].lightVar],
                (typeCxt('wh')):[var:var, xor:t.f], (question):[questioned:var, frame:comp, xor:t.e], (modality):[questioned:var, xor:t.d], (complementizer):[xor:t.adef, frame:comp]]
        return update.apply(state)
      case "идет":
      case "идёт":
        state = state.assign(var, 'time', 'PRESENT')
        return state.apply((comeScalarly):[verb:var, xor:t.ab], (typeCxt('GO')):[var:var, xor:t.a],
                (vAcc):[noun:v[vAcc].lightVar, xor:t.b, head:var], (vAccGoal):[head:var, noun:v[vAcc]],
                (vPrep):[noun:v[vPrep].lightVar, head:var], (vPrepCondition):[head:var, noun:v[vPrep]],
                (nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (poDat):[head:var], (verbHolder): [head:var], (sentenceHolder): [head:var],
                (posleGen):[head:var], (ransheGen):[head:var],
                (conditionComp):[head:var], (absTime):[head:var],
                (complementizer):[content:var, xor:t.c], (question):[content:var, xor:t.c])
      case "следовало":
        state = state.assign(var, 'time', 'PAST')
        return state.apply((nom):[noun:v[nom].lightVar, head:var], (nomSubject):[head:var, noun:v[nom]],
                (comeScalarly):[verb:var],
                (posleGen):[head:var], (relTime):[head:var],
                (poDat):[head:var, noun:v[poDat].lightVar], (poDatOpinion):[head:var, noun:v[poDat]],
                (verbHolder):[head:var], (elaboration):[elaboration:var])
      case "раньше":
        return state.apply((comeScalarly):[order:'EARLIER', xor:t.a], (relTime):[relTime:'BEFORE', xor:t.a],
                (ransheGen):[noun:var], (gen):[noun:var.lightVar, head:var])
      case "-":
        state = state.advanceSection()
        return state.apply((directSpeech):[hasDash:true],
                (questionVariants):[hasDash:true],
                (clauseEllipsis):[interceptor:new EllipsisInterceptor(state)])
        return state
      case ".":
        return state.apply((dot):[head:var], (verbHolder):[head:var.lightVar, mustFinish:true]).advanceSection()
      case 'каково':
        return state.assign(var, 'type', 'wh').apply((shortAdj):[copula: v['copula'], value:var, noun:v[nom]],
                (nom):[noun:v[nom].lightVar, head:var],
                (conditionComp):[head:v['copula']])
      case 'бы':
        return state.apply((subjunctive):[subjunctive:true])
      case 'было':
        return state.apply((shortAdj):[time:'PAST', copula:var.lightVar], (timedModality):[time:'PAST'], (adverbPred):[time:'PAST'])
      case 'так':
        return state.apply((reasonComp):[reason:var], (verbHolder):[head:var.lightVar])
      case 'обе':
        def num = new Variable()
        return state.assign(num, 'type', 'BOTH').apply((acc):[noun:var],
                (numQuantifier):[num:num, prev:state, noun:var.lightVar, innerCase:gen, outerNoun:var])
      case 'по-моему':
        def me = new Variable()
        return state.assign(var, 'type', 'OPINION').assign(var, 'arg1', me).assign(me, 'type', 'ME').
                apply((accordingTo):[content:var])
      case '?': return state.apply((question):[:])
      case '"':
        return state.apply((quote):[:])
      case 'лишенными':
        state = state.assign(var, 'type', 'LACK')
        return state.apply((participleArg):[participle:var],
                (gen):[noun:v[gen].lightVar, head:var], (genArg2):[head:var, noun:v[gen]])
      case 'бессмысленными':
        state = state.assign(var, 'type', 'MEANINGLESS')
        return state.apply((participleArg):[participle:var])
    }
    return state
  }

  Update parseUpdate(String word) {
    Variable var = new Variable()
    switch (word) {
      case "васи":
        return unoun(gen, var, null) + uv(var, name:'Вася')
      case "знаменской": // todo a unified treatment for street names
      case "бассейной":
        return commonCase(gen, var.lightVar) + uv(var, type:'STREET') + u(adjective(nounFrame:var, rel:'name', val:word[0..-3]+"ая"))
      case 'себе':
        return upronoun(dat, var, null) + u(reflexiveHolder(noun:var.lightVar))
      case 'мне':
        return upronoun(dat, var, 'ME')
      case "мы": return upronoun(nom, var, 'WE')
      case "нам": return upronoun(dat, var, 'WE')
      case '6-ти':
      case 'шести':
        return unoun(gen, var, '6')
      case '5-ти':
        return unoun(gen, var, '5')
      case "магазин":
        return uv(var, type:'SHOP') + u(nom(noun:var)).xor(acc(noun:var)) + u(naPrep(head:var), quotedName(noun:var), relativeClause(noun:var))
      case "счета": return unoun(gen, var, 'COUNTING')
      case "вдруг": return uadv('manner', 'SUDDENLY')
      case "опять": return uadv('anchor', 'AGAIN')
      case "слегка": return uadv('manner', 'SLIGHTLY')
      case "долго": return uadv('duration', 'LONG')
      case "грустно": return uadv('manner', 'SADLY')
      case "просто": return uadv('manner', 'JUST')
      case "случае": return unoun(prep, var, 'CASE', (conditionComp):[head:var])
      case "удивление": return unoun(nom, var, 'AMAZE') + uposs(var, possArg1)
      case "недоумении": return unoun(prep, var, 'PREDICAMENT') + uposs(var, possArg1)
      case "спора": return unoun(gen, var, 'ARGUE') + uposs(var, possArg1)
      case "смысла": return unoun(gen, var, 'MEANING')
      case "углу":
        return unoun(prep, var, 'CORNER') + uarg(var, gen, genArg1)
      case "кассир": return unoun(nom, var, null) + uv(var, type:'CASHIER', gender:'masc')
      case "кассирша": return unoun(nom, var, null) + uv(var, type:'CASHIER', gender:'fem')
      case "кассирши": return unoun(gen, var, 'CASHIER')
      case "одних": return unoun(gen, var, 'SOME')
      case "других": return unoun(gen, var, 'OTHERS')
      case "мнению":
        return unoun(dat, var, 'OPINION') +
               uarg(var, gen, genArg1).xor(uposs(var, possAuthor))
      case "словам":
        return unoun(dat, var, 'WORDS') +
               uarg(var, gen, genArg1).xor(uposs(var, possAuthor))
      case "слова":
        return uv(var, type:'WORDS') + unoun(acc, var, null).xor(unoun(nom, var, null)) +
               uarg(var, gen, genAuthor) + uposs(var, possAuthor)
      case "счастию":
        return unoun(dat, var, 'LUCK') + u(RussianConstructions.word(word:word))
      case "потом":
        return u(comeScalarly(order:'AFTER')).xor(relTime(relTime:'AFTER'))
      case "домам": return unoun(dat, var, 'HOMES') + uposs(var, possOwner)
      case "комнатам": return unoun(dat, var, 'ROOMS') + uposs(var, possOwner)
      case "квартирам": return unoun(dat, var, 'APARTMENTS') + uposs(var, possOwner)
      case "офисам": return unoun(dat, var, 'OFFICES') + uposs(var, possOwner)
      case 'был':
        def subj = new Variable().lightVar
        return uv(var, time:'PAST') +
               u(naPrep(head:subj, copula:var), verbHolder(head:var), uGen(head:subj, copula:var), nom(noun:subj, head:var))
      case 'есть':
        def subj = new Variable().lightVar
        return uv(var, time:'PRESENT') +
               u(naPrep(head:subj, copula:var), verbHolder(head:var), uGen(head:subj, copula:var), nom(noun:subj, head:var))
      case "после":
        Variable noun = new Variable()
        return u(comeScalarly(order:'AFTER'), posleGen(noun:noun)).xor(absTime(rel:'AFTER', noun:noun)) + u(gen(noun:noun.lightVar, head:var))
    }
    return null
  }

  Update uadv(String rel, String adv) {
    return u(adverb(adv:adv, attr:rel, head:new Variable().lightVar))
  }
  
  Update uposs(Variable head, Construction sem) {
    Variable arg = new Variable()
    u(possessive(possessor:arg.lightVar), sem(head:head, possessor:arg))
  }
  static Update uarg(Variable head, Variable arg = new Variable(), Construction syn, Construction... sem) {
    def tokens = new Tokens()
    List<Mite> mites = [syn(noun:arg.lightVar, head:head)]
    for (cxt in sem) {
      mites << cxt(head:head, noun:arg, xor:tokens.a)
    }
    new Update(mites)
  }

  ParsingState adj(ParsingState state, Construction caze, String rel, String val) {
    def noun = new Variable().lightVar
    return state.apply((adjective):[nounFrame:noun, rel:rel, val:val], (caze):[noun:noun])
  }

  ParsingState numeral(ParsingState state, Tokens t, String number) {
    def noun = new Variable()
    def num = new Variable()
    return state.apply((nom):[noun:noun, xor:t.a], (acc):[noun:noun, xor:t.a],
                    (typeCxt(number)):[xor:t.bd, var:noun],
                    (numQuantifier):[num:num, xor:t.b, noun:noun.lightVar, outerNoun:noun,
                            prev:state, innerCase:(number == '1' ? acc : gen)],
                    (typeCxt(number)):[xor:t.d, var:num]
    )
  }

  private Construction numberTypeCxt(Variable var, String word) {
    return cxt("sem_number_${var}_$word") { ParsingState st, Map args -> st.assign(args.var, 'type', word).assign(args.var, 'number', 'true') }
  }

  private ParsingState infinitive(Map<Construction, Map> args, ParsingState state, Variable verb, String type) {
    def mod = new Variable()
    def datNoun = new Variable().lightVar
    return state.assign(verb, 'type', type).apply(args +
            [(dat):[noun:datNoun], (datArg1):[head:verb, noun:datNoun], (control): [slave: verb],
                    (question): [content:mod], (modality):[modality:mod, infinitive:verb], (timedModality):[modality:mod],
                    (verbHolder):[head:verb]])
  }

  private ParsingState finiteVerb(Map<Construction, Map> args, ParsingState state, Variable verb, String type, String tense) {
    return Verbs.ufiniteVerb(args, verb, type, tense).apply(state)
  }

  private ParsingState noun(ParsingState state, Construction caze, String type) {
    Variable noun = new Variable()
    return unoun(caze, noun, null, (typeCxt(type)):[var:noun]).apply(state)
  }

  private Update unoun(Map<Construction, Map> mites = [:], Construction caze, Variable noun, String type) {
    def update = upronoun(mites, caze, noun, type)
    update + [(quotedName):[noun:noun], (numQuantifier):[noun:noun]]
  }
  private Update upronoun(Map<Construction, Map> mites = [:], Construction caze, Variable var, String type) {
    Update update = u()
    if (type) {
      update = update.addCxt(typeCxt(type), var:var)
    }
    return update + mites + commonCase(caze, var)
  }

  private Update commonCase(Construction caze, Variable var) {
    u(caze(noun:var, xor:new Tokens().a))
  }

  private ParsingState pronoun(ParsingState state, Construction caze, String type) {
    return upronoun(caze, new Variable(), type).apply(state)
  }

  private Construction typeCxt(String type) {
    return varCxt(type:type)
  }

  static Update uv(Map<String, String> attrs, Variable var) {
    Construction cxt = varCxt(attrs)
    return u(cxt(var:var))
  }

  static Construction varCxt(Map<String, String> attrs) {
    return cxt("var_${attrs.collect { k, v -> k + "_" + v}.join("_")}") { st, a ->
      for (attr in attrs.keySet()) {
        st = st.assign(a.var, attr, attrs[attr])
      }
      st
    }
  }

  static Update u(Mite... mites) { new Update(mites) }

}