package cons3

/**
 * @author peter
 */
class Parser {

  Chart parse(String text) {
    def chart = new Chart()
    ParsingState state = [chart.newSituation()]
    def tokenizer = new StringTokenizer(text, """ '":,.""", true)
    for (String w in tokenizer) {
      if (w != ' ') {
        state = handleWord(w, state)
      }
    }
    return chart
  }

  static class ParsingState {
    final Situation situation
    final Frame lastFrame
    private Map<String, Frame> participants = [:]

    ParsingState(Situation situation) {
      this(situation, null, [:])
    }

    private ParsingState(Situation situation, Frame lastFrame, Map<String, Frame> participants) {
      this.lastFrame = lastFrame
      this.situation = situation
      this.participants = participants
    }

    ParsingState withFrame(Frame frame) {
      assert frame
      [situation, frame, participants]
    }

    ParsingState withSituation(Situation situation) {
      [situation, null, [:]]
    }

    ParsingState withRole(String key, Frame frame = null) {
      if (!frame) {
        frame = getAt(key) ?: situation.newFrame()
      }
      [situation, frame, participants + [(key): frame]]
    }

    Frame getAt(String key) {
      participants[key]
    }

  }

  ParsingState handleWord(String word, ParsingState state) {
    def situation = state.situation
    switch (word) {
      case "Удивительный":
        return adj(state, "property", "AMAZING", true, 'nom')
      case "этому":
        def verb = state.lastFrame
        state = adj(state, 'determiner', 'THIS', false, 'dat')
        situation.assign(verb, "topic", state.lastFrame, false)
        return state
      case "случай":
        return noun(state, 'nom', "THING", true)
      case "поводу":
        return noun(state, 'dat', "MATTER", false)
      case "случился":
        def verb = situation.newFrame()
        situation.assign(verb, "type", "HAPPEN", true)
        situation.assign(situation, "time", "PAST", false)
        situation.assign(verb, "theme", state.lastFrame, true)
        return state.withFrame(verb)
      case "со":
        return state
      case "мной":
        def verb = state.lastFrame
        state = noun(state, 'instr', 'ME', false)
        situation.assign(verb, "experiencer", state.lastFrame, true)
        return state
      case ":":
        def elaboration = situation.chart.newSituation()
        situation.assign(situation, 'elaboration', elaboration, true)
        return state.withSituation(elaboration)
      case "я":
      case "Я":
        return noun(state, 'nom', 'ME', false)
      case "их":
        def verb = state.lastFrame
        state = noun(state, 'acc', 'THEY', false)
        situation.assign(verb, "addressee", state.lastFrame, true)
        return state
      case "они":
        return noun(state, 'nom', 'THEY', false)
      case "соседям":
        def verb = state.lastFrame
        state = noun(state, 'dat', 'NEIGHBOURS', false)
        situation.assign(verb, 'goal', state.lastFrame, true)
        return state
      case "вдруг":
        def verb = situation.newFrame()
        situation.assign(verb, "manner", "SUDDENLY", true)
        situation.assign(verb, "experiencer", state.lastFrame, true)
        return state.withFrame(verb)
      case "забыл":
        def verb = state.lastFrame
        situation.assign(verb, "type", "FORGET", true)
        situation.assign(situation, "time", "PAST", false)
        return state.withFrame(verb)
      case "отправился":
        def verb = situation.newFrame()
        situation.assign(verb, "type", "GO_OFF", true)
        situation.assign(situation, "time", "PAST", false)
        situation.assign(verb, "agent", state.lastFrame, true)
        return state.withFrame(verb)
      case "думают":
        def verb = situation.newFrame()
        situation.assign(verb, "type", "THINK", false)
        situation.assign(situation, "time", "PRESENT", false)
        situation.assign(verb, "experiencer", state.lastFrame, false)
        situation.assign(verb, "opinion", state['acc'], false)
        return state.withFrame(verb)
      case "спросил":
        def verb = situation.newFrame()
        situation.assign(verb, "type", "ASK", true)
        situation.assign(verb, "agent", state['nom'], true)
        return state.withFrame(verb)
      case ",":
        def question = situation.chart.newSituation()
        def verb = situation.frames.find { it.type in ['FORGET', 'ASK'] }
        def role = verb.type == 'FORGET' ? 'theme' : 'question'
        situation.assign(verb, role, question, true)
        return state.withSituation(question)
      case "что":
        state = state.withRole('nom')
        situation.assign(situation, "questioned", state.lastFrame, true)
        return state.withRole('questioned', state.lastFrame)
      case "идет":
        def verb = situation.newFrame()
        situation.assign(verb, "type", "COME_SCALARLY", false)
        situation.assign(situation, "time", "PRESENT", false)
        situation.assign(verb, "theme", state.lastFrame, false)
        return state.withFrame(verb)
      case "раньше":
        situation.assign(state.lastFrame, 'order', 'EARLIER', false)
        return state
      case "-":
        return state.withFrame(state['nom'])
      case "7":
      case "8":
        situation.assign(state.lastFrame, 'variant', word, false)
        return state
    }
    return state
  }

  private ParsingState noun(ParsingState state, String caze, String type, boolean rheme) {
    def existing = state[caze]
    if (existing && (existing.s('type') || existing == state['questioned'])) {
      state = state.withRole('acc', existing).withRole(caze, state.situation.newFrame())
    } else {
      state = state.withRole(caze)
    }

    state.situation.assign(state.lastFrame, "type", type, rheme)
    return state
  }

  private ParsingState adj(ParsingState state, String attr, String value, boolean rheme, String caze) {
    state = state.withRole(caze)
    state.situation.assign(state.lastFrame, attr, value, rheme)
    return state
  }

}