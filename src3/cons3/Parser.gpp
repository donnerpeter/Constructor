package cons3

/**
 * @author peter
 */
class Parser {
  String log = ""

  Chart parse(String text) {
    ParsingState state = new ParsingState(chart: new Chart(), situation: new Situation(), constructions:FLinkedMap.emptyMap, history:FList.emptyList)
    def tokenizer = new StringTokenizer(text, """ '":,.?!""", true)
    for (String w in tokenizer) {
      if (w != ' ') {
        state = handleWord(w.toLowerCase(), state)
        log += w + "\n"
        for (k in state.constructions.keySet()) {
          log += "  $k -> ${state.constructions[k]}\n"
        }
      }
    }
    return state.chart
  }

  Construction cxt(String name, Function2<ParsingState, Map, ParsingState> cl) {
    new Construction(name, cl)
  }

  private static ParsingState handleCase(Construction caze, ParsingState state, Map args) {
    if (args.save && args.hasNoun) {
      return state.satisfied(caze).restore((FLinkedMap)args.save).apply((Construction)args.delegate, noun: args.noun)
    }
    return state
  }

  Construction adjective = cxt('adjective') { ParsingState state, Map args -> state.assign(args.nounFrame, (String)args.rel, args.val) }
  Construction nom = cxt('nom') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'arg1', args.noun)
    }
    return state
  }
  Construction acc = cxt('acc') { ParsingState state, Map args ->
    def hdType = ((Variable) args.head)?.frame(state.chart)?.type
    if (hdType && args.noun) {
      state = state.assign(args.head, 'arg2', args.noun)
    }
    return handleCase(acc, state, args)
  }
  Construction gen = cxt('gen') { ParsingState state, Map args ->
    def type = ((Variable) args.head)?.frame(state.chart)?.type
    if (type && args.noun) {
      if (((Variable) args.head)?.frame(state.chart)?.type == 'BOTH') {
        state = state.assign(args.noun, 'quantifier', args.head)
      } else {
        state = state.assign(args.head,
                             type == 'LACK' ? 'arg2' :
                               'arg1', args.noun)

      }
    }
    return handleCase(gen, state, args)
  }
  Construction instr = cxt('instr') { ParsingState state, Map args ->
    if (((Variable) args.head)?.frame(state.chart)?.type && args.noun) {
      state = state.assign(args.head, 'arg2', args.noun)
    }
    handleCase(instr, state, args)
  }
  Construction dat = cxt('dat') { ParsingState state, Map args ->
    if (args.head && args.noun && args.infinitive) {
      state = state.assign(args.head, 'arg1', args.noun)
    }
    state
  }
  Construction prep = cxt('prep') { ParsingState state, Map args -> handleCase(prep, state, args) }
  Construction sInstr = cxt('sInstr') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if ( ((Variable) args.noun).frame(state.chart)?.type in ['JOY', 'RELIEF']) {
        state = state.assign(args.head, 'mood', args.noun)
      } else {
        state = state.assign(args.head, 'experiencer', args.noun)
      }
    }

    return state
  }
  Construction sGen = cxt('sGen') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'source', args.noun)
    }

    return state
  }
  Construction poDat = cxt('poDat') { ParsingState state, Map args ->
    Variable lastNoun = args.noun
    def member = lastNoun?.frame(state.chart)?.f('member')
    if (member) {
      lastNoun = member.var
    }
    def nType = lastNoun?.frame(state.chart)?.type
    if (nType) {
      if (nType in ['OPINION', 'WORDS']) {
        state = state.assign(state.situation, 'opinion_of', args.noun)
      } else if (args.head) {
        if (nType == 'LUCK') {
          state = state.assign(args.noun, 'topic', args.head)
        } else {
          state = state.assign(args.head, 'topic', args.noun)
        }
      }
    }

    return state
  }
  Construction oPrep = cxt('oPrep') { ParsingState state, Map args ->
    args.noun ? state.assign(args.head, 'topic', args.noun) : state
  }
  Construction nounGen = cxt('nounGen') { ParsingState state, Map args -> //todo nounGen -> gen
    if (args.noun && args.head) {
      Frame head = ((Variable) args.head).frame(state.chart)
      List<Variable> heads = head.flatten().collect {it.var}
      int i = 0
      for (h in heads) {
        def hf = h.frame(state.chart)
        def hType = hf.type
        def attr = hType == 'WORDS' ? 'author' : hType == 'OPINION' ? 'arg1' : 'criterion'
        if (i == heads.size() - 1 || !hf.f(attr)) {
          state = state.assign(h, attr, args.noun)
        }
        i++
      }
    }
    return state
  }
  Construction kDat = cxt('kDat') { ParsingState state, Map args ->
    args.noun && args.head ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction dativePart = cxt('dativePart') { state, args ->
    args.dat && args.head && args.acc ? state.assign(args.acc, 'arg1', args.dat) : state
  }
  Construction prevHistory = cxt('prevHistory') { ParsingState state, Map args ->
    return state
  }
  Construction clauseEllipsis = cxt('clauseEllipsis') { ParsingState state, Map args ->
    return state
  }
  Construction question = cxt('question') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head) {
      Situation next = args.comp ?: new Situation()
      state = state.assign(args.head, ((Variable) args.head).frame(state.chart).type == 'FORGET' ? 'theme' : 'question', next).withSituation(next).apply(question, comp:next)
    }
    if (args.questioned && args.comp) {
      if (args.imperative) {
        state = state.assign(state.situation, 'imperative', 'true')
      }
      state = state.assign(args.comp, 'questioned', args.questioned)
    }
    return state
  }
  Construction comeScalarly = cxt('comeScalarly') { ParsingState state, Map args ->
    args.verb && args.order ? state.assign(args.verb, 'type', 'COME_SCALARLY').assign(args.verb, 'order', args.order) : state
  }
  Construction questionVariants = cxt('questionVariants') { ParsingState state, Map args ->
    args.seq && args.questioned ? state.assign(args.questioned, 'variants', args.seq).satisfied(questionVariants) : state
  }
  Construction shortAdjCopula = cxt('shortAdjCopula') { ParsingState state, Map args ->
    if (args.noun && args.pred) {
      state = state.assign(args.noun, 'degree', args.pred)
    }
    return state
  }
  Construction parenthetical = cxt('parenthetical') { ParsingState state, Map args ->
    return state
  }
  Construction preposition = cxt('preposition') { ParsingState state, Map args ->
    return state
  }
  Construction possessive = cxt('possessive') { ParsingState state, Map args ->
    if (args.possessor) {
      def type = ((Variable) args.head)?.frame(state.chart)?.type
      if (type) {
        state = state.assign(args.head, type in ['AMAZE', 'PREDICAMENT', 'OPINION'] ? 'arg1' : 'author', args.possessor)
      }
    }
    return state
  }
  Construction control = cxt('control') { ParsingState state, Map args ->
    return args.head && args.slave ? state.assign(args.head, 'theme', args.slave) : state
  }
  Construction declComp = cxt('declComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.complementizer) {
      def next = new Situation()
      state = state.assign(args.head, 'theme', next).withSituation(next).apply(declComp, comp:next)
    }
    return state
  }
  Construction conditionComp = cxt('conditionComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.wh) {
      def next = new Situation()
      state = state.assign(args.head, "${args.wh}Condition", next).withSituation(next).apply(conditionComp, comp:next)
    }
    return state
  }
  Construction reasonComp = cxt('reasonComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.active) {
      def next = new Situation()
      state = state.assign(args.head, "reason", next).withSituation(next)
    }
    return state
  }
  Construction numQuantifier = cxt('numQuantifier') { ParsingState state, Map args ->
    if (args.noun && !args.num) {
      return state.satisfied(numQuantifier) //todo inverted quantification
    }

    return args.num && args.noun ? state.assign(args.noun, 'quantifier', args.num) : state
  }
  Construction negation = cxt('negation') { ParsingState state, Map args ->
    return state
  }
  Construction also = cxt('also') { ParsingState state, Map args ->
    return state
  }
  Construction vAcc = cxt('vAcc') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, ((Variable) args.head).frame(state.chart).type == 'THINK' ? 'theme' : 'goal', args.noun)
      //todo apply everything on every change
      if (state[nom]) {
        state = state.apply(nom)
      }
      if (state[posleGen]) {
        state = state.apply(posleGen)
      }
    }
    state
  }
  Construction vPrep = cxt('vPrep') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if (((Variable) args.head).frame(state.chart).type == 'COME_TO') {
        state = state.assign(args.head, 'domain', args.noun)
      } else {
        state = state.assign(state.situation, 'condition', args.noun)
      }
    }
    state
  }
  Construction posleGen = cxt('posleGen') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return handleCase(gen, state, args)
  }
  Construction ransheGen = cxt('ransheGen') { ParsingState state, Map args ->
    def type = ((Variable) args.head)?.frame(state.chart)?.type
    if (type && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return handleCase(gen, state, args)
  }
  Construction naPrep = cxt('naPrep') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'location', args.noun) : state
  }
  Construction izGen = cxt('izGen') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'source', args.noun) : state
  }
  Construction doGen = cxt('doGen') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction participleArg = cxt('participleArg') { ParsingState state, Map args ->
    args.head && args.participle ? state.assign(args.head, 'theme', args.participle) : state
  }
  Construction seq = cxt('seq') { ParsingState state, Map args ->
    return state
  }
  Construction advObj = cxt('advObj') { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, 'arg2', args.adv)
    }
    return state
  }
  Construction relTime = cxt('relTime') { ParsingState state, Map args ->
    if (args.head && args.relTime) {
      state = state.assign(args.head, 'relTime', args.relTime)
    }
    return state
  }
  Construction absTime = cxt('absTime') { ParsingState state, Map args ->
    if (args.head && args.rel && args.noun) {
      state = state.assign(args.head, 'relTime_after', args.noun)
    }
    return state
  }
  Construction adverb = cxt('adverb') { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, args.adv == 'LONG' ? 'duration' : 'manner', args.adv)
    }
    return state
  }
  Construction quotedName = cxt('quotedName') { ParsingState state, Map args ->
    if (args.finished) {
      state = state.assign(args.noun, 'name', args.name).satisfied(quotedName)
    }
    return state
  }
  Construction relativeClause = cxt('relativeClause') { ParsingState state, Map args ->
    if (args.noun && args.hasComma && args.wh) {
      def next = new Situation()
      return state.assign(args.noun, 'relative', next).withSituation(next).assign(next, 'wh', args.wh).apply(nestedClause, save: args.save, parent:args.parentSituation)
    }
    return state
  }
  Construction nestedClause = cxt('nestedClause') { ParsingState state, Map args ->
    return state
  }
  Construction directSpeech = cxt('directSpeech') { ParsingState state, Map args ->
    if (args.head && args.hasColon) {
      def message = new Situation()
      state = state.assign(args.head, 'message', message).withSituation(message)
    }

    return state
  }
  Construction summerGarden = cxt('summerGarden') { ParsingState state, Map args ->
    if (args.summer && args.garden) {
      state = state.assign(args.garden, 'name', 'Летний сад')
    }
    return state
  }

  private Update merge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, Update update, Map<Pair<Variable, Variable>, Variable> seqs) {
    if (cxt in [nom, acc, gen, poDat, nounGen] && oldArgs.noun && newArgs.noun) {
      return doMerge(state, cxt, oldArgs, newArgs, 'noun', update, seqs)
    }
    if (cxt in [nom] && oldArgs.head && newArgs.head && !newArgs.noun && state[cxt]?.head) {
      return update.addCxt((state[cxt] ?: oldArgs) + [head:newArgs.head], cxt, (Closure)newArgs.init)
    }
    if (cxt in [nounGen] && oldArgs.head && newArgs.head && !newArgs.noun) {
      return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs)
    }
    if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
      return doMerge(state, cxt, oldArgs, newArgs, 'possessor', update, seqs)
    }

    return update.addCxt(newArgs, cxt)
  }

  Construction seqStart = this.cxt('seqStart') { ParsingState st, Map args ->
    st = st.assign(args.multi, 'member', args.first)
    if (args.conj) {
      st = st.assign(args.multi, 'conj', args.conj)
    }
    if (args.distinguish) {
      st = st.assign(args.second, 'distinguished_in', args.multi)
    }
    st.assign(args.multi, 'member', args.second).satisfied(seqStart)
  }

  private Update doMerge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, String prop, Update update, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldArgs[prop]
    if (first.frame(state.chart).f('member')) {
      return joinSeq(newArgs, state, cxt, first, oldArgs, prop, update)
    }

    def second = newArgs[prop]
    Variable multi = seqs[new Pair(first, second)] ?: new Variable()
    seqs[new Pair(first, second)] = multi
    return update.
            addCxt(seqStart, multi:multi, first:first, second:second, conj:state[seq].conj, distinguish:state[cxt]?.repeated).
            addCxt(oldArgs + [(prop): multi, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt, ParsingState.mergeInits((Closure)oldArgs.init, (Closure)newArgs.init))
  }

  Construction seqNext = this.cxt('seqNext') { ParsingState st, Map args ->
    if (args.conj) {
      st = st.assign(args.multi, 'conj', args.conj)
    }
    st.assign(args.multi, 'member', args.next).satisfied(seqNext)
  }

  Update joinSeq(Map newArgs, ParsingState state, Construction cxt, Variable seqVar, Map oldArgs, String property, Update update) {
    def newMember = newArgs[property]
    return update.
            addCxt(oldArgs + [(property): seqVar, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt, ParsingState.mergeInits((Closure)oldArgs.init, (Closure)newArgs.init)).
            addCxt(seqNext, multi:seqVar, next:newMember, conj:state[seq]?.conj)
  }

  ParsingState conjWrap(Map<Construction, Map> constructions, ParsingState state) {
    Update update = new Update(FLinkedMap.emptyMap)
    if (state[seq]) {
      List<Contribution> history = ((ParsingState) state[seq].save).history
      //todo a wiser conj limit
      def limit = history.reverse().findIndexOf { Contribution it -> it.before.situation == state.situation }
      if (limit > 0) {
        history = history.subList(0, history.size() - limit)
      }
      def similar = history.findIndexOf { Contribution it -> areSimilar(it.apps, constructions) }
      if (similar >= 0) {
        def prev = history[similar].apps
        def seqs = [:]
        for (cxt in constructions.keySet()) {
          if (cxt in prev) {
            update = merge(state, cxt, prev[cxt], constructions[cxt], update, seqs)
          } else {
            update = update.addCxt(constructions[cxt], cxt)
          }
        }

        def modernHistory = state.history
        state = state.clearConstructions().restore(history[similar].before.constructions)

        def lastConj = modernHistory.findIndexOf { Contribution it -> it.apps[seq] != null }
        if (lastConj) {
          for (contribution in modernHistory.subList(0, lastConj).reverse()) {
            state = state.apply(contribution.apps)
          }
        }
        return state.apply(update.map)
      }
    }
    for (cxt in constructions.keySet()) {
      update = update.addCxt(constructions[cxt], cxt)
    }
    if (state[clauseEllipsis]) {
      Map<Variable, Variable> mapping = state[clauseEllipsis].mapping
      List<Contribution> prevConstructions = state[clauseEllipsis].remaining
      def index = prevConstructions.findIndexOf { Contribution it -> areSimilar(it.apps, update.map) }
      if (index >= 0) {
        state = state.satisfied(clauseEllipsis)
        prevConstructions.each { Contribution oldContribution ->
          oldContribution.apps.each { cxt, upd ->
            upd.each { k, v ->
              if (v instanceof Variable) {
                def nv = update.map[cxt]?.get(k) ?: mapping.get(v)
                if (!nv) {
                  nv = new Variable()
                }
                mapping[v] = nv
              }
            }
          }
        }

        def ellipsis = new Variable()
        state = state.assign(ellipsis, 'type', 'ellipsis').startMeta(ellipsis)

        for (i in 0..<prevConstructions.size()) {
          if (i == index) continue

          Contribution oldContribution = prevConstructions[i]
          FLinkedMap newContribution = FLinkedMap.emptyMap
          for (cxt in oldContribution.apps.keySet()) {
            def newArgs = [:]
            oldContribution.apps[cxt].each { k, v ->
              newArgs[k] = v instanceof Variable ? mapping[(Variable) v] : v
            }
            newContribution = newContribution.prepend(cxt, newArgs)
          }
          state = state.apply(newContribution.reverse())
        }

        state = state.finishMeta(ellipsis)
      }
    }
    return state.apply(update.map)
  }


  ParsingState handleWord(String word, ParsingState state) {
    Tokens t = new Tokens()
    if (Util.parseNumber(word) != null) { //todo generic noun treatment for numbers
      def noun = !state[doGen]?.hasNoun && state[doGen]?.noun ? state[doGen].noun : state.newVariable()
      def num = new Variable()

      def sem = cxt("sem_$word") { ParsingState st, Map args -> st.assign(args.var, 'type', word).assign(args.var, 'number', 'true') }


      List<Construction> cases = []
      if (!(state[preposition]?.prep in ['posle', 'ranshe', 'до'])) {
        cases << nom
      }
      if (state[preposition]?.prep == 'posle') {
        cases << posleGen
      } else if (state[preposition]?.prep == 'ranshe') {
        cases << ransheGen
      } else if (state[preposition]?.prep == 'до') {
        cases << doGen
      } else {
        cases << gen
      }
      cases << acc

      def qv = state[questionVariants]
      if (qv) {
        def seqVar = state.newVariable()
        state = state.apply((questionVariants):[seq:seqVar], (nom):[:])
        def update = new Update((sem):[var:noun])
        for (caze in cases) {
          update = joinSeq(state, caze, seqVar, noun: noun, [hasNoun: true, xor: t.a], 'noun', update)
        }
        state = state.apply(update.map)
      } else {
        state = conjWrap(cases.collectEntries { [it, [noun:noun, hasNoun:true, xor:t.a]] } +
                                 [(sem):[var:noun, xor:t.bd]] +
                                 [(numQuantifier):[num: num, xor:t.b],
                                         (typeCxt(num, word)):[xor:t.d, var:num]],
                         state)
      }

      return state
    }

    if (state[quotedName]?.started && !state[quotedName].name) {
      state = state.apply(quotedName, name:word)
    }

    def situation = state.situation
    switch (word) {
      case "удивительный":
        def noun = state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'property', val:'AMAZING').apply(nom, noun:noun)
      case "знаменской": // todo a unified treatment for street names
      case "бассейной":
        def noun = state.newVariable()
        def init = { ParsingState it -> it.assign(noun, 'type', 'STREET') }
        state = conjWrap(state, (gen):[noun:noun, init:init], (adjective):[nounFrame:noun, rel:'name', val:word[0..-3]+"ая", init:init])
        return state
      case "коммерческий":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'kind', val:'COMMERCIAL').apply(_acc, noun:noun)
      case "маленький":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'size', val:'LITTLE').apply(_acc, noun:noun)
      case "летний":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.noun ?: state.newVariable()
        return state.apply((adjective):[nounFrame:noun, rel:'timeAnchor', val:'SUMMER', xor:t.a], (_acc):[noun:noun], (summerGarden):[summer:true, xor:t.a])
      case "какой-то":
        def noun = state.newVariable()
        return state.apply((adjective):[nounFrame:noun, rel:'determiner', val:'SOME'], (nom):[noun:noun])
      case "большим":
        def _instr = transformCase(state, instr)
        def noun = state[_instr]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'size', val:'BIG').apply(_instr, noun:noun)
      case "большой":
        def _acc = transformCase(state, acc)
        def _instr = transformCase(state, instr)
        def noun = state[_instr]?.noun ?: state[_acc]?.noun ?: state.newVariable()
        return state.apply((adjective):[nounFrame:noun, rel:'size', val:'BIG'], (_instr):[noun:noun], (_acc):[noun:noun])
      case "нашем":
        def we = state.newVariable()
        def possHead = state[prep]?.noun ?: state.newVariable()
        state = state.assign(we, 'type', 'WE')
        return state.apply(possessive, possessor:we, head:possHead)
      case "этому":
        def noun = state[poDat]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'THIS').apply(poDat, noun:noun)
      case "всякого":
        def noun = state[gen]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'ANY').apply(gen, noun:noun)
      case "скромному":
        def noun = state[poDat]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'quality', val:'HUMBLE').apply(poDat, noun:noun)
      case "том":
        def _prep = transformCase(state, prep)
        def noun = state[_prep]?.noun ?: state.newVariable()
        return state.apply(adjective, nounFrame:noun, rel:'determiner', val:'THAT').apply(_prep, noun:noun)
      case "случай": return noun(state, nom, 'THING') //todo случай=CASE or THING
      case "случае":
        def _prep = transformCase(state, prep)
        def noun = state[_prep]?.noun ?: state.newVariable()
        state = state.apply(_prep, noun: noun, hasNoun:true) { ParsingState it ->it.assign(noun, 'type', 'CASE') }
        return state.apply(conditionComp, head:noun) //todo one noun frame - several cases
      case "удивление": return noun(state, nom, 'AMAZE')
      case "поводу": return noun(state, dat, 'MATTER')
      case "недоумении": return noun(state, prep, 'PREDICAMENT')
      case "рта": return noun(state, gen, 'MOUTH')
      case "смысла": return noun(state, gen, 'MEANING')
      case "молоточек": return noun(state, acc, 'HAMMER')
      case "радостью": return noun(state, instr, 'JOY')
      case "облегчением": return noun(state, instr, 'RELIEF')
      case "улицы": return noun(state, gen, 'STREET')
      case "скамейки": return noun(state, gen, 'BENCH')
      case "ребенок": return noun(state, nom, 'CHILD')
      case "углу":  //todo plain noun
        def noun = state[prep]?.noun ?: state.newVariable()
        state = state.apply(prep, noun: noun, hasNoun:true) {ParsingState it -> it.assign(noun, 'type', 'CORNER') }
        return state.apply(gen, head:noun) //todo one noun frame - several cases
      case "магазин":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.noun ?: state.newVariable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'SHOP') }
        state = state.apply((transformCase(state, nom)):[noun:noun, hasNoun:true, init:init, xor:t.a], (_acc):[noun:noun, hasNoun:true, init:init, xor:t.a])
        state = state.apply(naPrep, head:noun)
        state = state.apply(quotedName, noun:noun).satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
        return state //todo one noun frame - several cases
      case "сад":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.noun ?: state.newVariable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'GARDEN') }
        state = state.apply((transformCase(state, nom)):[noun:noun, hasNoun:true, init:init, xor:t.a], (_acc):[noun:noun, hasNoun:true, init:init, xor:t.a], (summerGarden):[garden:noun])
        state = state.apply(naPrep, head:noun)
        state = state.satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
        return state //todo one noun frame - several cases
      case "сада": return noun(state, gen, 'GARDEN')
      case "магазина":
        def noun = state[gen]?.noun ?: state.newVariable()
        state = state.apply(gen, noun: noun, hasNoun:true) {ParsingState it -> it.assign(noun, 'type', 'SHOP') }
        state = state.apply(naPrep, head:noun)
        state = state.apply(quotedName, noun:noun).satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
        return state //todo one noun frame - several cases
      case "мнению":
        if (state.situation.frame(state.chart).f('opinion_of') && !state[seq]?.conj) {
          def next = new Situation()
          state = state.assign(situation, 'but', next).withSituation(next).apply(prevHistory, history:state)
        }
        def noun = state[poDat]?.noun && !state[poDat]?.hasNoun ? state[poDat].noun : state.newVariable()
        state = state.assign(noun, 'type', 'OPINION')
        return conjWrap(state, (nounGen):[head:noun], (possessive):[head:noun], (poDat):[noun:noun, hasNoun:true],
                           (parenthetical):[:]) // todo common constructions in по-моему & по моему мнению
      case "словам":
        def noun = state[poDat]?.noun ?: state.newVariable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'WORDS') }
        state = state.apply((poDat):[noun:noun, hasNoun:true, init:init],
                            (nounGen):[head:noun, init:init],
                            (possessive):[head:noun, init:init])
        return state
      case "счастию":
        def noun = state[poDat]?.noun ?: state.newVariable()
        return state.assign(noun, 'type', 'LUCK').apply((poDat):[noun:noun, hasNoun:true])
      case "случился":
        Variable verb = state.newVariable()
        state = state.assign(verb, 'type', 'HAPPEN').assign(situation, 'time', 'PAST')
        return state.apply(sInstr, head:verb).apply(nom, head:verb)
      case 'со':
      case 'с':
        def noun = state.newVariable()
        return state.apply((preposition):[prep:'с'], (sInstr):[noun:noun, xor:t.b], (sGen):[noun:noun, xor:t.b])
      case 'по':
        return state.apply((preposition):[prep:'по'], (poDat):[noun:new Variable(), repeated:(state[seq] != null)])
      case 'о': return preposition(state, oPrep, prep)
      case 'к': return preposition(state, kDat, dat)
      case 'к': return preposition(state, kDat, dat)
      case 'до':
        return state.apply((preposition):[prep:'до'], (doGen):[noun:new Variable()])
      case 'в':
        def noun = state.newVariable()
        return state.apply((preposition):[prep:'в'], (vAcc):[noun:noun, xor:t.b], (vPrep):[noun:noun, xor:t.b])
      case 'из':
      case 'изо': return preposition(state, izGen, gen)
      case 'на': return preposition(state, naPrep, prep)
      case "мной": return noun(state, instr, 'ME')
      case ":":
        if (state[directSpeech]) {
          //todo construction handling of elaboration and direct speech
          return state.apply(directSpeech, hasColon:true)
        }

        def elaboration = new Situation()
        state = state.assign(situation, 'elaboration', elaboration)
        return state.withSituation(elaboration)
      case "я": return noun(state, nom, 'ME')
      case "мне": return noun(state, dat, 'ME')
      case "мы": return noun(state, nom, 'WE')
      case "нам": return noun(state, dat, 'WE')
      case "мое":
        def me = state.newVariable()
        return conjWrap(state, (possessive):[possessor:me, init:{ ParsingState it ->it.assign(me, 'type', 'ME') }])
      case "моему":
        def me = state.newVariable()
        return conjWrap(state, (possessive):[possessor:me, init:{ ParsingState it ->it.assign(me, 'type', 'ME') }])
      case "и": return state.apply(seq, save:state, conj:'and')
      case "или": return state.apply(seq, save:state, conj:'or')
      case "а":
      case "но":
        def next = new Situation()
        return state.assign(situation, 'but', next).withSituation(next).apply(prevHistory, history:state)
      case "тут":
        return state.assign(situation, 'emphasis', 'true')
      case "потом":
        Update update = new Update((comeScalarly):[order:'AFTER', xor: t.a], (nom):[:])
        if (state[comeScalarly]?.order) {
          state = state.inhibit(comeScalarly)
        } else {
          update = update.addCxt(relTime, relTime:'AFTER', xor:t.a)
        }
        return conjWrap(update.map, state)
      case "все":
        return state.assign(state[nom].noun, 'quantifier', 'ALL')
      case "дальше":
        def adv = state.newVariable()
        return state.apply((comeScalarly):[order:'AFTER', xor: t.a],  (advObj):[adv: adv, xor:t.a, init:{ ParsingState it ->it.assign(adv, 'type', 'NEXT') }])
      case "их":
        def they = state.newVariable()
        def init = {ParsingState st -> st.assign(they, 'type', 'THEY') }
        return conjWrap(state, (possessive):[possessor:they, init:init], (acc):[noun:they, hasNoun:true, init:init])
      case "они": return noun(state, nom, 'THEY')
      case "соседям": return noun(state, dat, 'NEIGHBOURS')
      case "кассиршу": return noun(state, acc, 'CASHIER')
      case "кассирша": return noun(state, nom, 'CASHIER') //todo кассир
      case "кассирши": return noun(state, nounGen, 'CASHIER')
      case "одних": return noun(state, nounGen, 'SOME')
      case "других": return noun(state, nounGen, 'OTHERS')
      case "деревья": return noun(state, acc, 'TREES')
      case "деньги": return noun(state, acc, 'MONEY')
      case "ее":
      case "её":
        def she = state.newVariable()
        def init = {ParsingState st -> st.assign(she, 'type', 'SHE') }
        return conjWrap(state, (possessive):[possessor:she, init:init], (acc):[noun:she, hasNoun:true, init:init])
      case "носом": return noun(state, instr, 'NOSE')
      case "пальцев": return noun(state, gen, 'FINGERS')
      case "челюсти":
        Construction _gen = transformCase(state, gen)
        Variable noun = state[_gen]?.noun ?: new Variable()
        return conjWrap(state, (_gen):[noun: noun], (acc):[noun:noun], (dativePart):[acc: noun], (typeCxt(noun, 'JAWS')):[var:noun], (numQuantifier):[noun:noun])
      case "челюстью": return noun(state, instr, 'JAW')
      case "челюсть":
        def noun = new Variable()
        return conjWrap(state, (acc):[noun: noun], (dativePart):[acc: noun], (typeCxt(noun, 'JAW')):[var:noun])
      case "семь":
        def noun = new Variable()
        def num = new Variable()
        return conjWrap(state.inhibit(numQuantifier), (nom):[noun: noun, xor:t.ac], (acc):[noun: noun, xor:t.ac], (typeCxt(noun, '7')):[xor:t.bd, var:noun], (numQuantifier):[num: num, xor:t.b], (typeCxt(num, '7')):[xor:t.cd, var:num])
      case "семи": return noun(state, gen, '7')
      case "восемь":
        def noun = new Variable()
        def num = new Variable()
        return conjWrap(state.inhibit(numQuantifier), (nom):[noun: noun, xor:t.a], (acc):[noun: noun, xor:t.a], (typeCxt(noun, '8')):[xor:t.bd, var:noun], (numQuantifier):[num: num, xor:t.b], (typeCxt(num, '8')):[xor:t.d, var:num])
      case "восьми": return noun(state, gen, '8')
      case "порядок":
        def noun = state.newVariable()
        state = state.apply(acc, noun: noun, hasNoun:true) { ParsingState it ->it.assign(noun, 'type', 'ORDER') }
        return state.apply(nounGen, head:noun) //todo one noun frame - several cases
      case "слова":
        def _acc = transformCase(state, acc)
        def noun = state[_acc]?.hasNoun ? state.newVariable() : state[_acc]?.noun ?: state.newVariable()
        def init = {ParsingState it -> it.assign(noun, 'type', 'WORDS') }
        Update update = new Update((_acc):[noun:noun, hasNoun:true, init:init, xor:t.a],
                                   (nounGen):[head:noun, init:init],
                                   (possessive):[head:noun, init:init])
        if (!state[preposition]) {
          update = update.addCxt(transformCase(state, nom), noun:noun, hasNoun:true, init:init, xor:t.a)
        }
        state = state.apply(update.map)
        return state
      case "счета": return noun(state, nounGen, 'COUNTING')
      case "счете": return noun(state, prep, 'COUNTING')
      case "работы":
        state = noun(state, gen, 'WORK')
        state = state.apply(absTime, noun:state[posleGen].noun)
        return state
      case "вдруг": return state.apply(adverb, adv:'SUDDENLY')
      case "опять":
        if (state[nom]) {
          def verb = state.newVariable()
          return state.assign(verb, 'anchor', 'AGAIN').apply(nom, head:verb)
        }
        return state
      case "слегка": return state.apply(adverb, adv:'SLIGHTLY')
      case "долго": return state.apply(adverb, adv:'LONG')
      case "грустно": return state.apply(adverb, adv:'SADLY')
      case "тоже":
        def alsoVar = state.newVariable()
        def subj = state.newVariable()
        state = state.assign(alsoVar, 'type', 'ALSO')
        state = state.assign(alsoVar, 'arg1', subj)
        return state.apply(also, also:alsoVar, subj:subj)
      case "не":
        return state.apply(negation)
      case "забыл":
        if (state[nom]) {
          Variable verb = state[nom].head ?: state.newVariable()
          state = state.assign(verb, 'type', 'FORGET').assign(situation, 'time', 'PAST')
          return state.apply(question, head:verb).apply(nom, head:verb).apply(adverb, head:verb)
        }
        return state
      case "забыли":
        Variable verb = state.newVariable()
        state = state.assign(verb, 'type', 'FORGET').assign(situation, 'time', 'PAST')
        def subj = state.newVariable()
        return state.apply(advObj, head:verb).apply(acc, head:verb).apply(nom, noun:subj, head:verb) { ParsingState it ->it.assign(subj, 'type', 'THEY') }
      case "помнят":
        Variable verb = state.newVariable()
        state = state.assign(verb, 'type', 'REMEMBER').assign(situation, 'time', 'PRESENT')
        state = state.apply(acc, head:verb)
        if (!state[nom]) {
          def subj = state.newVariable()
          state = state.apply(nom, noun:subj) { ParsingState it ->it.assign(subj, 'type', 'THEY') }
        }
        return state.apply(nom, head:verb)
      case "могут":
        def verb = state.newVariable()
        def also = state[also]
        def subj = null
        if (also) {
          subj = also.subj
          state = state.assign(also.also, 'theme', verb)
        }
        if (state[negation] != null) {
          state = state.assign(verb, 'negated', 'true')
        }
        if (!subj) {
          subj = state.newVariable()
        }
        state = state.assign(verb, 'type', 'CAN').assign(situation, 'time', 'PRESENT')
        state = state.assign(subj, 'type', 'THEY')
        return state.apply(control, subj:subj, head:verb)
      case 'стали':
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'BEGIN').assign(situation, 'time', 'PAST')
        return conjWrap(state, (control):[subj:state[nom], head:verb], (nom):[head:verb])
      case 'начали':
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'BEGIN').assign(situation, 'time', 'PAST')
        return conjWrap(state, (control):[subj:state[nom], head:verb], (nom):[head:verb])
      case 'свалился':
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'FALL').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (sGen):[head:verb], (poDat):[head:verb])
      case 'сломал':
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'BREAK').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (acc):[head:verb], (dat):[head:verb], (dativePart):[head:verb])
      case "отправился":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'GO_OFF').assign(situation, 'time', 'PAST')
        return conjWrap(state, (kDat):[head:verb], (nom):[head:verb])
      case "пошли":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'GO').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (vAcc):[head:verb])
      case "спорили":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'ARGUE').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (adverb):[head:verb])
      case "обнаружили":
        def verb = new Variable()
        state = state.assign(verb, 'type', 'DISCOVER').assign(situation, 'time', 'PAST').inhibit(relativeClause) //todo generic suppress for context-freeness
        return state.satisfied(declComp).apply(declComp, head:verb).apply(nom, head:verb).apply(adverb, head:verb)
      case "улыбнулась":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'SMILE').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (adverb):[head:verb])
      case "сказала":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'SAY').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (directSpeech):[head:verb])
      case "вынула":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'TAKE_OUT').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (acc):[head:verb], (izGen):[head:verb])
      case "показались":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'SEEM').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (dat):[head:verb], (participleArg):[head:verb])
      case "подвигав":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'MOVE').assign(verb, 'background', 'perfect')
        return conjWrap(state, (instr):[head:verb], (adverb):[head:verb])
      case "подвигала":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'MOVE')
        return conjWrap(state, (instr):[head:verb], (adverb):[head:verb])
      case "дойдя":
        def verb = state[instr]?.head ?: state.newVariable()
        state = state.assign(verb, 'type', 'COME_TO').assign(verb, 'background', 'perfect')
        return conjWrap(state, (vPrep):[head:verb], (doGen):[head:verb])
      case "вдумываясь":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'THINK').assign(verb, 'background', 'present')
        return conjWrap(state, (vAcc):[head:verb])
      case "вспомнить":
        def verb = state.newVariable()
        return infinitive(state, verb, 'RECALL', [(acc):[head:verb]])
      case "делать":
        def verb = state.newVariable()
        return infinitive(state, verb, 'DO', [(acc):[head:verb]])
      case "спорить":
        def verb = state.newVariable()
        return infinitive(state, verb, 'ARGUE', [:])
      case "считать":
        def verb = state.newVariable()
        return infinitive(state, verb, 'COUNT', [(acc):[head:verb]])
      case "поливать":
        def verb = state.newVariable()
        return infinitive(state, verb, 'TO_WATER', [(acc):[head:verb]])
      case "танцевать":
        def verb = state.newVariable()
        return infinitive(state, verb, 'DANCE', [:])
      case "нужно":
        def verb = state.newVariable()
        return state.assign(verb, 'type', 'NEED').apply((acc):[head:verb], (dat):[head:verb, infinitive:true])
      case "спросить":
        def verb = state.newVariable()
        return infinitive(state, verb, 'ASK', [(acc):[head:verb]])
      case "думают":
        if (state[nom]) {
          def verb = state.newVariable()
          state = state.assign(verb, 'type', 'THINK').assign(situation, 'time', 'PRESENT')
          return state.apply(poDat, head:verb).apply(nom, head:verb).apply(acc, head:verb)
        }
        return state
      case "спросил":
      case "спросили":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'ASK').assign(situation, 'time', 'PAST')
        return conjWrap(state, (acc):[head:verb], (nom):[head:verb], (question):[head:verb], (oPrep):[head:verb])
      case "делал":
      case "делали":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'DO').assign(situation, 'time', 'PAST')
        return conjWrap(state, (acc):[head:verb], (nom):[head:verb])
      case "поблагодарили":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'THANK').assign(situation, 'time', 'PAST')
        return conjWrap(state, (acc):[head:verb], (nom):[head:verb])
      case "выбежали":
        def verb = state.newVariable()
        state = state.assign(verb, 'type', 'RUN_OUT').assign(situation, 'time', 'PAST')
        return conjWrap(state, (izGen):[head:verb], (nom):[head:verb], (sInstr):[head:verb])
      case "приуныли":
        def verb = state[nom]?.head ?: state.newVariable()
        state = state.assign(verb, 'type', 'GET_SAD').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb], (reasonComp):[head:situation], (relTime):[head:state.situation])
      case "остановились":
        def verb = state[nom]?.head ?: state.newVariable()
        state = state.assign(verb, 'type', 'STOP').assign(situation, 'time', 'PAST')
        return conjWrap(state, (nom):[head:verb])
      case ",":
        state = state.apply((declComp):[hasComma:true],
                            (conditionComp):[hasComma:true],
                            (reasonComp):[hasComma:true],
                            (question):[hasComma:true],
                            (relativeClause):[hasComma:true, parentSituation:situation],
                            (prevHistory):[history:state],
                            (seq):[save:state, hasComma:true])
        if (state[nestedClause]) {
          state = state.withSituation((Situation)state[nestedClause].parent).clearConstructions().restore(((ParsingState) state[nestedClause].save).constructions).satisfied(nestedClause)
        }
        if (state[parenthetical]?.hasComma) {
          state = state.satisfied(parenthetical)
        } else {
          state = state.apply(parenthetical, hasComma:true)
        }
        return state
      case "если":
        return state.apply(conditionComp, wh:'if')
      case "когда":
        return state.apply(conditionComp, wh:'when')
      case "Что":
      case "что":
        def noun = state.newVariable()
        state = state.apply(question, questioned:noun)
        if (!state[declComp]) {
          //todo generic noun treatment for что
          state = state.apply((nom):[noun:noun, hasNoun:true, xor:t.a], (acc):[noun:noun, hasNoun:true, xor:t.a])
        }
        state = state.apply(declComp, complementizer:'that')
        if (state[relativeClause]?.hasComma) {
          def wh = new Variable()
          state = state.apply(relativeClause, wh:wh).apply(naPrep, head:wh) //todo pp copula
        }
        return state
      case "идет":
      case "идёт":
        def verb = new Variable()
        state = state.assign(situation, 'time', 'PRESENT')
        def goes = cxt('идёт') { ParsingState st, Map args -> st.assign(args.verb, 'type', 'GO') }
        return state.inhibit(preposition, numQuantifier).apply((comeScalarly):[verb:verb, xor:t.ab], (goes):[verb:verb, xor:t.a],
                                                (vAcc):[head:verb, xor:t.b], (vPrep):[head:verb], (nom):[head:verb],
                                                (posleGen):[head:verb], (ransheGen):[head:verb],
                                                (conditionComp):[head:situation], (absTime):[head:situation])
      case "следовало":
        Variable verb = state.newVariable()
        state = state.assign(situation, 'time', 'PAST')
        return state.inhibit(preposition, numQuantifier).apply((nom):[head:verb], (comeScalarly):[verb:verb], (posleGen):[head:verb], (relTime):[head:situation])
      case "раньше":
        return state.apply((comeScalarly):[order:'EARLIER', xor:t.a], (preposition):[prep:'ranshe'], (relTime):[relTime:'BEFORE', xor:t.a])
      case "после":
        return state.apply((comeScalarly):[order:'AFTER', xor:t.a], (preposition):[prep:'posle'], (absTime):[rel:'AFTER', xor:t.a])
      case "-":
        if (state[directSpeech]) {
          return state.apply(directSpeech, hasDash:true)
        }
        if (state[question]?.questioned) {
          state = state.clearConstructions().apply(questionVariants, questioned:state[question].questioned)
        }
        if (state[prevHistory]) {
          def mapping = [:]
          FList<Contribution> old = ((ParsingState) state[prevHistory].history).history
          def modern = state.history[0..state.history.size - old.size]
          def lcs = Util.lcs(old, modern, { Contribution a, Contribution b -> areSimilar(a.apps, b.apps) } as Function2)
          if (lcs) {
            lcs.each { Contribution contribution ->
              contribution.apps.values().each { val ->
                if (val instanceof Variable && !mapping[val]) {
                  mapping[val] = new Variable()
                }
              }
            }
            def commonStart = old.indexOf(lcs[0])
            if (commonStart) {
              FList<Contribution> remaining = FList.fromList(old[0..commonStart-1])
              state = state.clearConstructions().apply(clauseEllipsis, remaining:remaining, mapping: mapping)
            }
          }
        }
        return state
      case ".":
        return state.assign(state.situation, 'dot', 'true').withSituation(new Situation())
      case 'каково':
        def degree = state.newVariable()
        state = state.assign(situation, 'exclamation', degree)
        return state.apply(shortAdjCopula, pred:degree, situation:state.situation)
      case 'бы':
        return state.assign(situation, 'mood', 'subjunctive')
      case 'был':
        def subj = state[nom]?.noun ?: state.newVariable()
        state = state.assign(situation, 'time', 'PAST').assign(situation, 'copulaTopic', subj)
        return state.apply(naPrep, head: subj).apply(nom, noun:subj)
      case 'было':
        state = state.assign(situation, 'time', 'PAST')
        return state.apply(conditionComp, head:situation)
      case 'так':
        return state.apply(reasonComp, active:true)
      case 'обе':
        def num = new Variable()
        return state.inhibit(numQuantifier).assign(num, 'type', 'BOTH').apply((numQuantifier):[num:num])
      case 'себе':
        def noun = state[nom]?.noun ?: new Variable()
        return state.apply((nom):[noun:noun], (dat):[noun:noun], (dativePart):[dat:noun])
      case 'по-моему':
        def opinion = new Variable()
        def me = new Variable()
        return state.assign(state.situation, 'opinion_of', opinion).assign(opinion, 'type', 'OPINION').assign(opinion, 'arg1', me).assign(me, 'type', 'ME').apply(parenthetical)
      case '?': return state.apply(question, comp:situation)
      case '"':
        if (state[quotedName]) {
          if (state[quotedName].started) {
            state = state.apply(quotedName, finished:true)
          } else {
            state = state.apply(quotedName, started:true)
          }
        }
        return state
      case 'лишенными':
        def lack = state.newVariable()
        state = state.assign(lack, 'type', 'LACK')
        return state.apply(participleArg, participle:lack).apply(gen, head:lack)
      case 'бессмысленными':
        def part = state.newVariable()
        state = state.assign(part, 'type', 'MEANINGLESS')
        return state.apply(participleArg, participle:part)
      case '6-ти':
      case 'шести':
        return noun(state, gen, '6')
      case '5-ти':
        return noun(state, gen, '5')
    }
    return state
  }

  private boolean areSimilar(Map<Construction, Map> c1, Map<Construction, Map> c2) {
    def common = Util.intersect(c1.keySet(), c2.keySet())
    common = Util.intersect(common, [nom, acc, gen, dat, instr, prep, possessive, parenthetical, nounGen, comeScalarly, poDat])
    common = common.findAll { (c1[it].keySet() - 'init' - 'xor') == (c2[it].keySet() - 'init' - 'xor') }

    if (common.size() == 1 && possessive in common && c1[possessive].head) {
      return false
    }

    return common.size() > 0
  }

  private ParsingState infinitive(ParsingState state, Variable verb, String type, LinkedHashMap<Construction, LinkedHashMap<String, Object>> args) {
    if (state[question]) {
      state = state.apply((question): [mainVerb: verb, imperative: true])
    }
    return state.assign(verb, 'type', type).apply(args + [(dat): [head: verb, infinitive: true], (control): [slave: verb]])
  }

  private ParsingState noun(ParsingState state, Construction caze, String type) {
    return noun(state, caze) { ParsingState st, Variable n -> st.assign(n, 'type', type) }
  }
  private ParsingState noun(ParsingState state, Construction caze, Closure init) {
    caze = transformCase(state, caze)

    Variable noun = state.constructions[caze]?.noun && !state.constructions[caze].hasNoun ? state.constructions[caze]?.noun : state.newVariable()

    if (noun.frame(state.chart).f('member')) { //todo number agreement
      noun = noun.frame(state.chart).f('member').var
    }

    Update update = new Update([:])

    if (caze == nom) {
      update = update.addCxt(shortAdjCopula, noun:noun)
    }

    update = update.addCxt(caze, noun:noun, hasNoun:true, init:{ init(it, noun) })

    if (state[possessive]) {
      update = update.addCxt(possessive, head:noun)
    }

    if (state[preposition] && !state[preposition].hasNoun) {
      update = update.addCxt(preposition, hasNoun:true)
    }

    update = update.addCxt(quotedName, noun:noun).addCxt(numQuantifier, noun:noun)

    return conjWrap(update.map, state).satisfied(relativeClause).apply(relativeClause, noun:noun, save:state)
  }

  private Construction transformCase(ParsingState state, Construction caze) {
    if (state[numQuantifier]?.num && !state[numQuantifier].noun && caze == gen) {
      return acc
    }

    if (state[preposition]?.hasNoun) {
      return caze
    }

    def p = state[preposition]?.prep

    if (p == 'posle' && caze == gen) return posleGen
    if (p == 'ranshe' && caze == gen) return ransheGen
    if (p == 'по' && caze == dat) return poDat
    if (p == 'в' && caze == prep) return vPrep
    if (p == 'в' && caze == acc) return vAcc
    if (p == 'с' && caze == gen) return sGen
    if (p == 'с' && caze == instr) return sInstr
    if (p == 'до' && caze == gen) return doGen
    return caze
  }

  private ParsingState preposition(ParsingState state, Construction prepCtx, Construction caze) {
    def noun = state.newVariable()
    state = state.apply(prepCtx, noun:noun)
    def save = state.constructions
    return state.clearConstructions().apply(caze, save: save, delegate: prepCtx, noun:noun)
  }

  private Construction typeCxt(Variable var, String type) {
    return cxt("type_${var}_$type") { st, a -> st.assign(a.var, 'type', type) }
  }

}

