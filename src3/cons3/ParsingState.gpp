package cons3

/**
 * @author peter
 */
class ParsingState {
  static final ParsingState EMPTY = new ParsingState()
  final Chart chart
  private final FLinkedMap<Mite, Integer> miteGenerations
  final List<Mite> contribution
  final Network network
  final int currentGeneration
  private Map<Construction, List<Mite>> vmCache
  final List<Mite> ownMites
  final ParsingState prevState

  ParsingState() {
    this([chart: new Chart(), prevState:EMPTY, network:new Network([:], [:], [])], null)
  }

  private ParsingState(Map map, ParsingState base) {
    chart = map.chart ?: base.chart
    currentGeneration = map.currentGeneration ?: base?.currentGeneration ?: 0
    network = map.network ?: base.network
    miteGenerations = map.miteGenerations ?: base?.miteGenerations ?: FLinkedMap.emptyMap
    contribution = map.contribution ?: base?.contribution ?: []
    ownMites = map.ownMites ?: base?.ownMites ?: []
    prevState = map.prevState ?: base?.prevState
  }

  List<Mite> getMiteList() {
    return visibleMites.values().collect { it.reverse() }.flatten() as List
  }

  Map<Construction, List<Mite>> getVisibleMites() {
    if (vmCache == null) {
      vmCache = this.calcVisibleMites()
    }
    return vmCache
  }

  private ParsingState clone(Map update) {
    return new ParsingState(update, this)
  }


  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign(((Variable)var).base, property, value instanceof Variable ? value.base : value, currentGeneration))
  }

  ParsingState advanceSection() {
    clone(chart: chart.advanceSection())
  }

  Map getAt(Construction c) {
    def allMites = visibleMites[c]
    if (allMites == null) {
      return null
    }

    for (Mite mite in allMites.reverse()) {
      if (network.isChosen(mite)) {
        return mite.contents
      }
    }

    Map value = [:]
    for (part in allMites.reverse()) {
      if (!Mite.overwrites(value, part.contents)) {
        value = Mite.unify(value, part.contents)
      }
    }
    value
  }

  @Override
  String toString() {
    return "#$currentGeneration"
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private Mite nextInterceptor(Construction start) {
    def mites = visibleMites
    List<Construction> cs = mites.keySet() as List
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = mites[cxt].reverse().find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    apply((constructions.keySet() as List<Construction>).collect { it(constructions[it]) } as List)
  }
  ParsingState apply(Mite... constructions) { apply(constructions as List) }
  ParsingState apply(List<Mite> constructions) {
    if (!constructions) return this

    def interceptor = nextInterceptor(null)
    if (interceptor) {
      return ((Interceptor) interceptor.contents.interceptor).intercept(constructions, this, { c, s -> baseApply(s, c, true) })
    }
    return baseApply(this, constructions, true)
  }

  private static ParsingState baseApply(ParsingState state, List<Mite> update, boolean mayCorrectRoute) {
    LinkedHashSet<Mite> fullUpdate = update as LinkedHashSet<Mite>
    fullUpdate.addAll(state.enrichUpdate(update, state))
    assert fullUpdate

    def newMiteGenerations = registerGeneration(fullUpdate, state.miteGenerations, state.currentGeneration)
    state = state.clone(ownMites:fullUpdate as List, prevState:state,
            miteGenerations:newMiteGenerations, network:state.network.addMites(fullUpdate),
            contribution:update, currentGeneration:state.currentGeneration + 1)

    def newActive = state.network.choose(fullUpdate)
    def sat = newActive.maximizeSatisfiedness()
    state = state.activate(sat)

    state = processAlternatives(state, fullUpdate)

    if (mayCorrectRoute && state.findTraitor()) {
      state = correctRoute(state.prevState, FList.fromList([state]))
    }

    return state
  }

  private static FLinkedMap<Mite, Integer> registerGeneration(LinkedHashSet<Mite> fullUpdate, FLinkedMap<Mite, Integer> newMiteGenerations, int generation) {
    for (mite in fullUpdate) {
      newMiteGenerations = newMiteGenerations.putValue(mite, generation)
    }
    return newMiteGenerations
  }

  private static ParsingState processAlternatives(ParsingState state, LinkedHashSet<Mite> fullUpdate) {
    for (cxt in state.visibleMites.keySet()) {
      if (!(cxt in state.visibleMites)) continue

      List<Mite> toCheck = (fullUpdate as List<Mite>).findAll { it.cxt == cxt }
      def last = state.visibleMites[cxt].reverse()[0]
      if (last && !(last in toCheck)) {
        toCheck << last
      }

      for (toAdd in toCheck.reverse()) {
        if (!state.network.isChosen(toAdd)) {
          state = tryAlternative(state, [toAdd])
        }
      }
    }
    return state
  }

  private static ParsingState correctRoute(ParsingState state, FList<ParsingState> reapply) {
    for (mite in state.miteList) {
      if (mite in state.miteList && !state.network.isChosen(mite)) {
        def anotherActive = state.network.choose([mite])
        def alternative = state.activate(anotherActive)
        for (step in reapply) {
          alternative = baseApply(alternative, step.contribution, false)
        }
        if (!alternative.findTraitor()) {
          return alternative
        }
      }
    }
    if (state.prevState) {
      return correctRoute(state.prevState, reapply.prepend(state))
    }
    return state
  }

  private Mite findTraitor() {
    miteList.find { it.cxt.wrongRoute(it, this) }
  }

  ParsingState getPrevVisibleState() {
    getPrevStateFromLink(findLink(null), null)
  }

  private final Map<Mite, Mite> linkCache = [:]
  private Mite findLink(Mite via) {
    if (linkCache.containsKey(via)) {
      return linkCache[via]
    }

    return linkCache[via] = doFindLink(via, true) ?: doFindLink(via, false)
  }
  private Mite doFindLink(Mite via, boolean up) {
    ParsingState bestPrev = null
    Mite nextVia = null
    for (mite in ownMites) {
      if (!network.isChosen(mite)) continue

      def somePrev = mite.cxt.showPrev(mite, prevState, via, up)
      if (somePrev == EMPTY) {
        return mite
      }
      if (somePrev && (bestPrev == null || bestPrev.isMoreRecentThan(somePrev))) {
        bestPrev = somePrev
        nextVia = mite
      }
    }
    return nextVia
  }

  private LinkedHashSet<Mite> findAllLinks(Mite via) {
    def link = findLink(via)
    if (!link) return []

    def prev = getPrevStateFromLink(link, via)
    assert prev
    return ownMites.findAll { prev == getPrevStateFromLink(it, via, null) } as LinkedHashSet
  }

  boolean isMoreRecentThan(ParsingState state) {
    return state == this || prevState?.isMoreRecentThan(state)
  }

  LinkedHashSet<Mite> enrichUpdate(List<Mite> update, ParsingState original) {
    _enrichUpdate(update, null, original)
  }

  private LinkedHashSet<Mite> _enrichUpdate(List<Mite> update, Mite via, ParsingState original) {
    LinkedHashSet<Mite> fullUpdate = askEnrichAction(findMitesAlongParsingRoute(via, original), update, original)
    Mite link = findLink(via)
    ParsingState prev = getPrevStateFromLink(link, via)
    if (prev) {
      List<Mite> filtered = update.findAll { !link || link.cxt.filterUpdate(link, it) }
      return fullUpdate + prev._enrichUpdate(filtered, link, original)
    }
    return fullUpdate
  }

  private LinkedHashSet<Mite> askEnrichAction(List<Mite> mites, List<Mite> update, ParsingState original) {
    LinkedHashSet<Mite> fullUpdate = []
    for (mite in mites) {
      fullUpdate.addAll((mite.cxt.enrichAction(mite, update, original) as List<Mite>).reverse())
    }
    return fullUpdate
  }

  private List<Mite> findMitesAlongParsingRoute(Mite via, ParsingState original) {
    LinkedHashSet<Mite> links = findAllLinks(via)
    return ownMites.findAll { mite -> !links || links.find { !original.network.contradict(mite, it) } }
  }

  ParsingState getPrevStateFromLink(Mite link, Mite via, ParsingState defValue = prevState) {
    link?.cxt?.showPrev(link, prevState, via, true) ?: link?.cxt?.showPrev(link, prevState, via, false) ?: defValue
  }

  private static ParsingState tryAlternative(ParsingState state, Collection<Mite> preferred) {
    def anotherActive = state.network.choose(preferred)
    def alternative = state.activate(anotherActive)
    try {
      if (new Domination(alternative, state).dominatesSemantically()) {
        return alternative
      }
    } catch (Throwable e) {
      println alternative.chart.presentable() + "\n\n"
      println alternative.presentable() + "\n\n"
      throw e
    }
    return state
  }

  private static ParsingState activate(ParsingState state, Network newActive) {
    def oldActive = state.network
    state = state.clone(network:newActive)

    def toRemove = Util.minus(oldActive._chosen, newActive._chosen)

    LinkedHashSet<Mite> toApply = Util.minus(newActive._chosen, oldActive._chosen)
    toApply = Util.intersect(toApply, state.ownMites) + toApply + Util.intersect(state.miteList, newActive._chosen)

    state = state.undoChanges(toRemove)
    state = state.clone(chart:addNewUnifications(state, toApply))

    while (true) {
      ParsingState result = applyConstructions(toApply, state)
      if (result.chart == state.chart) {
        return result
      }
      state = result
    }
  }

  private static ParsingState applyConstructions(LinkedHashSet<Mite> toApply, ParsingState state) {
    for (mite in toApply) {
      if (state.network.isChosen(mite) && mite.contents && mite.cxt.isExecutable(mite)) {
        ParsingState next = state.clone(currentGeneration:state.miteGenerations[mite]?: state.currentGeneration, chart:state.chart.startMeta(mite))
        next = mite.cxt.action.call(next, mite.contents)
        state = next.clone(currentGeneration:state.currentGeneration, chart:next.chart.finishMeta(mite))
      }
    }
    return state
  }

  private static Chart addNewUnifications(ParsingState state, LinkedHashSet<Mite> toApply) {
    def ch = state.chart
    for (mite in toApply) {
      ch = ch.startMeta(mite)
      for (pair in mite.unifications) {
        ch = ch.addUnificationConstraint(pair.first.base, pair.second.base)
      }
      ch = ch.finishMeta(mite)
    }
    return ch
  }

  private ParsingState undoChanges(Collection<Mite> toRemove) {
    ParsingState state = this
    for (mite in toRemove) {
      state = state.clone(chart:state.chart.removeDifference(mite))
    }
    return state
  }

  String presentable() {
    def log = ""
    def mites = visibleMites
    def link = findLink(null)
    def links = findAllLinks(null)
    log += "$this->${getPrevStateFromLink(link, null)},  uni: " + chart.__unifications.keySet().collect { "${it.iterator().next()}=" + (it as List)[1] }.join(", ") + "\n"
    for (k in mites.keySet()) {
      log += "    $k: " + mites[k].collect {
        (it in links ? '!!' : '') + (network.isChosen(it) ? '*' : '') + (it.satisfied ? '' : '@') +
        new LinkedHashMap(it.contents.reverse()) +
        (it.unifications ? ';' + it.unifications.collect { "<$it.first=$it.second>" }.join("") : '')
      }.join(" ") +"\n"
    }
    LinkedHashSet<Mite> invisible = network.chosenUnsatisfied.findAll { !(it in miteList) }
    if (invisible) {
      log += "    invisible: " + invisible.collect { "${network.isChosen(it) ? '*' : ''}@$it" }.join(", ") + "\n"
    }
    return log
  }

  ParsingState findState(Mite mite, String attr) {
    findState(mite.primaries.find { it.contents[attr] })
  }
  ParsingState findState(Mite mite) {
    if (mite in ownMites) {
      return this
    }
    return prevState?.findState(mite)
  }

  List<ParsingState> getHistory() {
    def result = []
    def each = this
    while (each) {
      result << each
      each = each.prevState
    }
    result
  }

  private static Map<Construction, List<Mite>> calcVisibleMites(ParsingState state) {
    Map<Construction, List<Mite>> result = [:]
    Mite via = null
    while (state) {
      Mite link = state.findLink(via)
      state.ownMites.groupBy { it.cxt }.each { cxt, group ->
        List updated = new ArrayList(group)
        if (result[cxt]) {
          updated.addAll(result[cxt])
        }
        result[cxt] = updated
      }
      state = state.getPrevStateFromLink(link, via)
      via = link
    }
    result
  }

}