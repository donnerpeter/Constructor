package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final FLinkedMap<Construction, List<Mite>> mites
  final FLinkedMap<Construction, Map> constructions
  private final FLinkedMap<Construction, List<Pair<Chart, Chart>>> changes
  final FList<Contribution> history
  final FList<Mite> active

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(), mites: FLinkedMap.emptyMap, changes: FLinkedMap.emptyMap, history: FList.emptyList, active: FList.emptyList)
  }

  ParsingState(Map map) {
    chart = map.chart
    changes = map.changes
    situation = map.situation
    mites = map.mites
    history = map.history
    active = map.active

    if (map.constructions != null) {
      constructions = map.constructions
    } else {
      FLinkedMap<Construction, Map> merged = FLinkedMap.emptyMap

      for (c in mites.keySet()) {
        Map value = [:]
        for (Mite mite in Util.intersect(active as Set, mites[c])) {
          value = unify(value, mite.contents)
        }
        for (part in mites[c].reverse()) {
          if (!overwrites(value, part.contents)) {
            value = unify(value, part.contents)
          }
        }
        merged = merged.putValue(c, value)
      }

      constructions = merged
    }
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, mites:mites, history:history, active:active, changes:changes]
    current.putAll(update)
    if (update.mites == null && update.active == null) {
      current.constructions = constructions
    }
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign((Variable)var, situation, property, value))
  }
  
  Map getAt(Construction construction) {
    def mite = nextInterceptor(null)
    if (mite) {
      def interceptor = (Interceptor) mite.contents.interceptor
      def args = interceptor.getArgs(construction, this)
      if (args != null) {
        return args
      }
      
    }
    
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return false
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && arg != 'xor' && before[arg] != newArgs[arg] && before[arg] != null) {
        return true
      }
    }
    return false
  }

  ParsingState addCxt(Mite mite) {
    return clone(mites: mites + [(mite.cxt): (mites[mite.cxt] ?: []) + mite])
  }

  static Map unify(Map oldArgs, Map newArgs) {
    def args = oldArgs ? oldArgs + newArgs : newArgs
    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args += [init:merged]
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args += [xor:xor]
    }

    return Collections.unmodifiableMap(args)
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor
    Set xor2 = newArgs?.xor
    def xor = (xor1 ?: Collections.emptySet()) + (xor2 ?: Collections.emptySet())
    if (!xor) {
      xor = null
    }
    return xor
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(mites.keySet())

    Map<Construction, Map> freed = freedByInhibition(toRemove)

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

    return (freed ? state.apply(freed) : state).clone(history: history + new Contribution(this, FLinkedMap.emptyMap, FList.fromList(cxts as List)))
  }

  Map<Construction, Map> freedByInhibition(Set<Construction> toRemove) {
    LinkedHashSet<Construction> remaining = (mites.keySet() as LinkedHashSet) - toRemove

    Map<Construction, Map> freed = [:]
    for (removed in remaining) {
      for (c in toRemove) {
        if (contradict(this[removed], this[c])) {
          freed[removed] = [:]
        }
      }
    }
    return freed
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    return clone(mites: mites.removeKey(name), active: active.withoutAll(mites[name] ?: []), changes:changes.removeKey(name))
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private LinkedHashSet<Construction> findContradictors(Construction c, Collection<Construction> among, Map<Construction, Map> values = constructions) {
    return new LinkedHashSet<Construction>(among).findAll { contradict(values[it], values[c]) }
  }

  private Mite nextInterceptor(Construction start) {
    def cs = mites.keyList()
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = mites[cxt].reverse().find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  private Function2<Map<Construction, Map>, ParsingState, ParsingState> nextApplier(Construction start) {
    def interceptor = nextInterceptor(start)
    if (interceptor) {
      return { c, s -> ((Interceptor) interceptor.contents.interceptor).intercept(c, s, { c1, s1 ->
        s1.nextApplier(interceptor.cxt).call(c1, s1)
      }) }
    }
    return { c, s -> baseApply(s, c, true) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    def applier = nextApplier(null)
    applier(constructions, this).clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions).reverse(), FList.emptyList))
  }

  private static ParsingState baseApply(ParsingState state, Map<Construction, Map> update, boolean tryAlternatives) {
    List<Mite> newMites = update.collect { c, v -> new Mite(v, c) } as List
    for (c in newMites.reverse()) {
      state = state.addCxt(c)
    }
    
    Map<Mite, LinkedHashSet<ParsingState.Group>> groups = state.buildGroups()
    for (mite in newMites) {
      groups[mite].each { it.isNew = true }
    }

    def newActive = state.balance(groups, allGroups(newMites, groups) as List, state.active as LinkedHashSet, [])
    assert newActive != null : 'cannot balance'
    state = state.activate(newActive)

    for (cxt in state.mites.keySet()) {
      def currentActive = Util.intersect(state.active as LinkedHashSet, state.mites[cxt])
      List<Mite> toAdd = []
      for (mite in state.mites[cxt].reverse()) {
        if (!(mite in currentActive) && !mite.findContradictors(currentActive)) {
          currentActive << mite
          toAdd << mite
        }
      }
      if (toAdd) {
        newActive = state.active as LinkedHashSet
        def cxtContradictors = toAdd.collect { it.findContradictors(newActive) }.flatten().collect { Mite m -> m.cxt } as LinkedHashSet<Construction>
        def contradictors = cxtContradictors.collect { state.mites[it].reverse() }.flatten() as LinkedHashSet<Mite>
        newActive = state.balance(groups, allGroups(contradictors, groups) as List, newActive - contradictors + toAdd as LinkedHashSet, [])
        if (newActive) {
          def alternative = state.activate(newActive)
          def act1 = (alternative.active.collect { it.cxt } as Set).size()
          int act2 = (state.active.collect { it.cxt } as Set).size()
          if (act1 < act2 ||
              act1 == act2 && state.active.size() < alternative.active.size() ||
              alternative.dominates(state)) {
            state = alternative
          }
        }
      }
    }

    state
  }

  private Map<Mite, LinkedHashSet<ParsingState.Group>> buildGroups() {
    Map<Mite, LinkedHashSet<Group>> groups = [:]
    Map<Object, Group> members = [:]
    for (Mite mite in mites.values().flatten()) {
      Collection<Object> _xor = mite.contents.xor ?: [new Object()] //todo alex inline
      LinkedHashSet<Object> xor = new LinkedHashSet<Object>(_xor)
      for (x in xor) {
        if (!members[x]) members[x] = new Group()
        members[x].members << mite
      }
      groups[mite] = xor.collect { members[it] } as LinkedHashSet
    }
    return groups
  }

  private static LinkedHashSet<Group> allGroups(Collection<Mite> newMites, Map<Mite, LinkedHashSet<Group>> groups) {
    return newMites.collect { groups[it] }.flatten() as LinkedHashSet
  }

  private ParsingState activate(LinkedHashSet<Mite> newActive) {
    def toRemove = new LinkedHashSet<Mite>(active)
    toRemove.removeAll(newActive)
    def toApply = new LinkedHashSet<Mite>(newActive)
    toApply.removeAll(active)
    
    def state = clone(active: FList.fromList(newActive as List))
    for (mite in toRemove) {
      if (mite.findContradictors(toApply).find { mite.cxt != it.cxt }) {
        state = state.undoChanges(mite.cxt).doApply(mite.cxt)
      }
    }
    for (mite in toApply) {
      state = state.doApply(mite.cxt)
    }
    state
  }
  
  private static class Group {
    List<Mite> members = []
    boolean isNew

    @Override
    String toString() {
      return members.toString()
    }

  }

  private LinkedHashSet<Mite> balance(Map<Mite, LinkedHashSet<Group>> groups, List<Group> changed, LinkedHashSet<Mite> result, Set<Group> visited) {
    for (i in 0..<changed.size()) {
      def g = changed[i]
      if (Util.intersect(result, g.members)) {
        continue
      }

      List<Group> rest = i == changed.size() - 1 ? [] : changed[i + 1..<changed.size()]
      LinkedHashSet<Mite> sortedMembers = []
      sortedMembers.addAll g.members.findAll { Mite mite -> result.find { it.cxt == mite.cxt } }
      sortedMembers.addAll g.members

      for (mite in sortedMembers) {
        if (!mite.findContradictors(result)) {
          LinkedHashSet bigger = result + mite as LinkedHashSet
          def inner = balance(groups, rest, bigger, visited + changed[0..i] as Set)
          if (inner != null) {
            return inner
          }
        }
      }

      for (mite in sortedMembers) {
        List<Mite> contradictors = mite.findContradictors(result)
        LinkedHashSet<Group> touchedGroups = allGroups(contradictors, groups)
        if (!Util.intersect(visited, touchedGroups)) {
          LinkedHashSet modified = result - contradictors + mite as LinkedHashSet
          def inner = balance(groups, rest + touchedGroups as List, modified, visited + changed[0..i] as Set)
          if (inner != null) {
            return inner
          }
        }
      }

      if (g.isNew && g.members.size() == 1) {
        def mite = g.members[0]
        List<Mite> contradictors = mite.findContradictors(result)
        LinkedHashSet bigger = result - contradictors + mite as LinkedHashSet
        def inner = balance(groups, rest, bigger, visited + changed[0..i] as Set)
        if (inner != null) {
          return inner
        }
      }

      return null
    }
    
    return result
  }

  private ParsingState undoChanges(Construction cxt) {
    List<Pair<Chart, Chart>> diffList = changes[cxt] ?: []
    def newChart = diffList.foldLeft(chart) { Pair<Chart, Chart> diff, Chart ch -> ch.removeDifference(diff) }
    return clone(changes: changes.removeKey(cxt), chart: newChart)
  }

  private boolean dominates(ParsingState other) {
    for (verb in chart.frames.findAll { it.type in ['GO', 'BREAK'] }) {
      def alternative = verb.var.frame(other.chart)
      if (!alternative) continue

      if (!alternative.f('arg1')?.canBeHuman() && verb.f('arg1')?.canBeHuman()) {
        return true
      }

      if (verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        return true
      }
    }
    
    return false
  }

  private ParsingState doApply(Construction cxt) {
    List<Mite> mites = mites[cxt]
    Map args = [:]
    for (Mite mite in Util.intersect(active as Set, mites)) {
      args = unify(args, mite.contents)
    }

    Closure init = args.init ?: noInit
    args = args - [init:args.init]
    if (!args) {
      return this
    }

    def before = chart
    
    def next = (ParsingState)init(this)
    next = cxt.action.call(next, args)
    if (before != next.chart) {
      next = next.clone(changes: changes + [(cxt):(changes[cxt] ?: []) + new Pair(before, next.chart)])
    }
    return next
  }


  ParsingState clearConstructions() {
    return clone(mites: FLinkedMap.emptyMap, active:FList.emptyList, changes:FLinkedMap.emptyMap)
  }

  ParsingState restore(ParsingState saved) {
    clone(mites: saved.mites + this.mites, active:saved.active.withoutAll(active).prependAll(active), changes:saved.changes + this.changes)
  }

  private static boolean contradict(Map args1, Map args2) {
    if (args1.is(args2)) return false

    Set xor1 = args1.xor
    Set xor2 = args2.xor
    return xor1 && xor2 && Util.intersect(xor1, xor2)
  }
}