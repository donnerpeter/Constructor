package cons3

/**
 * @author peter
 */
class ParsingState {
  final Chart chart
  final Situation situation
  final Node node
  private final FLinkedMap<Mite, Integer> miteGenerations
  final FList<Contribution> history
  final Set<Mite> active
  private final Map<Object, Mite> byXor
  private final int currentGeneration

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(),
            node: Node.EMPTY,
            history: FList.emptyList, active: Collections.emptySet(), currentGeneration:0, miteGenerations:FLinkedMap.emptyMap, byXor:Collections.emptyMap())
  }

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    node = map.node
    history = map.history
    currentGeneration = map.currentGeneration
    byXor = map.byXor
    assert (map.active instanceof LinkedHashSet) || !(map.active instanceof HashSet)
    assert (map.groups instanceof LinkedHashSet) || !(map.groups instanceof HashSet)
    active = Collections.unmodifiableSet((Set)map.active)
    miteGenerations = map.miteGenerations
  }

  List<Mite> getMiteList() {
    return visibleMites.values().collect { it.reverse() }.flatten() as List
  }

  Map<Construction, List<Mite>> getVisibleMites() {
    return node.visibleMites
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, node:node, history:history, active:active, currentGeneration:currentGeneration, miteGenerations:miteGenerations, byXor:byXor]
    current.putAll(update)
    return current == update ? this : new ParsingState(current)
  }

  static boolean areUnifiableVars(val1, val2) {
    return val1 != val2 && val1 instanceof Variable && val2 instanceof Variable && (val1.light || val2.light) && val1.base != val2.base
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign(((Variable)var).base, situation, property, value instanceof Variable ? value.base : value, currentGeneration))
  }

  Map getAt(Construction c) {
    def allMites = visibleMites[c]
    if (allMites == null) {
      return null
    }

    for (Mite mite in allMites.reverse()) {
      if (mite in active) {
        return mite.contents
      }
    }

    Map value = [:]
    for (part in allMites.reverse()) {
      if (!overwrites(value, part.contents)) {
        value = unify(value, part.contents)
      }
    }
    value
  }

  ParsingState apply(Map newArgs = [:], Construction name) {
    return apply((name): newArgs)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return false
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg == 'xor') continue

      def val1 = before[arg]
      def val2 = newArgs[arg]
      if (val1 != val2 && val1 != null && val2 != null && !areUnifiableVars(val1, val2)) {
        return true
      }
    }
    return false
  }

  private ParsingState addCxt(Node node) {
    def newMiteGenerations = miteGenerations
    for (mite in node.ownMites) {
      newMiteGenerations = newMiteGenerations.putValue(mite, currentGeneration)
    }

    return clone(node:node, miteGenerations:newMiteGenerations)
  }

  public static Map unify(Map oldArgs, Map newArgs) {
    def args = new HashMap()
    if (oldArgs) args.putAll(oldArgs)
    if (newArgs) {
      for (key in newArgs.keySet()) {
        if (oldArgs[key] instanceof Variable && !((Variable) oldArgs[key]).light) {
          continue
        }
        args[key] = newArgs[key]
      }
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args.xor = xor
    }

    return args
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor ?: Collections.emptySet()
    Set xor2 = newArgs?.xor ?: Collections.emptySet()
    if (!xor1 && !xor2) {
      return null
    }

    def xor = new LinkedHashSet()
    xor.addAll xor1
    xor.addAll xor2
    return xor
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    LinkedHashSet<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(visibleMites.keySet())

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

    return state.clone(history: history + new Contribution(this, FList.emptyList, FList.fromList(cxts as List)))
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    LinkedHashSet<Mite> newActive = new LinkedHashSet<Mite>(active)
    Set<Mite> toRemove = new LinkedHashSet<Mite>(visibleMites[name] ?: [])
    if (!toRemove) {
      return this
    }

    newActive.removeAll(toRemove)
    return clone(node: new Node(Collections.emptyList(), toRemove, node, this), active:newActive)
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private Mite nextInterceptor(Construction start) {
    def mites = visibleMites
    List<Construction> cs = mites.keySet() as List
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = mites[cxt].reverse().find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  private Function2<List<Mite>, ParsingState, ParsingState> nextApplier(Construction start) {
    def interceptor = nextInterceptor(start)
    if (interceptor) {
      return { c, s -> ((Interceptor) interceptor.contents.interceptor).intercept(c, s, { c1, s1 ->
        s1.nextApplier(interceptor.cxt).call(c1, s1)
      }) }
    }
    return { c, s -> baseApply(s, c) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    apply((constructions.keySet() as List<Construction>).collect { it(constructions[it]) } as List)
  }
  ParsingState apply(List<Mite> constructions) {
    if (!constructions) return this

    def applier = nextApplier(null)
    applier(constructions as List<Mite>, this).clone(history: history + new Contribution(this, FList.fromList(constructions).reverse(), FList.emptyList))
  }

  private static ParsingState baseApply(ParsingState state, List<Mite> update) {
    Set oldXors = state.activeXors

    LinkedHashSet<Mite> toAsk = state.visibleMites.values().flatten() as LinkedHashSet
    LinkedHashSet<Mite> fullUpdate = update as LinkedHashSet
    for (Mite mite in toAsk) {
      fullUpdate.addAll mite.cxt.enrichAction(mite, update, state)
    }
    assert fullUpdate
    state = state.addCxt(new Node(fullUpdate as List<Mite>, Collections.emptySet(), state.node, state))

    LinkedHashSet<Mite> preferred = Util.intersect(state.miteList, fullUpdate)
    def newActive = suggestActive(state, preferred)
    state = state.activate(newActive)

    for (cxt in state.visibleMites.keySet()) {
      if (!(cxt in state.visibleMites)) continue

      List<Mite> toCheck = (fullUpdate as List<Mite>).findAll { it.cxt == cxt }
      def last = state.visibleMites[cxt].reverse()[0]
      if (last) {
        toCheck << last
      }

      for (toAdd in toCheck.reverse()) {
        if (!(toAdd in state.active)) {
          state = tryAlternative(state, toAdd, oldXors)
        }
      }
    }

    return state.clone(currentGeneration:state.currentGeneration + 1)
  }

  private static ParsingState tryAlternative(ParsingState state, Mite toAdd, Set oldXors) {
    def anotherActive = suggestActive(state, [toAdd])
    def alternative = state.activate(anotherActive)
    try {
      if (alternative.dominates(state, oldXors)) {
        return alternative
      }
    } catch (Throwable e) {
      println alternative.chart.presentable() + "\n\n"
      println alternative.presentable() + "\n\n"
      throw e
    }
    return state
  }

  private static LinkedHashSet<Mite> suggestActive(ParsingState state, Collection<Mite> updated) {
    Set<Mite> checked = []
    LinkedHashSet<Mite> newActive = []

    LinkedHashSet<Mite> preferred = rearrangeUpdatedMites(state, updated)
    while (preferred) {
      Mite mite = preferred.iterator().next()
      preferred.remove(mite)
      if (!checked.add(mite)) continue

      if (!mite.findContradictors(newActive)) {
        newActive << mite
      } else {
        for (contr in mite.findContradictors(preferred)) {
          if (checked.add(contr) && !contr.findContradictors(newActive)) {
            preferred.remove(contr)
            newActive << contr
          }
        }
      }
    }

    return newActive
  }

  private static LinkedHashSet<Mite> rearrangeUpdatedMites(ParsingState state, Collection<Mite> updated) {
    Collection<Mite> all = state.miteList
    LinkedHashSet<Mite> preferred = []

    LinkedHashSet<Mite> oldActive = []
    oldActive.addAll(state.active)
    oldActive.addAll(state.byXor.values())
    oldActive.retainAll(all)

    for (mite in oldActive) {
      preferred.addAll(updated.findAll { mite.isPartOf(it) })
    }

    LinkedHashSet<Mite> oldMerged = Util.intersect(all, oldActive).findAll { !it.atom }
    List<Mite> newMerged = (updated as List<Mite>).findAll { !it.atom }
    preferred.addAll(newMerged.findAll { !it.findContradictors(oldMerged) })

    for (mite in oldMerged) {
      preferred.addAll(Util.minus(newMerged, mite.findContradictors(newMerged)))
    }
    preferred.addAll(updated)
    preferred.addAll(oldMerged)

    preferred.addAll(all.findAll { !it.atom })
    preferred.addAll(state.active)
    preferred.addAll(all)
    return Util.intersect(preferred, all)
  }

  private ParsingState activate(LinkedHashSet<Mite> newActive) {
    def toRemove = new LinkedHashSet<Mite>()

    LinkedHashMap<Object, Mite> newByXor = [:] + byXor
    for (mite in newActive) {
      allXors(mite).each {
        def old = byXor[it]
        if (old && old != mite && newByXor[it]) {
          toRemove << old
          allXors(old).each {
            assert newByXor.remove(it) == old : "\n $old\n $it\n $byXor"
          }
        }
        newByXor[it] = mite
      }
    }

    def all = new LinkedHashSet<Mite>(node.ownMites)
    all.addAll(miteList)
    LinkedHashSet<Mite> toApply = all.findAll { it in newActive && !(it in active) }
    toApply.addAll newActive

    def state = clone(active: newActive, byXor:newByXor)
    state = state.undoChanges(toRemove)
    state = state.clone(chart:addNewUnifications(state, toApply))

    boolean changed = true
    while (changed) {
      changed = false
      for (mite in toApply) {
        if (mite in state.active && mite.contents && mite.cxt.isExecutable([mite])) {
          def prev = state
          state = prev.doApply(mite)
          if (prev.chart != state.chart) {
            changed = true
            break
          }
        }
      }
    }
    state
  }

  private Set allXors(Mite mite) {
    Set xor = mite.contents.xor
    xor ? mite.primaries + xor : mite.primaries
  }

  private static Chart addNewUnifications(ParsingState state, LinkedHashSet<Mite> toApply) {
    def ch = state.chart
    for (mite in toApply) {
      ch = ch.startMeta(mite)
      for (pair in mite.unifications) {
        ch = ch.addUnificationConstraint(pair.first.base, pair.second.base)
      }
      ch = ch.finishMeta(mite)
    }
    return ch
  }

  private ParsingState undoChanges(Collection<Mite> toRemove) {
    ParsingState state = this
    for (mite in toRemove) {
      state = state.clone(chart:state.chart.removeDifference(mite))
    }
    return state
  }

  private Set getActiveXors() { new LinkedHashSet(active.collect { it.contents.xor ?: [] }.flatten()) }
  private Collection getUnsatisfiedDaughters() { return active.findAll { it.missingHead } }

  private boolean dominates(ParsingState other, Set oldXors) {
    int daughterDelta = unsatisfiedDaughters.size() - other.unsatisfiedDaughters.size()
    int xorDelta = Util.minus(oldXors, activeXors).size() - Util.minus(oldXors, other.activeXors).size()
    if (daughterDelta > 0 || xorDelta > 0) {
      return false
    }

    if ((daughterDelta < 0 || xorDelta < 0) &&
        !other.dominatesSemantically(this)) {
      return true
    }

    return dominatesSemantically(other)
  }

  private boolean dominatesSemantically(ParsingState other) {
    def humanActions = ['GO', 'BREAK', 'CAN', 'REMEMBER', 'FORGET']
    def verbs = humanActions + ['COME_SCALARLY', 'fact', 'question']
    for (frame in chart.frames) {
      def alternative = frame.unifiedVar.frame(other.chart)
      if (frame.f('member') && alternative.flatten().every { it.type != null } && !frame.flatten().every { it.type != null }) {
        return false
      }
      if (!frame.type && alternative.type && frame.f('quantifier')?.type) {
        return false
      }
    }
    for (verb in chart.frames.findAll { it.type in verbs }) {
      def alternative = verb.unifiedVar.frame(other.chart)

      if (verb.type in humanActions ||
          verb.type == 'COME_SCALARLY' && verb.f('anchor')?.canBeHuman() && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        boolean meHuman = !verb.f('arg1')?.definitelyNonHuman()
        def otherHuman = !alternative.f('arg1')?.definitelyNonHuman()
        if (meHuman != otherHuman) {
          return meHuman
        }
      }

      if (verb.type == 'COME_SCALARLY' && verb.f('anchor')?.definitelyNonHuman() && verb.f('arg1')?.definitelyNonHuman() && alternative.type == 'GO') {
        return true
      }

      if (verb.type && verb.type != 'fact' && !alternative.type) {
        return true
      }

      if (verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        return true
      }

      if (((Frame) verb?.definedAttributeValue('arg1'))?.definedAttributeValue('type') &&
          !((Frame) alternative?.definedAttributeValue('arg1'))?.definedAttributeValue('type')) {
        return true
      }

      if (verb.type == 'FORGET' && verb.f('arg2') && !alternative.f('arg2')) {
        return true
      }

      if (verb.type == 'question' && alternative.type == 'fact') {
        def controller = alternative.findClauseController()
        if (!controller || controller.type == 'ASK') {
          return true
        }
      }

    }

    return false
  }

  private ParsingState doApply(Mite mite) {
    ParsingState next = clone(currentGeneration:miteGenerations[mite]?:currentGeneration, chart:chart.startMeta(mite))
    next = mite.cxt.action.call(next, mite.contents)
    return next.clone(currentGeneration:currentGeneration, chart:next.chart.finishMeta(mite))
  }


  ParsingState clearConstructions() {
    return inhibit(visibleMites.keySet() as Construction[])
  }

  String presentable() {
    def log = ""
    def mites = visibleMites
    log += " - - uni: " + chart.__unifications.keySet().collect { "${it.iterator().next()}=" + (it as List)[1] }.join(", ") + "\n"
    for (k in mites.keySet()) {
      log += "    $k: " + mites[k].collect {
        (it in active ? '*' : '') +
        new LinkedHashMap(it.contents.reverse()) +
        (it.unifications ? ';' + it.unifications.collect { "<$it.first=$it.second>" }.join("") : '')
      }.join(" ") +"\n"
    }
    return log
  }

}