package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  Map<Construction, Map> constructions = [:]
  Map<Construction, Map> history = [:]

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    constructions = Collections.unmodifiableMap((Map)map.constructions)
    history = Collections.unmodifiableMap((Map)map.history)
  }

  ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, constructions:constructions, history:history]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation, history:[:]) }

  Variable newVariable() {
    new Variable()
  }

  ParsingState assign(Variable var, String property, def value) {
    clone(chart: chart.assign(var, situation, property, value))
  }

  Map getAt(Construction construction) {
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    return addCtx(newArgs, name, init).applyAll(name)
  }

  ParsingState addCtx(Map newArgs, Construction name, Closure init = null) {
    def oldArgs = constructions[name] ?: [:]
    def replace = false
    for (cxt in oldArgs.keySet().intersect(newArgs.keySet())) {
      if (oldArgs[cxt] != newArgs[cxt] && oldArgs[cxt]) {
        replace = true
        oldArgs = [:]
        break
      }
    }

    def args = oldArgs + newArgs
    Closure oldInit = args['init']
    def newInit = init && oldInit ? { ParsingState state -> init(oldInit(state)) } : init ?: oldInit
    args.init = newInit
    def newConstructions = constructions + [(name): Collections.unmodifiableMap(args)]
    return (replace ? inhibit(name) : this).clone(constructions: newConstructions)
  }

  ParsingState inhibit(Construction name) {
    def state = removeConstruction(name)

    def freed = [] as Set
    state.constructions.keySet().each {
      if (contradict(it, name) || contradict(name, it)) {
        freed << it
      }
    }
    return state.applyAll(freed as Construction[])
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name).clone(history: (history + [(name): constructions[name]]))
  }

  private ParsingState removeConstruction(Construction name) {
    def newConstructions = new HashMap(constructions)
    newConstructions.remove(name)
    return clone(constructions: newConstructions)
  }

  ParsingState applyAll(Construction... names) {
    def hanging = [] as Set
    names.each { name1 ->
      names.each { name2 ->
        if (contradict(name1, name2)) {
          hanging << name1
          hanging << name2
        }
      }
    }

    ParsingState result = this
    def others = constructions.keySet() - (names as List)
    for (name1 in names) {
      for (name2 in others) {
        if (contradict(name1, name2) || contradict(name2, name1)) {
          result = result.inhibit(name2)
        }
      }
    }

    for (cxt in names) {
      if (!(cxt in hanging)) {
        def args = constructions[cxt]
        Closure init = args.init ?: noInit
        result = cxt.action.call((ParsingState)init(result), args)
      }

    }
    return result
  }


  ParsingState clearConstructions() {
    return clone(constructions: [:])
  }

  ParsingState restore(Map saved) {
    clone(constructions: saved + this.constructions)
  }

  boolean contradict(Construction name1, Construction name2) {
    if (name1.name == 'nom' && name2.name == 'acc' && this[name1].noun == this[name2].noun && this[name1].noun) {
      return true
    }

    return false
  }
}
