package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final FLinkedMap<Construction, List<Mite>> mites
  final Merger constructions = new Merger()
  private final FLinkedMap<Construction, List<Pair<Chart, Chart>>> changes
  final FList<Contribution> history
  final Set<Mite> active

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(), mites: FLinkedMap.emptyMap, changes: FLinkedMap.emptyMap, history: FList.emptyList, active: Collections.emptySet())
  }

  ParsingState(Map map) {
    chart = map.chart
    changes = map.changes
    situation = map.situation
    mites = map.mites
    history = map.history
    active = Collections.unmodifiableSet((Set)map.active)
  }
  
  class Merger {
    Map getAt(Construction c) {
      Map value = [:]
      def allMites = mites[c]
      if (!allMites) {
        return value
      }

      for (Mite mite in Util.intersect(active, allMites)) {
        value = unify(value, mite.contents)
      }
      for (part in allMites.reverse()) {
        if (!overwrites(value, part.contents)) {
          value = unify(value, part.contents)
        }
      }
      value
    }
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, mites:mites, history:history, active:active, changes:changes]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign((Variable)var, situation, property, value))
  }
  
  Map getAt(Construction construction) {
    def mite = nextInterceptor(null)
    if (mite) {
      def interceptor = (Interceptor) mite.contents.interceptor
      def args = interceptor.getArgs(construction, this)
      if (args != null) {
        return args
      }
      
    }
    
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return false
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && arg != 'xor' && before[arg] != newArgs[arg] && before[arg] != null) {
        return true
      }
    }
    return false
  }

  ParsingState addCxt(Mite mite) {
    return clone(mites: mites + [(mite.cxt): (mites[mite.cxt] ?: []) + mite])
  }

  private static Map unify(Map oldArgs, Map newArgs) {
    def args = new HashMap()
    if (oldArgs) args.putAll(oldArgs)
    if (newArgs) args.putAll(newArgs)

    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args.init = merged
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args.xor = xor
    }

    return args
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor ?: Collections.emptySet()
    Set xor2 = newArgs?.xor ?: Collections.emptySet()
    if (!xor1 && !xor2) {
      return null
    }

    def xor = new HashSet()
    xor.addAll xor1
    xor.addAll xor2
    return xor
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(mites.keySet())

    Map<Construction, Map> freed = freedByInhibition(toRemove)

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

    return (freed ? state.apply(freed) : state).clone(history: history + new Contribution(this, FLinkedMap.emptyMap, FList.fromList(cxts as List)))
  }

  private Map<Construction, Map> freedByInhibition(Set<Construction> toRemove) {
    LinkedHashSet<Mite> mitesToRemove = toRemove.collect { mites[it] }.flatten() as LinkedHashSet
    LinkedHashSet<Mite> mitesRemaining = ((mites.keySet() as LinkedHashSet) - toRemove).collect { Construction it -> mites[it] }.flatten() as LinkedHashSet
    LinkedHashSet<Mite> contradictors = mitesToRemove.collect { it.findContradictors(mitesRemaining) }.flatten() as LinkedHashSet

    Map<Construction, Map> freed = [:]
    for (c in contradictors) {
      freed[c.cxt] = [:]
    }
    return freed
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    return clone(mites: mites.removeKey(name), active: active - (mites[name] ?: []), changes:changes.removeKey(name))
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private Mite nextInterceptor(Construction start) {
    def cs = mites.keyList()
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = mites[cxt].reverse().find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  private Function2<Map<Construction, Map>, ParsingState, ParsingState> nextApplier(Construction start) {
    def interceptor = nextInterceptor(start)
    if (interceptor) {
      return { c, s -> ((Interceptor) interceptor.contents.interceptor).intercept(c, s, { c1, s1 ->
        s1.nextApplier(interceptor.cxt).call(c1, s1)
      }) }
    }
    return { c, s -> baseApply(s, c, true) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    def applier = nextApplier(null)
    applier(constructions, this).clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions).reverse(), FList.emptyList))
  }

  private static ParsingState baseApply(ParsingState state, Map<Construction, Map> update, boolean tryAlternatives) {
    List<Mite> newMites = []
    for (c in update.keySet()) {
      if (update[c] && !state.mites[c]?.find { unify(it.contents, update[c]) == it.contents }) {
        newMites << new Mite(update[c], c)
      }
    }
    
    for (c in newMites.reverse()) {
      state = state.addCxt(c)
    }
    
    Map<Mite, LinkedHashSet<ParsingState.Group>> groups = state.buildGroups()
    for (mite in newMites) {
      groups[mite].each { it.isNew = true }
    }

    def newActive = state.balance(groups, allGroups(newMites, groups) as List, state.active as LinkedHashSet, [])
    assert newActive != null : 'cannot balance'
    state = state.activate(newActive)

    for (cxt in state.mites.keySet()) {
      List<Mite> toAdd = collectNonContradicting(state, cxt)
      if (toAdd) {
        newActive = calcAlternative(state, toAdd, groups)
        if (newActive) {
          def alternative = state.activate(newActive)
          if (alternative.dominates(state)) {
            state = alternative
          }
        }
      }
    }

    state
  }

  private static LinkedHashSet<Mite> calcAlternative(ParsingState state, List<Mite> toAdd, Map<Mite, LinkedHashSet<ParsingState.Group>> groups) {
    LinkedHashSet<Mite> newActive = state.active as LinkedHashSet
    def cxtContradictors = toAdd.collect { it.findContradictors(newActive) }.flatten().collect { Mite m -> m.cxt } as LinkedHashSet<Construction>
    def contradictors = cxtContradictors.collect { state.mites[it].reverse() }.flatten() as LinkedHashSet<Mite>
    return state.balance(groups, allGroups(contradictors, groups) as List, newActive - contradictors + toAdd as LinkedHashSet, [])
  }

  private static List<Mite> collectNonContradicting(ParsingState state, Construction cxt) {
    def currentActive = Util.intersect(state.active, state.mites[cxt])
    List<Mite> toAdd = []
    for (mite in state.mites[cxt].reverse()) {
      if (!(mite in currentActive) && !mite.findContradictors(currentActive)) {
        currentActive << mite
        toAdd << mite
      }
    }
    return toAdd
  }

  private Map<Mite, LinkedHashSet<ParsingState.Group>> buildGroups() {
    Map<Mite, LinkedHashSet<Group>> groups = [:]
    Map<Object, Group> members = [:]
    for (Mite mite in mites.values().flatten()) {
      Collection<Object> xor = mite.contents.xor ?: [new Object()] //todo alex inline
      for (x in xor) {
        if (!members[x]) members[x] = new Group()
        members[x].members << mite
      }
      groups[mite] = new LinkedHashSet(xor.collect { members[it] })
    }
    return groups
  }

  private static LinkedHashSet<Group> allGroups(Collection<Mite> newMites, Map<Mite, LinkedHashSet<Group>> groups) {
    return newMites.collect { 
      LinkedHashSet<ParsingState.Group> g = groups[it]
      if (!g) {
        Group group = new Group()
        group.members << it
        g = groups[it] = [group] as LinkedHashSet
      }
      g
    }.flatten() as LinkedHashSet
  }

  private ParsingState activate(LinkedHashSet<Mite> newActive) {
    def toRemove = new LinkedHashSet<Mite>(active)
    toRemove.removeAll(newActive)
    def toApply = new LinkedHashSet<Mite>(newActive)
    toApply.removeAll(active)
    
    def state = clone(active: newActive)
    for (mite in toRemove) {
      if (mite.findContradictors(toApply).find { mite.cxt != it.cxt }) {
        state = state.undoChanges(mite.cxt).doApply(mite.cxt)
      }
    }
    for (mite in toApply) {
      state = state.doApply(mite.cxt)
    }
    state
  }
  
  private static class Group {
    List<Mite> members = []
    boolean isNew

    @Override
    String toString() {
      return members.toString()
    }

  }

  private LinkedHashSet<Mite> balance(Map<Mite, LinkedHashSet<Group>> groups, List<Group> changed, LinkedHashSet<Mite> result, Set<Group> visited) {
    Set<Group> easy = easyBalance(changed, result)

    if (easy) {
      changed = new ArrayList<Group>(changed)
      changed.removeAll(easy)
    }

    for (i in 0..<changed.size()) {
      def g = changed[i]
      if (Util.intersects(result, g.members)) {
        continue
      }

      List<Group> rest = i == changed.size() - 1 ? [] : changed[i + 1..<changed.size()]
      LinkedHashSet<Mite> sortedMembers = []
      sortedMembers.addAll g.members.findAll { Mite mite -> result.find { it.cxt == mite.cxt } }
      sortedMembers.addAll g.members

      for (mite in sortedMembers) {
        List<Mite> contradictors = mite.findContradictors(result)
        LinkedHashSet<Group> touchedGroups = allGroups(contradictors, groups)
        if (!Util.intersects(visited, touchedGroups)) {
          LinkedHashSet modified = result - contradictors + mite as LinkedHashSet
          def inner = balance(groups, rest + touchedGroups as List, modified, visited + changed[0..i] as Set)
          if (inner != null) {
            return inner
          }
        }
      }

      if (g.isNew && g.members.size() == 1) {
        def mite = g.members[0]
        List<Mite> contradictors = mite.findContradictors(result)
        LinkedHashSet bigger = result - contradictors + mite as LinkedHashSet
        def inner = balance(groups, rest, bigger, visited + changed[0..i] as Set)
        if (inner != null) {
          return inner
        }
      }

      return null
    }

    return result
  }

  private Set<Group> easyBalance(List<ParsingState.Group> changed, LinkedHashSet<Mite> result) {
    Set<Group> easy = []
    for (g in changed) {
      if (Util.intersects(result, g.members)) {
        easy << g
      } else {
        LinkedHashSet<Mite> sortedMembers = []
        sortedMembers.addAll g.members.findAll { Mite _mite -> result.find { it.cxt == _mite.cxt } }
        sortedMembers.addAll g.members
        for (mite in sortedMembers) {
          if (!mite.findContradictors(result)) {
            easy << g
            result << mite
            break
          }
        }
      }
    }
    easy
  }

  private ParsingState undoChanges(Construction cxt) {
    List<Pair<Chart, Chart>> diffList = changes[cxt] ?: []
    def newChart = diffList.foldLeft(chart) { Pair<Chart, Chart> diff, Chart ch -> ch.removeDifference(diff) }
    return clone(changes: changes.removeKey(cxt), chart: newChart)
  }

  private boolean dominates(ParsingState other) {
    def theirActiveCxts = (other.active.collect { it.cxt } as Set).size()
    int myActiveCxts = (active.collect { it.cxt } as Set).size()
    if (theirActiveCxts > myActiveCxts || theirActiveCxts == myActiveCxts && other.active.size() < active.size()) {
      return true
    }

    for (verb in chart.frames.findAll { it.type in ['GO', 'BREAK', 'CAN'] }) {
      def alternative = verb.var.frame(other.chart)
      if (!alternative) continue

      if (!alternative.f('arg1')?.canBeHuman() && verb.f('arg1')?.canBeHuman()) {
        return true
      }

      if (verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        return true
      }
    }
    
    return false
  }

  private ParsingState doApply(Construction cxt) {
    LinkedHashSet<Mite> mites = Util.intersect(active, mites[cxt])
    Map args = mites.foldLeft([:]) { Mite mite, Map merge -> unify(merge, mite.contents) }

    Closure init = args.init
    args.remove('init')
    if (!args) {
      return this
    }

    def before = chart
    
    def next = init ? (ParsingState)init(this) : this
    next = cxt.action.call(next, args)
    if (before != next.chart) {
      next = next.clone(changes: changes + [(cxt):(changes[cxt] ?: []) + new Pair(before, next.chart)])
    }
    return next
  }


  ParsingState clearConstructions() {
    return clone(mites: FLinkedMap.emptyMap, active:Collections.emptySet(), changes:FLinkedMap.emptyMap)
  }

  ParsingState restore(ParsingState saved) {
    clone(mites: saved.mites + this.mites, active:saved.active + active, changes:saved.changes + this.changes)
  }

}