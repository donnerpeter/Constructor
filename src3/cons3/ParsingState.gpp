package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final FLinkedMap<Construction, List<Mite>> _constructions
  final FLinkedMap<Construction, Map> constructions
  final FList<Contribution> history
  final FList<Construction> active

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(), constructions: FLinkedMap.emptyMap, history: FList.emptyList, active: FList.emptyList)
  }

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    _constructions = map.constructions
    history = map.history
    active = map.active

    FLinkedMap<Construction, Map> merged = FLinkedMap.emptyMap
    for (c in _constructions.keySet()) {
      Map value = [:]
      for (part in _constructions[c]) {
        value = unify(value, part.contents)
      }
      merged = merged.putValue(c, value)
    }
    
    constructions = merged
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, constructions:_constructions, history:history, active:active]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign((Variable)var, situation, property, value))
  }
  
  Map getAt(Construction construction) {
    def mite = nextInterceptor(null)
    if (mite) {
      def interceptor = (Interceptor) mite.contents.interceptor
      def args = interceptor.getArgs(construction, this)
      if (args != null) {
        return args
      }
      
    }
    
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return true
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && arg != 'xor' && before[arg] != newArgs[arg] && before[arg] != null) {
        return true
      }
    }
    return false
  }

  ParsingState addCxt(Mite mite) {
    return clone(constructions: _constructions + [(mite.cxt): (_constructions[mite.cxt] ?: []) + mite])
  }

  static Map unify(Map oldArgs, Map newArgs) {
    def args = oldArgs ? oldArgs + newArgs : newArgs
    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args += [init:merged]
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args += [xor:xor]
    }

    return Collections.unmodifiableMap(args)
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor
    Set xor2 = newArgs?.xor
    def xor = (xor1 ?: Collections.emptySet()) + (xor2 ?: Collections.emptySet())
    if (!xor) {
      xor = null
    }
    return xor
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(_constructions.keySet())

    Map<Construction, Map> freed = freedByInhibition(toRemove)

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

    return (freed ? state.apply(freed) : state).clone(history: history + new Contribution(this, FLinkedMap.emptyMap, FList.fromList(cxts as List)))
  }

  Map<Construction, Map> freedByInhibition(Set<Construction> toRemove) {
    LinkedHashSet<Construction> remaining = (_constructions.keySet() as LinkedHashSet) - toRemove

    Map<Construction, Map> freed = [:]
    for (removed in remaining) {
      for (c in toRemove) {
        if (contradict(this[removed], this[c])) {
          freed[removed] = [:]
        }
      }
    }
    return freed
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    return clone(constructions: _constructions.removeKey(name), active: active - name)
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private LinkedHashSet<Construction> findContradictors(Construction c, Set<Construction> among, Map<Construction, Map> values = constructions) {
    return new LinkedHashSet<Construction>(among).findAll { contradict(values[it], values[c]) }
  }

  private Mite nextInterceptor(Construction start) {
    def cs = _constructions.keyList()
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = _constructions[cxt].find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  private Function2<Map<Construction, Map>, ParsingState, ParsingState> nextApplier(Construction start) {
    def interceptor = nextInterceptor(start)
    if (interceptor) {
      return { c, s -> ((Interceptor) interceptor.contents.interceptor).intercept(c, s, { c1, s1 ->
        s1.nextApplier(interceptor.cxt).call(c1, s1)
      }) }
    }
    return { c, s -> s.baseApply(c) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    def applier = nextApplier(null)
    applier(constructions, this).clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions).reverse(), FList.emptyList))
  }

  private ParsingState baseApply(Map<Construction, Map> update) {
    LinkedHashSet<Construction> fresh = []
    LinkedHashSet<Construction> old = []
    LinkedHashSet<Construction> replaced = []
    for (cxt in update.keySet()) {
      if (this._constructions[cxt] != null) {
        if (this._constructions[cxt].any { it.contradicts(new Mite(update[cxt], cxt)) }) {
          replaced << cxt
        } else {
          old << cxt
        }
      } else {
        fresh << cxt
      }
    }

    for (c in old - active) {
      if (findContradictors(c, Util.intersect(old, active))) {
        replaced << c
        old.remove(c)
      }
    }

    def result = this
    LinkedHashSet<Construction> silent = []
    shutUpOrUndo: for (c in Util.intersect(replaced, active)) {
      for (mite in _constructions[c]) {
        def undo = mite.undo(this)
        if (undo) {
          result = result.clone(constructions: _constructions + [(c): _constructions[c] - mite]).addCxt(undo)
          replaced.remove(c)
          old << c
          old << undo.cxt
          continue shutUpOrUndo
        }
      }

      if (!findContradictors(c, _constructions.keySet() - active) && findContradictors(c, update.keySet(), update)) {
        silent << c
        replaced.remove(c)
      }
    }

    def freed = freedByInhibition(replaced)

    for (cxt in replaced) {
      result = result.removeConstruction(cxt)
    }
    for (cxt in (update.keySet() as List<Construction>).reverse()) {
      if (!(cxt in silent)) {
        result = result.addCxt(new Mite(update[cxt], cxt, update))
      }
    }

    LinkedHashSet<Construction> all = result._constructions.keySet() as LinkedHashSet
    LinkedHashSet<Construction> toRemove = ((all - update.keySet()).findAll { result.findContradictors(it, old) } as LinkedHashSet)
    LinkedHashSet<Construction> runCandidates = ((update.keySet() as LinkedHashSet) + freed.keySet() as LinkedHashSet) - toRemove

    old.each {
      LinkedHashSet<Construction> unlucky = result.findContradictors(it, runCandidates - old)
      runCandidates.removeAll(unlucky)
      runCandidates.addAll(unlucky)
    }

    LinkedHashSet<Construction> hanging
    LinkedHashSet<Construction> toApply

    while (true) {
      runCandidates += (all - toRemove - runCandidates).findAll { result.findContradictors(it, toRemove) } as LinkedHashSet
      hanging = runCandidates.findAll { result.findContradictors(it, runCandidates) }
      toApply = runCandidates - hanging
      LinkedHashSet<Construction> newToRemove = (all - toApply).findAll { result.findContradictors(it, toApply) } as LinkedHashSet
      if (toRemove.containsAll(newToRemove)) {
        break
      }

      toRemove += newToRemove
    }

    for (cxt in toRemove) {
      result = result.removeConstruction(cxt)
    }

    for (cxt in toApply) {
      if (result[cxt] != null) {
        result = result.doApply(cxt)
      }
    }


    hanging = Util.intersect(hanging, result.active) + hanging
    result = result.clone(active: result.active.withoutAll(hanging))

    LinkedHashSet<Construction> stillHanging = hanging
    stillHanging = stillHanging.findAll { result.findContradictors(it, stillHanging) }
    while (stillHanging) {
      def next = stillHanging.iterator().next()
      def contradictors = result.findContradictors(next, stillHanging)
      result = result.doApply(next)
      stillHanging = Util.intersect(stillHanging - next - contradictors, result._constructions.keySet())
    }

    return result
  }

  private ParsingState doApply(Construction cxt) {
    def args = constructions[cxt]
    def next = clone(active: active - cxt + cxt)
    
    Closure init = args.init ?: noInit
    args = args - [init:args.init]
    next = (ParsingState)init(next)
    return cxt.action.call(next, args)
  }


  ParsingState clearConstructions() {
    return clone(constructions: FLinkedMap.emptyMap, active:FList.emptyList)
  }

  ParsingState restore(ParsingState saved) {
    clone(constructions: saved._constructions + this._constructions, active:saved.active.prependAll(active))
  }

  private static boolean contradict(Map args1, Map args2) {
    if (args1.is(args2)) return false

    Set xor1 = args1.xor
    Set xor2 = args2.xor
    return xor1 && xor2 && Util.intersect(xor1, xor2)
  }
}