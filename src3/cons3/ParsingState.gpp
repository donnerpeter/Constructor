package cons3

/**
 * @author peter
 */
class ParsingState {
  final Chart chart
  final Situation situation
  final FLinkedMap<Construction, List<Mite>> mites
  final Merger constructions = new Merger()
  final FLinkedMap<Construction, List<Object>> changes
  final FLinkedMap<Mite, Integer> miteGenerations
  final FList<Contribution> history
  final Set<Mite> active
  final Set<Group> groups
  final int currentGeneration

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(), 
            mites: FLinkedMap.emptyMap, changes: FLinkedMap.emptyMap, groups: Collections.emptySet(),
            history: FList.emptyList, active: Collections.emptySet(), currentGeneration:0, miteGenerations:FLinkedMap.emptyMap)
  }

  ParsingState(Map map) {
    chart = map.chart
    changes = map.changes
    situation = map.situation
    mites = map.mites
    history = map.history
    currentGeneration = map.currentGeneration
    assert (map.active instanceof LinkedHashSet) || !(map.active instanceof HashSet)
    assert (map.groups instanceof LinkedHashSet) || !(map.groups instanceof HashSet)
    active = Collections.unmodifiableSet((Set)map.active)
    groups = Collections.unmodifiableSet((Set)map.groups)
    miteGenerations = map.miteGenerations
  }
  
  class Merger {
    Map getAt(Construction c) {
      def allMites = mites[c]
      if (allMites == null) {
        return null
      }

      Map value = [:]
      for (Mite mite in allMites) {
        if (mite in active) {
          value = unify(value, mite.contents)
        }
      }
      if (!value) {
        for (part in allMites.reverse()) {
          if (!overwrites(value, part.contents)) {
            value = unify(value, part.contents)
          }
        }
      }
      value
    }
  }

  ParsingState getBeforeThisChange() {
    if (history.empty) {
      return new ParsingState()
    }
    return history[0].before.apply(history[0])
  }

  ParsingState apply(Contribution contribution) {
    return inhibit(contribution.inhibited as Construction[]).apply(contribution.apps)
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, mites:mites, history:history, active:active, changes:changes, currentGeneration:currentGeneration, groups:groups, miteGenerations:miteGenerations]
    current.putAll(update)
    return new ParsingState(current)
  }

  private Chart updateUnification(Chart chart, Set<Mite> oldActive, Set<Mite> newActive) {
    if (oldActive == newActive) {
      return chart
    }

    LinkedHashSet<Mite> added = (newActive as LinkedHashSet) - oldActive
    LinkedHashSet<Mite> removed = (oldActive as LinkedHashSet) - newActive
    List<Pair<Variable, Variable>> toRemove = findChangedUnificationPairs(removed, oldActive)
    List<Pair<Variable, Variable>> toAdd = findChangedUnificationPairs(added, newActive)
    for (s in toRemove) {
      chart = chart.removeUnificationConstraint(s.first, s.second)
    }
    for (s in toAdd) {
      chart = chart.addUnificationConstraint(s.first, s.second)
    }
    return chart
  }

  private List<Pair<Variable, Variable>> findChangedUnificationPairs(LinkedHashSet<Mite> part, Set<Mite> whole) {
    List<Pair<Variable, Variable>> result = []
    for (mite1 in part) {
      for (mite2 in whole) {
        if (mite1.cxt == mite2.cxt && !mite1.contradicts(mite2)) {
          for (key in mite1.contents.keyList()) {
            def val1 = mite1.contents[key]
            def val2 = mite2.contents[key]
            if (areUnifiableVars(val1, val2)) {
              result << new Pair(((Variable) val1).base, ((Variable) val2).base)
            }
          }
        }
      }
    }
    return result
  }

  private static boolean areUnifiableVars(val1, val2) {
    return val1 != val2 && val1 instanceof Variable && val2 instanceof Variable && (val1.light || val2.light)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign(((Variable)var).base, situation, property, value instanceof Variable ? value.base : value, currentGeneration))
  }
  
  Map getAt(Construction construction) {
    def mite = nextInterceptor(null)
    if (mite) {
      def interceptor = (Interceptor) mite.contents.interceptor
      def args = interceptor.getArgs(construction, this)
      if (args != null) {
        return args
      }
      
    }
    
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name) {
    return apply((name): newArgs)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return false
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg == 'xor') continue

      def val1 = before[arg]
      def val2 = newArgs[arg]
      if (val1 != val2 && val1 != null && !areUnifiableVars(val1, val2)) {
        return true
      }
    }
    return false
  }

  ParsingState addCxt(boolean activate, Mite... mites) {
    def newMiteGenerations = miteGenerations
    LinkedHashMap<Object, Group> members = [:]
    for (mite in mites) {
      newMiteGenerations = newMiteGenerations.putValue(mite, currentGeneration)
      
      Collection<Object> xor = mite.contents.xor ?: [] //todo alex inline
      for (x in xor) {
        if (!members[x]) members[x] = new Group(mite)
        else members[x].members << mite
      }
    }
    def newGroups = new LinkedHashSet<Group>(groups)
    for (g in members.values()) {
      if (g.members.size() > 1) {
        newGroups << g
      }
    }

    FLinkedMap<Construction, List<Mite>> newMites = this.mites
    for (mite in mites.reverse()) {
      newMites = newMites + [(mite.cxt):(newMites[mite.cxt] ?: []) + mite]
    }

    Set<Mite> newActive = active
    if (activate) {
      newActive = (active as LinkedHashSet) + (mites as Set)
    }
    return clone(mites:newMites, groups:newGroups, active:newActive, chart:updateUnification(chart, active, newActive), miteGenerations:newMiteGenerations)
  }

  private static Map unify(Map oldArgs, Map newArgs) {
    def args = new HashMap()
    if (oldArgs) args.putAll(oldArgs)
    if (newArgs) args.putAll(newArgs)

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args.xor = xor
    }

    return args
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor ?: Collections.emptySet()
    Set xor2 = newArgs?.xor ?: Collections.emptySet()
    if (!xor1 && !xor2) {
      return null
    }

    def xor = new LinkedHashSet()
    xor.addAll xor1
    xor.addAll xor2
    return xor
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    LinkedHashSet<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(mites.keySet())

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

    return state.clone(history: history + new Contribution(this, FList.emptyList, FList.fromList(cxts as List)))
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    LinkedHashSet<Mite> newActive = new LinkedHashSet<Mite>(active)
    def toRemove = mites[name] ?: []
    newActive.removeAll(toRemove)
    return clone(mites: mites.removeKey(name), active:newActive, changes:changes.removeKey(name), groups:(groups as LinkedHashSet) - allGroups(toRemove))
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  private Mite nextInterceptor(Construction start) {
    def cs = mites.keyList()
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        def mite = mites[cxt].reverse().find { it.contents.interceptor }
        if (mite) {
          return mite
        }
      }
    }
    return null
  }

  private Function2<List<Mite>, ParsingState, ParsingState> nextApplier(Construction start) {
    def interceptor = nextInterceptor(start)
    if (interceptor) {
      return { c, s -> ((Interceptor) interceptor.contents.interceptor).intercept(c, s, { c1, s1 ->
        s1.nextApplier(interceptor.cxt).call(c1, s1)
      }) }
    }
    return { c, s -> baseApply(s, c, true) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    apply((constructions.keySet() as List<Construction>).collect { it(constructions[it]) } as List)
  }
  ParsingState apply(Mite[] constructions) {
    apply(constructions as List<Mite>)
  }
  ParsingState apply(List<Mite> constructions) {
    if (!constructions) return this

    def applier = nextApplier(null)
    applier(constructions as List<Mite>, this).clone(history: history + new Contribution(this, FList.fromList(constructions).reverse(), FList.emptyList))
  }

  private static ParsingState baseApply(ParsingState state, Collection<Mite> update, boolean tryAlternatives) {
    List<Mite> newMites = []
    for (mite in update) {
      def c = mite.cxt
      if (mite.contents && !state.mites[c]?.find { !it.contradicts(mite) && unify(it.contents, mite.contents) == it.contents }
              || !state.mites[c]) {
        newMites << mite
      }
    }

    state = state.addCxt(false, newMites as Mite[])
    
    def newActive = state.optimizedBalance(state.allGroups(newMites), state.active as LinkedHashSet, [])
    if (newActive == null) {
      println "cannot balance: $update"
      return state
    }
    state = state.activate(newActive)

    for (cxt in state.mites.keySet()) {
      if (!(cxt in state.mites)) continue

      List<Mite> toAdd = collectNonContradicting(state, cxt)
      if (toAdd) {
        newActive = state.calcAlternative(toAdd)
        if (newActive) {
          def alternative = state.activate(newActive)
          if (alternative.dominates(state)) {
            state = alternative
          }
        }
      }
    }

    return state.clone(currentGeneration: state.currentGeneration + 1)
  }

  private LinkedHashSet<Mite> calcAlternative(List<Mite> toAdd) {
    LinkedHashSet<Mite> newActive = active as LinkedHashSet
    def cxtContradictors = toAdd.collect { it.findContradictors(newActive) }.flatten().collect { Mite m -> m.cxt } as LinkedHashSet<Construction>
    def contradictors = cxtContradictors.collect { mites[it].reverse() }.flatten() as LinkedHashSet<Mite>
    LinkedHashSet modified = new LinkedHashSet(newActive)
    modified.removeAll(contradictors)
    modified.addAll(toAdd)
    return optimizedBalance(allGroups(contradictors), modified, [])
  }

  private static List<Mite> collectNonContradicting(ParsingState state, Construction cxt) {
    def mites = state.mites[cxt]
    if (!mites) {
      throw new AssertionError(cxt)
    }
    def currentActive = new LinkedHashSet<Mite>(mites.findAll { it in state.active })
    List<Mite> toAdd = []
    for (mite in mites.reverse()) {
      if (!(mite in currentActive) && !mite.findContradictors(currentActive)) {
        currentActive << mite
        toAdd << mite
      }
    }
    if (!cxt.isExecutable(currentActive)) {
      return null
    }
    return toAdd
  }

  private LinkedHashSet<Group> allGroups(Collection<Mite> mites) {
    return mites.collect { m -> 
      Collection<ParsingState.Group> containingGroups = (groups as LinkedHashSet<Group>).findAll { g -> m in g.members }
      if (!containingGroups) {
        return [new Group(m)]
      }
      return containingGroups
    }.flatten() as LinkedHashSet<Group>
  }

  private ParsingState activate(LinkedHashSet<Mite> newActive) {
    def toRemove = new LinkedHashSet<Mite>(active)
    toRemove.removeAll(newActive)
    def toApply = new LinkedHashSet<Mite>(newActive)
    toApply.removeAll(active)
    
    def state = clone(active: newActive, chart:updateUnification(chart, active, newActive))
    for (mite in toRemove) {
      if (mite.findContradictors(toApply).find { mite.cxt != it.cxt }) {
        state = state.undoChanges(mite.cxt).doApply(mite.cxt)
      }
    }
    for (mite in toApply) {
      if (state.mites[mite.cxt]) {
        state = state.doApply(mite.cxt)
      }
    }
    state
  }
  
  private static class Group {
    final LinkedHashSet<Mite> members = []

    Group(Mite first) {
      this.members << first
    }

    @Override
    String toString() {
      return members.toString()
    }

    LinkedHashSet<Mite> sortedMembers(LinkedHashSet<Mite> preferred) {
      LinkedHashSet<Mite> sortedMembers = []
      sortedMembers.addAll members.findAll { Mite mite -> preferred.find { it.cxt == mite.cxt } }
      sortedMembers.addAll members
      return sortedMembers
    }

  }

  private LinkedHashSet<Mite> optimizedBalance(LinkedHashSet<Group> changed, LinkedHashSet<Mite> result, Set<Group> visited) {
    for (g in changed.findAll { it.members.size() == 1 }) {
      def mite = g.members.iterator().next()
      def contradictors = mite.findContradictors(result)
      result.removeAll(contradictors)
      result << mite
      visited << g
      changed.remove(g)

      for (gc in allGroups(contradictors)) {
        if (gc.members.size() > 1) {
          changed.add(gc)
        }
      }
    }

    return balance(changed as List, result, visited)
  }

  private LinkedHashSet<Mite> balance(List<Group> changed, LinkedHashSet<Mite> result, Set<Group> visited) {
    LinkedHashSet<Group> easy = easyBalance(changed, result)

    if (easy) {
      changed = new ArrayList<Group>(changed)
      changed.removeAll(easy)
    }

    for (i in 0..<changed.size()) {
      def g = changed[i]
      if (Util.intersects(result, g.members)) {
        continue
      }

      List<Group> rest = i == changed.size() - 1 ? [] : changed[i + 1..<changed.size()]

      for (mite in g.sortedMembers(result)) {
        List<Mite> contradictors = mite.findContradictors(result)
        LinkedHashSet<Group> touchedGroups = allGroups(contradictors)
        if (!Util.intersects(visited, touchedGroups)) {
          LinkedHashSet modified = new LinkedHashSet(result)
          modified.removeAll(contradictors)
          modified.add(mite)
          def inner = balance(rest + touchedGroups as List, modified, visited + changed[0..i] as Set)
          if (inner != null) {
            return inner
          }
        }
      }

      return null
    }

    return result
  }

  private LinkedHashSet<Group> easyBalance(List<ParsingState.Group> changed, LinkedHashSet<Mite> result) {
    LinkedHashSet<Group> easy = []
    for (g in changed) {
      if (Util.intersects(result, g.members)) {
        easy << g
      } else {
        for (mite in g.sortedMembers(result)) {
          if (!mite.findContradictors(result)) {
            easy << g
            result << mite
            break
          }
        }
      }
    }
    easy
  }

  private ParsingState undoChanges(Construction cxt) {
    List<Object> diffList = changes[cxt] ?: []
    def newChart = diffList.foldLeft(chart) { diff, Chart ch -> ch.removeDifference(diff) }
    return clone(changes: changes.removeKey(cxt), chart: newChart)
  }

  private boolean dominates(ParsingState other) {
    def theirActiveCxts = (other.active.collect { it.cxt } as Set).size()
    int myActiveCxts = (active.collect { it.cxt } as Set).size()
    if (theirActiveCxts > myActiveCxts || theirActiveCxts == myActiveCxts && other.active.size() < active.size()) {
      if (!other.dominatesSemantically(this)) {
        return true
      }
    }

    return dominatesSemantically(other)
  }

  private boolean dominatesSemantically(ParsingState other) {
    def humanActions = ['GO', 'BREAK', 'CAN', 'REMEMBER', 'FORGET']
    def verbs = humanActions + ['COME_SCALARLY', 'fact', 'question']
    for (verb in chart.frames.findAll { it.type in verbs }) {
      def alternative = verb.var.frame(other.chart)
      if (!alternative) continue

      if (verb.type in humanActions) {
        boolean meHuman = !verb.f('arg1')?.definitelyNonHuman()
        if (meHuman != !alternative.f('arg1')?.definitelyNonHuman()) {
          return meHuman
        }
      }

      if (verb.type && verb.type != 'fact' && !alternative.type) {
        return true
      }

      if (verb.type == 'GO' && alternative.type == 'COME_SCALARLY' && alternative.f('anchor')?.canBeHuman()) {
        return true
      }

      if (((Frame) verb?.definedAttributeValue('arg1'))?.definedAttributeValue('type') &&
          !((Frame) alternative?.definedAttributeValue('arg1'))?.definedAttributeValue('type')) {
        return true
      }

      if (verb.type == 'FORGET' && verb.f('arg2') && !alternative.f('arg2')) {
        return true
      }

      if (verb.type == 'question' && alternative.type == 'fact' && !alternative.usages('arg2') && !alternative.usages('theme')) {
        return true
      }

    }

    return false
  }

  private ParsingState doApply(Construction cxt) {
    List<Mite> mites = mites[cxt].findAll { it in active }
    if (!cxt.isExecutable(mites)) return this

    Map args = [:]
    int newestGeneration = 0
    for (mite in mites) {
      args = unify(args, mite.contents)
      newestGeneration = Math.max(newestGeneration, miteGenerations[mite])
    }

    if (!args) {
      return this
    }

    def meta = new Object()
    def before = chart

    ParsingState next = clone(currentGeneration:newestGeneration, chart:chart.startMeta(meta))
    next = cxt.action.call(next, args)
    if (before != next.chart) {
      next = next.clone(changes:next.changes + [(cxt):(changes[cxt] ?: []) + meta])
    }
    return next.clone(currentGeneration:currentGeneration, chart:next.chart.finishMeta(meta))
  }


  ParsingState clearConstructions() {
    return inhibit(mites.keyList() as Construction[])
  }

  ParsingState restore(ParsingState saved) {
    LinkedHashSet<Mite> newActive = new LinkedHashSet<Mite>(saved.active)
    newActive.addAll(active)
    LinkedHashSet<Group> newGroups = new LinkedHashSet<ParsingState.Group>(saved.groups)
    newGroups.addAll(groups)
    for (c in saved.mites.keyList()) {
      if (c in this.mites) {
        newActive.removeAll(saved.mites[c])
        newGroups.removeAll(allGroups(saved.mites[c]))
      }
    }
    clone(mites: saved.mites + this.mites, active:newActive, changes:saved.changes + this.changes, groups:newGroups, chart:updateUnification(chart, active, newActive))
  }

}