package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final FLinkedMap<Construction, Map> constructions
  final FList<Contribution> history
  final FList<Construction> active

  ParsingState() {
    this(chart: new Chart(), situation: new Situation(), constructions: FLinkedMap.emptyMap, history: FList.emptyList, active: FList.emptyList)
  }

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    constructions = map.constructions
    history = map.history
    active = map.active
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, constructions:constructions, history:history, active:active]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  Variable newVariable() {
    new Variable()
  }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign((Variable)var, situation, property, value))
  }

  Map getAt(Construction construction) {
    for (Map value in this.constructions.values()) {
      if (value.interceptor != null) {
        def interceptor = (Interceptor) value.interceptor
        def args = interceptor.getArgs(construction, this)
        if (args != null) {
          return args
        }
      }
    }
    
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  static boolean overwrites(Map before, Map newArgs) {
    if (before == null) {
      return true
    }
    for (arg in before.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && arg != 'xor' && before[arg] != newArgs[arg] && before[arg]) {
        return true
      }
    }
    return false
  }

  private ParsingState addCtx(Map newArgs, Construction name) {
    return clone(constructions: constructions + [(name): unify(constructions[name], newArgs)])
  }

  static Map unify(Map oldArgs, Map newArgs) {
    def args = oldArgs ? oldArgs + newArgs : newArgs
    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args += [init:merged]
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args += [xor:xor]
    }

    return Collections.unmodifiableMap(args)
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor
    Set xor2 = newArgs?.xor
    def xor = (xor1 ?: Collections.emptySet()) + (xor2 ?: Collections.emptySet())
    if (!xor) {
      xor = null
    }
    return xor
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    if (!cxts) return this

    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(constructions.keySet())

    Map<Construction, Map> freed = freedByInhibition(toRemove)

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

   return (freed ? state.apply(freed) : state).clone(history: history + new Contribution(this, FLinkedMap.emptyMap, FList.fromList(cxts as List)))
  }

  Map<Construction, Map> freedByInhibition(Set<Construction> toRemove) {
    LinkedHashSet<Construction> remaining = (constructions.keySet() as LinkedHashSet) - toRemove

    Map<Construction, Map> freed = [:]
    for (removed in remaining) {
      for (c in toRemove) {
        if (contradict(this[removed], this[c])) {
          freed[removed] = [:]
        }
      }
    }
    return freed
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    return clone(constructions: constructions.removeKey(name), active: active - name)
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  LinkedHashSet<Construction> findContradictors(Construction c, Set<Construction> among) {
    return new LinkedHashSet<Construction>(among).findAll { contradict(constructions[it], constructions[c]) }
  }

  Function2<Map<Construction, Map>, ParsingState, ParsingState> getApplier() {
    return nextApplier(null)
  }

  private Function2<Map<Construction, Map>, ParsingState, ParsingState> nextApplier(Construction start) {
    def cs = constructions.keyList()
    def index = cs.indexOf(start)
    if (index >= 0 || !start) {
      def tail = cs.subList(index + 1, cs.size())
      for (cxt in tail) {
        if (constructions[cxt].interceptor != null) {
          def interceptor = (Interceptor) constructions[cxt].interceptor
          return { c, s -> interceptor.intercept(c, s, { c1, s1 ->
            s1.nextApplier(cxt).call(c1, s1)
          }) }
        }
      }
    }
    return { c, s -> s.baseApply(c) }
  }

  ParsingState apply(Map<Construction, Map> constructions) {
    applier(constructions, this)
  }

  private ParsingState baseApply(Map<Construction, Map> constructions) {
    LinkedHashSet<Construction> fresh = []
    LinkedHashSet<Construction> old = []
    LinkedHashSet<Construction> replaced = []
    for (cxt in constructions.keySet()) {
      if (this.constructions[cxt] != null) {
        if (overwrites(this.constructions[cxt], constructions[cxt])) {
          replaced << cxt
        } else {
          old << cxt
        }
      } else {
        fresh << cxt
      }
    }

    def result = this
    LinkedHashSet<Construction> toRestore = replaced.findAll { findContradictors(it, old) }
    for (c in toRestore) {
      def prev = history.find { it.before[c] != result[c] }
      if (prev && !overwrites(prev.before.constructions[c], constructions[c])) {
        replaced.remove(c)
        result = result.removeConstruction(c).addCtx(prev.before[c], c)
        old << c
      }
    }

    def freed = result.freedByInhibition(replaced)

    for (cxt in replaced) {
      result = result.removeConstruction(cxt)
    }
    for (cxt in (constructions.keySet() as List<Construction>).reverse()) {
      result = result.addCtx(constructions[cxt], cxt)
    }

    LinkedHashSet<Construction> all = result.constructions.keySet() as LinkedHashSet
    LinkedHashSet<Construction> toRemove = ((all - constructions.keySet()).findAll { result.findContradictors(it, old) } as LinkedHashSet)
    LinkedHashSet<Construction> runCandidates = ((constructions.keySet() as LinkedHashSet) + freed.keySet() as LinkedHashSet) - toRemove

    old.each {
      LinkedHashSet<Construction> unlucky = result.findContradictors(it, runCandidates - old)
      runCandidates.removeAll(unlucky)
      runCandidates.addAll(unlucky)
    }

    LinkedHashSet<Construction> hanging
    LinkedHashSet<Construction> toApply

    while (true) {
      runCandidates += (all - toRemove - runCandidates).findAll { result.findContradictors(it, toRemove) } as LinkedHashSet
      hanging = runCandidates.findAll { result.findContradictors(it, runCandidates) }
      toApply = runCandidates - hanging
      LinkedHashSet<Construction> newToRemove = (all - toApply).findAll { result.findContradictors(it, toApply) } as LinkedHashSet
      if (toRemove.containsAll(newToRemove)) {
        break
      }

      toRemove += newToRemove
    }

    for (cxt in toRemove) {
      result = result.removeConstruction(cxt)
    }

    for (cxt in toApply) {
      if (result[cxt] != null) {
        result = result.doApply(cxt)
      }
    }


    hanging = Util.intersect(hanging, result.active) + hanging
    result = result.clone(active: result.active.withoutAll(hanging))
    Map<Construction, Map> plausible = [:]
    for (cxt1 in hanging) {
      def alt1 = result.doApply(cxt1)
      if (result.findContradictors(cxt1, result.constructions.keySet()).every { alt1.morePlausible(result.doApply(it)) }) {
        plausible[cxt1] = result[cxt1]
      }
    }

    if (plausible) {
      result = result.apply(plausible)
    }

    LinkedHashSet<Construction> stillHanging = Util.intersect(hanging, result.constructions.keySet()) as LinkedHashSet
    stillHanging = stillHanging.findAll { result.findContradictors(it, stillHanging) }
    while (stillHanging) {
      def next = stillHanging.iterator().next()
      def contradictors = result.findContradictors(next, stillHanging)
      result = result.doApply(next)
      stillHanging = Util.intersect(stillHanging - next - contradictors, result.constructions.keySet())
    }

    return result.clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions).reverse(), FList.emptyList))
  }

  boolean morePlausible(ParsingState than) {
    return false
  }

  ParsingState doApply(Construction cxt) {
    def args = constructions[cxt]
    def next = clone(active: active - cxt + cxt)
    
    Closure init = args.init ?: noInit
    args = args - [init:args.init]
    next = (ParsingState)init(next)
    return cxt.action.call(next, args)
  }


  ParsingState clearConstructions() {
    return clone(constructions: FLinkedMap.emptyMap)
  }

  ParsingState restore(ParsingState saved) {
    clone(constructions: saved.constructions + this.constructions)
  }

  private static boolean contradict(Map args1, Map args2) {
    if (args1.is(args2)) return false

    Set xor1 = args1.xor
    Set xor2 = args2.xor
    return xor1 && xor2 && Util.intersect(xor1, xor2)
  }
}
