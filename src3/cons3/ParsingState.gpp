package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final Map<Construction, Map> constructions
  final FList<Contribution> history

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    constructions = Collections.unmodifiableMap((Map)map.constructions)
    history = map.history
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, constructions:constructions, history:history]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  Variable newVariable() {
    new Variable()
  }

  ParsingState assign(def var, String property, def value) {
    clone(chart: chart.assign((Variable)var, situation, property, value))
  }

  Map getAt(Construction construction) {
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  private boolean overwrites(Construction name, Map newArgs) {
    def oldArgs = constructions[name]
    if (oldArgs == null) {
      return true
    }
    for (arg in oldArgs.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && arg != 'xor' && oldArgs[arg] != newArgs[arg] && oldArgs[arg]) {
        return true
      }
    }
    return false
  }

  private ParsingState addCtx(Map newArgs, Construction name) {
    return clone(constructions: constructions + [(name): unify(constructions[name], newArgs)])
  }

  static Map unify(Map oldArgs, Map newArgs) {
    def args = oldArgs ? oldArgs + newArgs : newArgs
    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args += [init:merged]
    }

    Collection xor = mergeXor(oldArgs, newArgs)
    if (xor) {
      args += [xor:xor]
    }

    return Collections.unmodifiableMap(args)
  }

  static Collection mergeXor(Map oldArgs, Map newArgs) {
    Set xor1 = oldArgs?.xor
    Set xor2 = newArgs?.xor
    def xor = (xor1 ?: Collections.emptySet()) + (xor2 ?: Collections.emptySet())
    if (!xor) {
      xor = null
    }
    return xor
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    Set<Construction> remaining = constructions.keySet() as LinkedHashSet
    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(constructions.keySet())
    remaining.removeAll(toRemove)

    Map<Construction, Map<String, Object>> freed = [:]
    for (removed in remaining) {
      for (c in toRemove) {
        if (contradict(this[removed], this[c])) {
          freed[removed] = [:]
        }
      }
    }

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }

   return freed ? state.apply(freed).clone(history: history + new Contribution(this, FLinkedMap.emptyMap, FList.fromList(cxts as List))) : state
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    def newConstructions = new HashMap(constructions)
    newConstructions.remove(name)
    return clone(constructions: newConstructions)
  }

  ParsingState startMeta(Variable meta) {
    return clone(chart: chart.startMeta(meta))
  }
  ParsingState finishMeta(Variable meta) {
    return clone(chart: chart.finishMeta(meta))
  }

  LinkedHashSet<Construction> findContradictors(Construction c, Set<Construction> among) {
    return (among as LinkedHashSet<Construction>).findAll { contradict(constructions[it], constructions[c]) }
  }

  ParsingState apply(Map<Construction, Map<String, Object>> constructions) {
    LinkedHashSet<Construction> fresh = []
    LinkedHashSet<Construction> old = []
    LinkedHashSet<Construction> replaced = []
    for (cxt in constructions.keySet()) {
      if (this.constructions[cxt] != null) {
        if (overwrites(cxt, constructions[cxt])) {
          replaced << cxt
        } else {
          old << cxt
        }
      } else {
        fresh << cxt
      }
    }
    def result = inhibit(replaced as Construction[])

    for (cxt in constructions.keySet()) {
      result = result.addCtx(constructions[cxt], cxt)
    }

    LinkedHashSet<Construction> all = result.constructions.keySet() as LinkedHashSet
    LinkedHashSet<Construction> toRemove = (fresh + replaced).findAll { result.findContradictors(it, old) }
    LinkedHashSet<Construction> runCandidates = (constructions.keySet() as LinkedHashSet) - toRemove

    LinkedHashSet<Construction> hanging
    LinkedHashSet<Construction> toApply

    while (true) {
      runCandidates += (all - toRemove - runCandidates).findAll { result.findContradictors(it, toRemove) } as LinkedHashSet
      hanging = runCandidates.findAll { result.findContradictors(it, runCandidates) }
      toApply = runCandidates - hanging
      LinkedHashSet<Construction> newToRemove = (all - toApply).findAll { result.findContradictors(it, toApply) } as LinkedHashSet
      if (toRemove.containsAll(newToRemove)) {
        break
      }

      toRemove += newToRemove
    }

    for (cxt in toRemove) {
      result = result.removeConstruction(cxt)
    }

    for (cxt in toApply) {
      if (result[cxt] != null) {
        result = result.doApply(cxt)
      }
    }

    for (cxt1 in hanging) {
      if (result[cxt1] != null) {
        def alt1 = result.apply(cxt1)
        if (result.findContradictors(cxt1, result.constructions.keySet()).every { alt1.morePlausible(result.apply(it)) }) {
          result = alt1
        }
      }
    }

    LinkedHashSet<Construction> stillHanging = Util.intersect(hanging, result.constructions.keySet()) as LinkedHashSet
    stillHanging = stillHanging.findAll { result.findContradictors(it, stillHanging) }
    while (stillHanging) {
      def next = stillHanging.iterator().next()
      result = result.doApply(next)
      stillHanging.remove(next)
      stillHanging -= result.findContradictors(next, stillHanging)
    }

    return result.clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions), FList.emptyList))
  }

  boolean morePlausible(ParsingState than) {
    if (than.chart.frames(than.situation).find { it.type == 'GO' && it.f('arg1')?.type in ['7', '8'] } &&
            !chart.frames(situation).find { it.type == 'GO' && it.f('arg1')?.type in ['7', '8'] }) {
      return true
    }

    Frame comeScalarly = chart.frames(situation).find { it.type == 'COME_SCALARLY' }
    if (comeScalarly && comeScalarly.s('order') && !comeScalarly.var.frame(than.chart)?.type) {
      return true
    }

    return false
  }

  ParsingState doApply(Construction cxt) {
    def args = constructions[cxt]
    Closure init = args.init ?: noInit
    args = args - [init:args.init]
    def next = this
    next = (ParsingState)init(next)
    return cxt.action.call(next, args)
  }


  ParsingState clearConstructions() {
    return clone(constructions: [:])
  }

  ParsingState restore(Map saved) {
    clone(constructions: saved + this.constructions)
  }

  private static boolean contradict(Map args1, Map args2) {
    if (args1.is(args2)) return false

    Set xor1 = args1.xor
    Set xor2 = args2.xor
    return xor1 && xor2 && Util.intersect(xor1, xor2)
  }
}
