package cons3

/**
 * @author peter
 */
class ParsingState {
  static final Closure noInit = { it }

  final Chart chart
  final Situation situation
  final Map<Construction, Map> constructions
  final FList<Contribution> history

  ParsingState(Map map) {
    chart = map.chart
    situation = map.situation
    constructions = Collections.unmodifiableMap((Map)map.constructions)
    history = map.history
  }

  private ParsingState clone(Map update) {
    Map current = [chart:chart, situation:situation, constructions:constructions, history:history]
    current.putAll(update)
    return new ParsingState(current)
  }

  ParsingState withSituation(Situation situation) { clearConstructions().clone(situation:situation) }

  Variable newVariable() {
    new Variable()
  }

  ParsingState assign(Variable var, String property, def value) {
    clone(chart: chart.assign(var, situation, property, value))
  }

  Map getAt(Construction construction) {
    constructions[construction]
  }

  ParsingState apply(Map newArgs = [:], Construction name, Closure init = null) {
    def args = newArgs
    if (!args.init && init) {
      args.init = init
    }
    return apply((name): args)
  }

  private boolean overwrites(Construction name, Map newArgs) {
    def oldArgs = constructions[name]
    if (!oldArgs) {
      return true
    }
    for (arg in oldArgs.keySet().intersect(newArgs.keySet())) {
      if (arg != 'init' && oldArgs[arg] != newArgs[arg] && oldArgs[arg]) {
        return true
      }
    }
    return false
  }

  private ParsingState addCtx(Map newArgs, Construction name) {
    return clone(constructions: constructions + [(name): unify(constructions[name], newArgs)])
  }

  static Map unify(Map oldArgs, Map newArgs) {
    def args = oldArgs ? oldArgs + newArgs : newArgs
    def merged = mergeInits((Closure) oldArgs?.init, (Closure) newArgs.init)
    if (merged) {
      args += [init:merged]
    }
    return Collections.unmodifiableMap(args)
  }

  static Closure mergeInits(Closure oldInit, Closure newInit) {
    return newInit && oldInit ? { ParsingState state -> newInit(oldInit(state)) } : newInit ?: oldInit
  }

  ParsingState inhibit(Construction... cxts) {
    Set<Construction> remaining = constructions.keySet() as LinkedHashSet
    Set<Construction> toRemove = cxts as LinkedHashSet
    toRemove.retainAll(constructions.keySet())
    remaining.removeAll(toRemove)

    def freed = [] as LinkedHashSet
    remaining.each {
      for (c in toRemove) {
        if (contradict(it, c) || contradict(c, it)) {
          freed << it
        }
      }
    }

    def state = this
    for (c in toRemove) {
      state = state.removeConstruction(c)
    }
   return state.applyAll(freed)
  }

  ParsingState satisfied(Construction name) {
    return removeConstruction(name)
  }

  private ParsingState removeConstruction(Construction name) {
    def newConstructions = new HashMap(constructions)
    newConstructions.remove(name)
    return clone(constructions: newConstructions)
  }

  ParsingState apply(Map<Construction, Map<String, Object>> constructions) {
    Set<Construction> fresh = [] as LinkedHashSet
    Set<Construction> old = [] as LinkedHashSet
    Set<Construction> replaced = [] as LinkedHashSet
    for (cxt in constructions.keySet()) {
      if (this.constructions[cxt]) {
        if (overwrites(cxt, constructions[cxt])) {
          replaced << cxt
        } else {
          old << cxt
        }
      } else {
        fresh << cxt
      }
    }
    def result = clone(history: history + new Contribution(this, FLinkedMap.fromMap(constructions))).inhibit(replaced as Construction[])

    for (cxt in constructions.keySet()) {
      result = result.addCtx(constructions[cxt], cxt)
    }

    Set<Construction> bornDead = [] as LinkedHashSet
    for (cxt1 in (fresh + replaced)) {
      for (cxt2 in old) {
        if (result.contradict(cxt1, cxt2) || result.contradict(cxt2, cxt1)) {
          bornDead << cxt1
        }
      }
    }
    result = result.inhibit(bornDead as Construction[])

    def cs = constructions.keySet() as LinkedHashSet
    cs.retainAll(result.constructions.keySet())
    result = result.applyAll(cs)
    return result
  }

  private ParsingState applyAll(LinkedHashSet<Construction> names) {
    Set<Construction> hanging = [] as LinkedHashSet
    names.each { name1 ->
      names.each { name2 ->
        if (contradict(name1, name2)) {
          hanging << name1
          hanging << name2
        }
      }
    }

    ParsingState result = this
    LinkedHashSet<Construction> others = (constructions.keySet() as LinkedHashSet) - names
    for (name1 in names) {
      for (name2 in others) {
        if (contradict(name1, name2) || contradict(name2, name1)) {
          result = result.inhibit(name2)
        }
      }
    }

    for (cxt in names) {
      if (!(cxt in hanging)) {
        if (result[cxt]) {
          result = result.doApply(cxt)
        }
      }
    }

    for (cxt1 in hanging) {
      for (cxt2 in hanging) {
        if (cxt1 != cxt2 && result[cxt1] && result[cxt2]) {
          def alt1 = result.apply(cxt1)
          def alt2 = result.apply(cxt2)
          if (morePlausible(alt1, alt2)) {
            result = result.inhibit(cxt2)
          }
          else if (morePlausible(alt2, alt1)) {
            result = result.inhibit(cxt1)
          }
        }
      }
    }

    return result
  }

  boolean isHuman(Frame f) {
    return !f.s('number')
  }

  boolean morePlausible(ParsingState st1, ParsingState st2) {
    def remember2 = st2.chart.frames(st2.situation).find { it.type in ['REMEMBER', 'FORGET'] }
    def remember1 = st1.chart.frames(st1.situation).find { it.type in ['REMEMBER', 'FORGET'] }
    if (remember2 && remember1 && !remember2.conjArg('arg1').every { isHuman(it) } && remember1.conjArg('arg1').every { isHuman(it) }) {
      return true
    }

    if (st2.constructions.keySet().find { it.name == 'nom' } && st2.chart.frames(st2.situation).find { it.type in ['COME_SCALARLY', 'FORGET'] }?.f('arg1')) {
      return true //todo prohibit two nom's in one situation
    }

    return false
  }

  ParsingState doApply(Construction cxt) {
    def args = constructions[cxt]
    Closure init = args.init ?: noInit
    args = args - [init:args.init]
    def next = this
    next = (ParsingState)init(next)
    return cxt.action.call(next, args)
  }


  ParsingState clearConstructions() {
    return clone(constructions: [:])
  }

  ParsingState restore(Map saved) {
    clone(constructions: saved + this.constructions)
  }

  boolean contradict(Construction c1, Construction c2) {
    assert this[c1] != null : c1
    assert this[c2] != null : c2
    if (c1.name in ['nom', 'prep', 'vPrep', 'gen'] && c2.name in ['acc', 'vAcc'] && this[c1].noun && this[c2].noun) {
      if (this[c1].noun == this[c2].noun) return true

      Map base1 = this[c1].base
      Map base2 = this[c2].base
      if (base1?.noun) {
        return base1.noun in [this[c2].noun, base2?.noun]
      }
      if (base2?.noun) {
        return base2.noun in [this[c1].noun, base1?.noun]
      }
      return false
    }
    if (c1.name == 'summerGarden' && c2.name == 'adjective') {
      return true
    }
    if (c1.name == 'comeScalarly' && c2.name in ['advObj', 'relTime'] && this[c1].id == this[c2].id) {
      return true
    }


    return false
  }
}
