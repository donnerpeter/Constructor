package cons3

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Preposition extends Interceptor {

  static final ArrayList<Construction> cases = [nom, acc, gen, dat, instr, prep]

  @Override
  Map<Construction, List<Mite>> getExtensionState(Mite mite, Node current) {
    Map<Construction, List<Mite>> result = [:] + super.getExtensionState(mite, current)
    Variable noun = mite.contents.noun
    if (!noun || mite.contents.hasNoun) {
      return result
    }

    Tokens t = new Tokens()
    if (mite.contents.prep == 'с') {
      result[sInstr] = sInstr(noun:noun, xor:t.ac).unifyWherePossible(result[sInstr] ?: [], false, true)
      result[sGen] = sGen(noun:noun, xor:t.ab).unifyWherePossible(result[sGen] ?: [], false, true)
      result[instr] = [instr(noun:noun.lightVar, xor:t.bd)]
      result[gen] = [gen(noun:noun.lightVar, xor:t.cd)]
    }
    return result
  }

  private Construction transformCase(ParsingState state, Construction caze) {
    def p = state[preposition].prep

    if (p == 'posle' && caze == gen) return posleGen
    if (p == 'ranshe' && caze == gen) return ransheGen
    if (p == 'по' && caze == dat) return poDat
    if (p == 'в' && caze == prep) return vPrep
    if (p == 'в' && caze == acc) return vAcc
    if (p == 'с' && caze == gen) return sGen
    if (p == 'с' && caze == instr) return sInstr
    if (p == 'до' && caze == gen) return doGen
    if (p == 'к' && caze == dat) return kDat
    if (p == 'о' && caze == prep) return oPrep
    if (p == 'из' && caze == gen) return izGen
    if (p == 'на' && caze == prep) return naPrep
    if (p == 'от' && caze == gen) return otGen
    if (p == 'у' && caze == gen) return uGen
    return caze
  }

  Collection<Mite> enrichUpdate(Mite prep, List<Mite> contribution, ParsingState state) {
    List<Mite> result = []
    for (mite in contribution) {
      def c = mite.cxt
      if (c in cases && !mite.contents.head) {
        def newC = transformCase(state, c)
        if (newC != c) {
          result.addAll(new Mite(mite.contents, newC).unifyWherePossible(state))
        }
      }
    }
    if (!result.empty && !prep.contents.hasNoun) {
      result << prep.unify(new Mite(preposition, hasNoun:true))
    }
    return result
  }

}

