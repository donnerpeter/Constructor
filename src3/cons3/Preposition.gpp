package cons3

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Preposition implements Interceptor {

  static final ArrayList<Construction> cases = [nom, acc, gen, dat, instr, prep]

  private Construction transformCase(ParsingState state, Construction caze) {
    def p = state[preposition].prep

    if (p == 'posle' && caze == gen) return posleGen
    if (p == 'ranshe' && caze == gen) return ransheGen
    if (p == 'по' && caze == dat) return poDat
    if (p == 'в' && caze == prep) return vPrep
    if (p == 'в' && caze == acc) return vAcc
    if (p == 'с' && caze == gen) return sGen
    if (p == 'с' && caze == instr) return sInstr
    if (p == 'до' && caze == gen) return doGen
    if (p == 'к' && caze == dat) return kDat
    if (p == 'о' && caze == prep) return oPrep
    if (p == 'из' && caze == gen) return izGen
    if (p == 'на' && caze == prep) return naPrep
    if (p == 'от' && caze == gen) return otGen
    return caze
  }

  ParsingState intercept(List<Mite> contribution, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    Update update = new Update()
    for (mite in contribution) {
      def c = mite.cxt
      if (c == nom) continue

      def newC = c in cases && !mite.contents.head ? transformCase(state, c) : c
      update = update.addCxt(mite.contents, newC)
      if (newC != c && ((Variable) mite.contents.noun)?.hard) {
        state = state.inhibit(preposition)
      }
    }
    return base(update.mites.reverse(), state)
  }

}

