package cons3

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Preposition implements Interceptor {

  static final ArrayList<Construction> cases = [nom, acc, gen, dat, instr, prep]

  private Construction transformCase(ParsingState state, Construction caze) {
    if (state.constructions[preposition]?.hasNoun) {
      return caze
    }

    def p = state.constructions[preposition]?.prep

    if (p == 'posle' && caze == gen) return posleGen
    if (p == 'ranshe' && caze == gen) return ransheGen
    if (p == 'по' && caze == dat) return poDat
    if (p == 'в' && caze == prep) return vPrep
    if (p == 'в' && caze == acc) return vAcc
    if (p == 'с' && caze == gen) return sGen
    if (p == 'с' && caze == instr) return sInstr
    if (p == 'до' && caze == gen) return doGen
    if (p == 'к' && caze == dat) return kDat
    if (p == 'о' && caze == prep) return oPrep
    if (p == 'из' && caze == gen) return izGen
    if (p == 'на' && caze == prep) return naPrep
    if (p == 'от' && caze == gen) return otGen
    return caze
  }

  ParsingState intercept(List<Mite> contribution, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    Update update = new Update()
    for (mite in contribution) {
      def c = mite.cxt
      if (c == nom && !state[preposition].hasNoun) continue

      def replace = c in cases && !mite.contents.head
      def newC = replace ? transformCase(state, c) : c
      if (newC == c) {
        update = update.addCxt(mite.contents, newC)
      } else if (((Variable) state.constructions[newC]?.noun)?.hard) {
        update = update.addCxt(mite.contents - [noun:mite.contents.noun] + [innerNoun:mite.contents.noun], newC)
      } else {
        update = update.addCxt(mite.contents, newC) //todo innerNoun/noun separation for all prepositions
      }
      if (replace && newC != c && ((Variable) mite.contents.noun)?.hard) {
        update = update.addCxt(preposition, hasNoun:true)
      }
    }
    return base(update.mites.reverse(), state)
  }

}

