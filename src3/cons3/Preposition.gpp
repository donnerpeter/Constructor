package cons3

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Preposition extends Interceptor {

  static final ArrayList<Construction> cases = [nom, acc, gen, dat, instr, prep]

  private Construction transformCase(ParsingState state, Construction caze) {
    def p = state[preposition].prep

    if (p == 'posle' && caze == gen) return posleGen
    if (p == 'ranshe' && caze == gen) return ransheGen
    if (p == 'по' && caze == dat) return poDat
    if (p == 'в' && caze == prep) return vPrep
    if (p == 'в' && caze == acc) return vAcc
    if (p == 'с' && caze == gen) return sGen
    if (p == 'с' && caze == instr) return sInstr
    if (p == 'до' && caze == gen) return doGen
    if (p == 'к' && caze == dat) return kDat
    if (p == 'о' && caze == prep) return oPrep
    if (p == 'из' && caze == gen) return izGen
    if (p == 'на' && caze == prep) return naPrep
    if (p == 'от' && caze == gen) return otGen
    if (p == 'у' && caze == gen) return uGen
    return caze
  }

  @Override
  ParsingState getExtensionState(Mite mite, Node current) {
    if (mite.contents.hasNoun || mite.contents.prep in ['posle', 'ranshe']) {
      return current.findNode(mite.primaries.iterator().next()).prevState
    }
    return super.getExtensionState(mite, current)
  }

  Collection<Mite> enrichUpdate(Mite prep, List<Mite> contribution, ParsingState state) {
    List<Mite> result = []
    for (mite in contribution) {
      def c = mite.cxt
      if (c in cases && !mite.contents.head) {
        def newC = transformCase(state, c)
        if (newC != c) {
          def converted = new Mite(mite.contents, newC)
          def existing = state.visibleMites[newC]
          if (existing) {
            result.addAll(existing.findAll { !ParsingState.overwrites(converted.contents, it.contents) }.collect { it.unify(converted) })
          }
        }
      }
    }
    if (!result.empty && !prep.contents.hasNoun) {
      result << prep.unify(new Mite(preposition, hasNoun:true))
    }
    return result
  }

}

