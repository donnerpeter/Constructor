package cons3

/**
 * @author peter
 */
class RussianConstructions {
  Construction cxt(String name, Function2<ParsingState, Map, ParsingState> cl) {
    new Construction(name, cl)
  }

  Construction adjective = cxt('adjective') { ParsingState state, Map args -> state.assign(args.nounFrame, (String)args.rel, args.val) }
  Construction nom = cxt('nom') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'arg1', args.noun)
    }
    return state
  }
  Construction acc = cxt('acc') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'arg2', args.noun)
    }
    return state
  }
  Construction gen = cxt('gen') { ParsingState state, Map args ->
    def type = ((Variable) args.head)?.frame(state.chart)?.type
    if (type && args.noun) {
      if (((Variable) args.head)?.frame(state.chart)?.type == 'BOTH') {
        state = state.assign(args.noun, 'quantifier', args.head)
      } else {
        state = state.assign(args.head,
                             type == 'LACK' ? 'arg2' :
                               'arg1', args.noun)

      }
    }
    return state
  }
  Construction instr = cxt('instr') { ParsingState state, Map args ->
    if (((Variable) args.head)?.frame(state.chart)?.type && args.noun) {
      state = state.assign(args.head, 'arg2', args.noun)
    }
    state
  }
  Construction dat = cxt('dat') { ParsingState state, Map args ->
    if (args.head && args.noun && args.infinitive) {
      state = state.assign(args.head, 'arg1', args.noun)
    }
    state
  }
  Construction prep = cxt('prep') { ParsingState state, Map args -> state }
  Construction sInstr = cxt('sInstr') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if ( ((Variable) args.noun).frame(state.chart)?.type in ['JOY', 'RELIEF']) {
        state = state.assign(args.head, 'mood', args.noun)
      } else {
        state = state.assign(args.head, 'experiencer', args.noun)
      }
    }

    return state
  }
  Construction sGen = cxt('sGen') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'source', args.noun)
    }

    return state
  }
  Construction poDat = cxt('poDat') { ParsingState state, Map args ->
    Variable lastNoun = args.noun
    def member = lastNoun?.frame(state.chart)?.f('member')
    if (member) {
      lastNoun = member.var
    }
    def nType = lastNoun?.frame(state.chart)?.type
    if (nType) {
      if (nType in ['OPINION', 'WORDS']) {
        state = state.assign(state.situation, 'opinion_of', args.noun)
      } else if (args.head) {
        if (nType == 'LUCK') {
          state = state.assign(args.noun, 'topic', args.head)
        } else {
          state = state.assign(args.head, 'topic', args.noun)
        }
      }
    }

    return state
  }
  Construction oPrep = cxt('oPrep') { ParsingState state, Map args ->
    args.noun ? state.assign(args.head, 'topic', args.noun) : state
  }
  Construction nounGen = cxt('nounGen') { ParsingState state, Map args -> //todo nounGen -> gen
    if (args.noun && args.head) {
      Frame head = ((Variable) args.head).frame(state.chart)
      List<Variable> heads = head.flatten().collect {it.var}
      int i = 0
      for (h in heads) {
        def hf = h.frame(state.chart)
        def hType = hf.type
        def attr = hType == 'WORDS' ? 'author' : hType == 'OPINION' ? 'arg1' : 'criterion'
        if (i == heads.size() - 1 || !hf.f(attr)) {
          state = state.assign(h, attr, args.noun)
        }
        i++
      }
    }
    return state
  }
  Construction kDat = cxt('kDat') { ParsingState state, Map args ->
    args.noun && args.head ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction dativePart = cxt('dativePart') { state, args ->
    args.dat && args.head && args.acc ? state.assign(args.acc, 'arg1', args.dat) : state
  }
  Construction prevHistory = cxt('prevHistory') { ParsingState state, Map args ->
    return state
  }
  Construction clauseEllipsis = cxt('clauseEllipsis') { ParsingState state, Map args ->
    return state
  }
  Construction question = cxt('question') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head) {
      Situation next = args.comp ?: new Situation()
      state = state.assign(args.head, ((Variable) args.head).frame(state.chart).type == 'FORGET' ? 'theme' : 'question', next).withSituation(next).apply(question, comp:next)
    }
    if (args.questioned && args.comp) {
      if (args.imperative) {
        state = state.assign(state.situation, 'imperative', 'true')
      }
      state = state.assign(args.comp, 'questioned', args.questioned)
    }
    return state
  }
  Construction comeScalarly = cxt('comeScalarly') { ParsingState state, Map args ->
    args.verb && args.order ? state.assign(args.verb, 'type', 'COME_SCALARLY').assign(args.verb, 'order', args.order) : state
  }
  Construction questionVariants = cxt('questionVariants') { ParsingState state, Map args ->
    args.seq && args.questioned ? state.assign(args.questioned, 'variants', args.seq).satisfied(questionVariants) : state
  }
  Construction shortAdjCopula = cxt('shortAdjCopula') { ParsingState state, Map args ->
    if (args.noun && args.pred) {
      state = state.assign(args.noun, 'degree', args.pred)
    }
    return state
  }
  Construction parenthetical = cxt('parenthetical') { ParsingState state, Map args ->
    return state
  }
  Construction preposition = cxt('preposition') { ParsingState state, Map args ->
    return state
  }
  Construction possessive = cxt('possessive') { ParsingState state, Map args ->
    if (args.possessor) {
      def type = ((Variable) args.head)?.frame(state.chart)?.type
      if (type) {
        state = state.assign(args.head, type in ['AMAZE', 'PREDICAMENT', 'OPINION'] ? 'arg1' : 'author', args.possessor)
      }
    }
    return state
  }
  Construction control = cxt('control') { ParsingState state, Map args ->
    return args.head && args.slave ? state.assign(args.head, 'theme', args.slave) : state
  }
  Construction declComp = cxt('declComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.complementizer) {
      def next = new Situation()
      state = state.assign(args.head, 'theme', next).withSituation(next).apply(declComp, comp:next)
    }
    return state
  }
  Construction conditionComp = cxt('conditionComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.wh) {
      def next = new Situation()
      state = state.assign(args.head, "${args.wh}Condition", next).withSituation(next).apply(conditionComp, comp:next)
    }
    return state
  }
  Construction reasonComp = cxt('reasonComp') { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.active) {
      def next = new Situation()
      state = state.assign(args.head, "reason", next).withSituation(next)
    }
    return state
  }
  Construction numQuantifier = cxt('numQuantifier') { ParsingState state, Map args ->
    if (args.noun && !args.num) {
      return state.satisfied(numQuantifier) //todo inverted quantification
    }

    return args.num && args.noun ? state.assign(args.noun, 'quantifier', args.num) : state
  }
  Construction negation = cxt('negation') { ParsingState state, Map args ->
    return state
  }
  Construction also = cxt('also') { ParsingState state, Map args ->
    return state
  }
  Construction vAcc = cxt('vAcc') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, ((Variable) args.head).frame(state.chart).type == 'THINK' ? 'theme' : 'goal', args.noun)
      //todo apply everything on every change
      if (state[nom]) {
        state = state.apply(nom)
      }
      if (state[posleGen]) {
        state = state.apply(posleGen)
      }
    }
    state
  }
  Construction vPrep = cxt('vPrep') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if (((Variable) args.head).frame(state.chart).type == 'COME_TO') {
        state = state.assign(args.head, 'domain', args.noun)
      } else if (((Variable) args.noun).frame(state.chart).type == 'CASE') {
        state = state.assign(state.situation, 'condition', args.noun)
      }
    }
    state
  }
  Construction posleGen = cxt('posleGen') { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return state
  }
  Construction ransheGen = cxt('ransheGen') { ParsingState state, Map args ->
    def type = ((Variable) args.head)?.frame(state.chart)?.type
    if (type && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return state
  }
  Construction naPrep = cxt('naPrep') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'location', args.noun) : state
  }
  Construction izGen = cxt('izGen') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'source', args.noun) : state
  }
  Construction doGen = cxt('doGen') { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction participleArg = cxt('participleArg') { ParsingState state, Map args ->
    args.head && args.participle ? state.assign(args.head, 'theme', args.participle) : state
  }
  Construction seq = cxt('seq') { ParsingState state, Map args ->
    return state
  }
  Construction advObj = cxt('advObj') { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, 'arg2', args.adv)
    }
    return state
  }
  Construction relTime = cxt('relTime') { ParsingState state, Map args ->
    if (args.head && args.relTime) {
      state = state.assign(args.head, 'relTime', args.relTime)
    }
    return state
  }
  Construction absTime = cxt('absTime') { ParsingState state, Map args ->
    if (args.head && args.rel && args.noun) {
      state = state.assign(args.head, 'relTime_after', args.noun)
    }
    return state
  }
  Construction adverb = cxt('adverb') { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, args.adv == 'LONG' ? 'duration' : 'manner', args.adv)
    }
    return state
  }
  Construction quotedName = cxt('quotedName') { ParsingState state, Map args ->
    if (args.finished) {
      state = state.assign(args.noun, 'name', args.name).satisfied(quotedName)
    }
    return state
  }
  Construction relativeClause = cxt('relativeClause') { ParsingState state, Map args ->
    if (args.noun && args.hasComma && args.wh) {
      def next = new Situation()
      return state.assign(args.noun, 'relative', next).withSituation(next).assign(next, 'wh', args.wh).apply(nestedClause, save: args.save, parent:args.parentSituation)
    }
    return state
  }
  Construction nestedClause = cxt('nestedClause') { ParsingState state, Map args ->
    return state
  }
  Construction directSpeech = cxt('directSpeech') { ParsingState state, Map args ->
    if (args.head && args.hasColon) {
      def message = new Situation()
      state = state.assign(args.head, 'message', message).withSituation(message)
    }

    return state
  }
  Construction summerGarden = cxt('summerGarden') { ParsingState state, Map args ->
    if (args.summer && args.garden) {
      state = state.assign(args.garden, 'name', 'Летний сад')
    }
    return state
  }
}
