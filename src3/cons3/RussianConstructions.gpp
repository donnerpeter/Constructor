package cons3

import static cons3.Construction.cxt

/**
 * @author peter
 */
interface RussianConstructions {

  Construction adjective = cxt('adjective') { ParsingState state, Map args ->
    state.assign(args.nounFrame, (String)args.rel, args.val) }
  Construction nom = cxt('nom', ['head']) { ParsingState state, Map args ->
    if (args.agr && !((Variable) args.noun)?.hard) {
      Variable noun = args.noun
      if (!noun) {
        noun = new Variable().lightVar
        state = state.augmentWith(RussianConstructions.nom(noun:noun)).augmentWith(RussianConstructions.reflexiveHolder(noun:noun))
      }
      String agr = args.agr
      if (SeqInterceptor.agrNumber(agr)) {
        state = state.assign(noun, 'rusNumber', SeqInterceptor.agrNumber(agr))
      }
      if (SeqInterceptor.agrPerson(agr)) {
        state = state.assign(noun, 'person', SeqInterceptor.agrPerson(agr))
      }
      if (SeqInterceptor.agrGender(agr)) {
        state = state.assign(noun, 'gender', SeqInterceptor.agrGender(agr))
      }
      args = state[nom]
    }
    Variable noun = args.noun
    if (args.head && noun) {
      for (subj in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(subj.var, 'arg1', noun)
      }
    }
    return state
  }
  Construction acc = cxt('acc', ['head', 'noun']) { ParsingState state, Map args ->
    state.assign(args.head, 'arg2', args.noun)
  }
  Construction gen = cxt('gen', ['head', 'noun']) { ParsingState state, Map args ->
    Frame head = ((Variable) args.head).frame(state.chart)
    List<Variable> heads = head.flatten().collect {it.var}
    int i = 0
    for (h in heads) {
      def hf = h.frame(state.chart)
      def hType = hf.type
      def attr = hType == 'LACK' ? 'arg2' :
        hType == 'WORDS' ? 'author' :
          hType in ['OPINION', 'CORNER', 'CASHIER'] ? 'arg1' :
            'criterion'
      if (i == heads.size() - 1 || !hf.f(attr)) {
        state = state.assign(h, attr, args.noun)
      }
      i++
    }
    return state
  }
  Construction instr = cxt('instr', ['+head', 'noun']) { ParsingState state, Map args ->
    state.assign(args.head, 'arg2', args.noun)
  }
  Construction datSubj = cxt('datSubj', ['+head', 'noun']) { ParsingState state, Map args ->
    state.assign(args.head, 'arg1', args.noun)
  }
  Construction dat = cxt('dat', ['+head', 'noun']) { ParsingState state, Map args ->
    if (((Variable) args.head)?.frame(state.chart)?.type == 'SAY') {
      state = state.assign(args.head, 'addressee', args.noun)
    }
    state
  }
  Construction prep = cxt('prep', ['X']) { ParsingState state, Map args -> state }
  Construction sInstr = cxt('sInstr', ['+head', 'noun']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if (((Variable) args.noun).frame(state.chart)?.type in ['JOY', 'RELIEF']) {
        state = state.assign(args.head, 'mood', args.noun)
      } else {
        state = state.assign(args.head, 'experiencer', args.noun)
      }
    }

    return state
  }
  Construction sGen = cxt('sGen', ['+head', 'noun']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'source', args.noun)
    }

    return state
  }
  Construction poDat = cxt('poDat', ['head', 'noun']) { ParsingState state, Map args ->
    Variable lastNoun = args.noun
    def member = lastNoun?.frame(state.chart)?.f('member')
    if (member) {
      lastNoun = member.var
    }
    def nType = lastNoun?.frame(state.chart)?.type
    if (args.head && lastNoun) {
      if (nType in ['OPINION', 'WORDS']) {
        state = state.assign(args.head, 'opinion_of', args.noun)
      } else {
        if (nType == 'LUCK') {
          state = state.assign(args.noun, 'topic', args.head)
        } else if (((Variable) args.head).frame(state.chart)?.type == 'DISPERSE') {
          state = state.assign(args.head, 'goal', args.noun)
        } else {
          state = state.assign(args.head, 'topic', args.noun)
        }
      }
    }

    return state
  }
  Construction oPrep = cxt('oPrep', ['+head', 'noun']) { ParsingState state, Map args ->
    args.noun ? state.assign(args.head, 'topic', args.noun) : state
  }
  Construction kDat = cxt('kDat', ['+head', 'noun']) { ParsingState state, Map args ->
    args.noun && args.head ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction dativePart = cxt('dativePart', ['head', 'dat', 'acc']) { state, args ->
    args.dat && args.head && args.acc ? state.assign(args.acc, 'arg1', args.dat) : state
  }
  Construction prevHistory = cxt('prevHistory', ['X']) { ParsingState state, Map args -> return state }
  Construction clauseEllipsis = cxt('clauseEllipsis', ['X']) { ParsingState state, Map args -> return state }
  Construction declOrQuestionComp = cxt('declOrQuestionComp', ['head', 'comp', 'hasComma']) { ParsingState state, Map args ->
    def type = ((Variable) args.head).frame(state.chart).type
    def attr = type == 'FORGET' ? 'arg2' : type == 'DISCOVER' ? 'theme' : type == 'SAY' ? 'message' : 'question'
    state.assign(args.head, attr, args.comp).inhibit(seq)
  }
  Construction question = cxt('question', ['questioned', 'frame', 'mainVerb']) { ParsingState state, Map args ->
    if (args.modality) {
      state = state.assign(args.modality, 'type', 'modality').assign(args.modality, 'arg1', args.mainVerb).assign(args.frame, 'content', args.modality)
      if (args.time) {
        state = state.assign(args.modality, 'time', args.time)
      }
    }
    else if (args.mainVerb) {
      state = state.assign(args.frame, 'content', args.mainVerb)
    }
    state = state.assign(args.frame, 'type', 'question').assign(args.frame, 'questioned', args.questioned)
    return state
  }
  Construction comeScalarly = cxt('comeScalarly', ['verb']) { ParsingState state, Map args ->
    state = state.assign(args.verb, 'type', 'COME_SCALARLY')
    args.order ? state.assign(args.verb, 'order', args.order) : state
  }
  Construction questionVariants = cxt('questionVariants', ['seq', 'questioned']) { ParsingState state, Map args ->
    args.seq && args.questioned ? state.assign(args.questioned, 'variants', args.seq).satisfied(questionVariants) : state
  }
  Construction reflexiveHolder = cxt('reflexiveHolder', ['X']) { ParsingState state, Map args -> state }
  Construction shortAdj = cxt('shortAdj', ['noun', 'value', 'copula']) { ParsingState state, Map args ->
    if (args.noun && args.value && args.copula) {
      state = state.assign(args.copula, 'type', 'degree').assign(args.copula, 'arg1', args.noun).assign(args.copula, 'arg2', args.value)
      if (args.time) {
        state = state.assign(args.copula, 'time', args.time)
      }
    }
    return state
  }
  Construction parenthetical = cxt('parenthetical', ['X']) { ParsingState state, Map args ->
    return state
  }
  Construction preposition = cxt('preposition', ['prep']) { ParsingState state, Map args ->
    if (!args.interceptor && args.prep) {
      state = state.inhibit(preposition).augmentWith(RussianConstructions.preposition(prep:args.prep, interceptor:new Preposition()))
    }
    return state
  }
  Construction possessive = cxt('possessive') { ParsingState state, Map args ->
    if (args.head && !args.possessor) {
      state = state.inhibit(possessive)
    }

    if (args.possessor) {
      def head = ((Variable) args.head)?.frame(state.chart)
      if (head) {
        for (h in head.flatten()) {
          def type = h.type
          if (type) {
            String attr = type in ['AMAZE', 'PREDICAMENT', 'OPINION', 'ARGUE'] ? 'arg1' : type in ['ROOMS', 'APARTMENTS', 'OFFICES'] ? 'owner' : 'author'
            state = state.assign(h.var, attr, args.possessor).satisfied(possessive)
          }
        }
      }

    }
    return state
  }
  Construction control = cxt('control', ['+head', 'slave']) { ParsingState state, Map args ->
    return args.head && args.slave ? state.assign(args.head, 'theme', args.slave) : state
  }
  Construction conditionComp = cxt('conditionComp', ['hasComma', 'head', 'wh']) { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.wh) {
      def next = new Situation()
      state = state.assign(args.head, "${args.wh}Condition", next).withSituation(next).apply(conditionComp, comp:next)
    }
    return state
  }
  Construction reasonComp = cxt('reasonComp', ['hasComma', 'head', 'active']) { ParsingState state, Map args ->
    if (args.hasComma && !args.comp && args.head && args.active) {
      def next = new Situation()
      state = state.assign(args.head, "reason", next).withSituation(next)
    }
    return state
  }
  Construction numQuantifier = cxt('numQuantifier', ['num', 'noun']) { ParsingState state, Map args ->
    return args.num && args.noun ? state.assign(args.noun, 'quantifier', args.num) : state
  }
  Construction negation = cxt('negation') { ParsingState state, Map args ->
    return state
  }
  Construction also = cxt('also') { ParsingState state, Map args ->
    if (args.head && !args.hasAlso) {
      state = state.inhibit(also)
    }
    if (args.hasAlso && args.head) {
      state = state.assign(args.head, 'also', 'true')
    }
    return state
  }
  Construction vAcc = cxt('vAcc', ['noun', 'head']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, ((Variable) args.head).frame(state.chart).type == 'THINK' ? 'theme' : 'goal', args.noun)
    }
    state
  }
  Construction vPrep = cxt('vPrep', ['noun', 'head']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if (((Variable) args.head).frame(state.chart).type == 'COME_TO') {
        state = state.assign(args.head, 'domain', args.noun)
      } else if (((Variable) args.noun).frame(state.chart).type == 'CASE') {
        state = state.assign(args.head, 'condition', args.noun)
      }
    }
    state
  }
  Construction posleGen = cxt('posleGen', ['noun', 'head']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return state
  }
  Construction ransheGen = cxt('ransheGen', ['noun', 'head']) { ParsingState state, Map args ->
    def type = ((Variable) args.head)?.frame(state.chart)?.type
    if (type && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return state
  }
  Construction naPrep = cxt('naPrep', ['noun', 'head']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      if (args.copula) {
        def location = args.copula
        state = state.assign(location, 'type', 'location').assign(location, 'arg1', args.head).assign(location, 'arg2', args.noun)
      } else {
        state = state.assign(args.head, 'location', args.noun)
      }
    }
    return state
  }
  Construction izGen = cxt('izGen', ['noun', 'head']) { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'source', args.noun) : state
  }
  Construction doGen = cxt('doGen', ['noun', 'head']) { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction otGen = cxt('otGen', ['noun', 'head']) { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'theme', args.noun) : state
  }
  Construction participleArg = cxt('participleArg', ['participle', 'head']) { ParsingState state, Map args ->
    args.head && args.participle ? state.assign(args.head, 'theme', args.participle) : state
  }
  Construction seq = cxt('seq') { ParsingState state, Map args ->
    SeqInterceptor interceptor = args.interceptor
    String conj = args.conj
    def before = state.beforeThisChange
    if (conj && !before[seq]?.conj && before[seq]?.interceptor) {
      interceptor = null
    }

    if (!interceptor) {
      interceptor = new SeqInterceptor(before, conj)
      if (conj) {
        state = state.clearConstructions()
      }
      state = state.augmentWith(RussianConstructions.seq(conj:conj, interceptor:interceptor))
    }
    if (args.conj == 'but') {
      if (!interceptor.before.history) {
        state = state.inhibit(seq)
      }
      if (args.butWord && !args.butWordHandled) {
        def verb = new Variable().lightVar
        state = state.apply((seq):[butWordHandled:true],
                (prevHistory):[history:before],
                (verbEmphasis):[emphasis:args.butWord == 'а' ? 'andEmphasis' : 'butEmphasis'])
      }
    }
    return state
  }
  Construction advObj = cxt('advObj', ['adv', 'head']) { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, 'arg2', args.adv)
    }
    return state
  }
  Construction verbEmphasis = cxt('verbEmphasis', ['verb', 'emphasis']) { ParsingState state, Map args ->
    state.assign(args.verb, (String)args.emphasis, 'true')
  }
  Construction relTime = cxt('relTime', ['relTime', 'head']) { ParsingState state, Map args ->
    state.assign(args.head, 'relTime', args.relTime)
  }
  Construction absTime = cxt('absTime', ['rel', 'head', 'noun']) { ParsingState state, Map args ->
    state.assign(args.head, 'relTime_after', args.noun)
  }
  Construction adverb = cxt('adverb', ['head', 'adv']) { ParsingState state, Map args ->
    state.assign(args.head, args.adv == 'LONG' ? 'duration' : 'manner', args.adv).inhibit(adverb)
  }
  Construction quotedName = cxt('quotedName', ['finished']) { ParsingState state, Map args ->
    state.assign(args.noun, 'name', args.name).satisfied(quotedName)
  }
  Construction relativeClause = cxt('relativeClause', ['noun', 'hasComma', 'wh']) { ParsingState state, Map args ->
    if (args.noun && args.hasComma && args.wh) {
      def next = new Situation()
      return state.assign(args.noun, 'relative', next).withSituation(next).assign(args.wh, 'relativized', 'true').apply(nestedClause, save:args.save, parent:args.parentSituation)
    }
    return state
  }
  Construction nestedClause = cxt('nestedClause', ['X']) { ParsingState state, Map args ->
    return state
  }
  Construction complementizer = cxt('complementizer', ['frame', 'mainVerb']) { ParsingState state, Map args ->
    state = state.assign(args.frame, 'type', 'fact')
    if (args.mainVerb) {
      state = state.assign(args.frame, 'content', args.mainVerb)
    }
    return state
  }
  Construction directSpeech = cxt('directSpeech') { ParsingState state, Map args ->
    if (args.head && args.hasColon) {
      def message = new Situation()
      state = state.assign(args.head, 'message', message).withSituation(message)
    }

    return state
  }
  Construction summerGarden = cxt('summerGarden', ['summer', 'garden']) { ParsingState state, Map args ->
    state.assign(args.garden, 'name', 'Летний сад')
  }
  Construction subjunctive = cxt('subjunctive', ['head', 'subjunctive']) { ParsingState state, Map args ->
    state.assign(args.head, 'irrealis', 'true')
  }
  Construction adverbPred = cxt('adverbPred', ['adverb', 'time']) { ParsingState state, Map args ->
    state.assign(args.adverb, 'time', args.time)
  }
  Construction verbHolder = cxt('verbHolder', ['X']) { ParsingState state, Map args -> state }
  Construction elaboration = cxt('elaboration', ['head', 'elaboration']) { ParsingState state, Map args ->
    state.assign(args.head, 'elaboration', args.elaboration)
  }
}
