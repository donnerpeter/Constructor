package cons3

import static cons3.Construction.cxt

/**
 * @author peter
 */
interface RussianConstructions {

  Construction adjective = cxt('adjective') { ParsingState state, Map args ->
    state.assign(args.nounFrame, (String)args.rel, args.val) }
  Construction nom = Util.commonCase('nom')
  Construction nomSubject = cxt('nomSubject', ['+head', 'noun']) { ParsingState state, Map args ->
    def nf = ((Variable) args.noun).frame(state.chart)
    if (nf.type || nf.s('rusNumber')) { //todo a nicer way of distinguishing contentful frames
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'arg1', args.noun)
      }
    }
    return state
  }
  Construction acc = Util.commonCase('acc')
  Construction accArg2 = cxt('accArg2', ['+head', 'noun']) { ParsingState state, Map args ->
    def nf = ((Variable) args.noun).frame(state.chart)
    nf.flatten()[0]?.type ? state.assign(args.head, 'arg2', args.noun) : state
  }
  Construction gen = Util.commonCase('gen')
  Construction genArg1 = cxt('genArg1', ['+head', 'noun']) { ParsingState state, Map args ->
    if (((Variable) args.noun).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'arg1', args.noun)
      }
    }
    return state
  }
  Construction genArg2 = cxt('genArg2', ['+head', 'noun']) { ParsingState state, Map args ->
    if (((Variable) args.noun).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'arg2', args.noun)
      }
    }
    return state
  }
  Construction genCriterion = cxt('genCriterion', ['+head', 'noun']) { ParsingState state, Map args ->
    if (((Variable) args.noun).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'criterion', args.noun)
      }
    }
    return state
  }
  Construction genAuthor = cxt('genAuthor', ['+head', 'noun']) { ParsingState state, Map args ->
    if (((Variable) args.noun).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'author', args.noun)
      }
    }
    return state
  }
  Construction instr = Util.commonCase('instr')
  Construction instrArg2 = cxt('instrArg2', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'arg2', args.noun) : state
  }
  Construction dat = Util.commonCase('dat')
  Construction datSubj = cxt('datSubj', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'arg1', args.noun) : state
  }
  Construction datAddressee = cxt('datAddressee', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'addressee', args.noun) : state
  }
  Construction prep = Util.commonCase('prep')
  Construction sInstr = Util.commonPrep('sInstr')
  Construction sInstrExperiencer = cxt('sInstrExperiencer', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'experiencer', args.noun) : state
  }
  Construction sInstrMood = cxt('sInstrMood', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'mood', args.noun) : state
  }
  Construction sGen = cxt('sGen', ['+head', 'noun']) { ParsingState state, Map args ->
    if (args.head && args.noun) {
      state = state.assign(args.head, 'source', args.noun)
    }

    return state
  }
  Construction poDat = cxt('poDat', ['+noun']) { ParsingState state, Map args ->
/*
    Variable lastNoun = args.noun
    def member = lastNoun?.frame(state.chart)?.f('member')
    if (member) {
      lastNoun = member.var
    }
    def nType = lastNoun?.frame(state.chart)?.type
    if (args.head && lastNoun) {
      if (nType in ['OPINION', 'WORDS']) {
        state = state.assign(args.head, 'opinion_of', args.noun)
      } else {
        if (nType == 'LUCK') {
          state = state.assign(args.noun, 'topic', args.head)
        } else if (((Variable) args.head).frame(state.chart)?.type == 'DISPERSE') {
          state = state.assign(args.head, 'goal', args.noun)
        } else {
          state = state.assign(args.head, 'topic', args.noun)
        }
      }
    }

*/
    return state
  }
  Construction poDatTopic = cxt('poDatTopic', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state = state.assign(args.head, 'topic', args.noun) : state
  }
  Construction oPrep = cxt('oPrep', ['*head', '+noun']) { ParsingState state, Map args -> state }
  Construction oPrepTopic = cxt('oPrepTopic', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'topic', args.noun) : state
  }
  Construction kDat = cxt('kDat', ['+noun']) { ParsingState state, Map args -> state }
  Construction kDatGoal = cxt('kDatGoal', ['+head', 'noun']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction uGen = cxt('uGen', ['+head', 'noun']) { ParsingState state, Map args ->
    if (args.copula) {
      def location = args.copula
      state = state.assign(location, 'type', 'location').assign(location, 'arg2', args.head).assign(location, 'arg1', args.noun)
    } else {
      state = state.assign(args.head, 'location', args.noun)
    }
    state
  }
  Construction dativePart = cxt('dativePart', ['head', 'dat', 'acc']) { state, args ->
    args.dat && args.head && args.acc ? state.assign(args.acc, 'arg1', args.dat) : state
  }
  Construction prevHistory = cxt('prevHistory', ['X']) { ParsingState state, Map args -> return state }
  Construction clauseEllipsis = cxt('clauseEllipsis', ['X']) { ParsingState state, Map args -> return state }
  Construction declOrQuestionComp = cxt('declOrQuestionComp', ['head', 'comp', 'hasComma']) { ParsingState state, Map args ->
    def type = ((Variable) args.head).frame(state.chart).type //todo split declOrQuestionComp semantically
    def attr = type == 'FORGET' ? 'arg2' : type == 'DISCOVER' ? 'theme' : type == 'SAY' ? 'message' : 'question'
    state.assign(args.head, attr, args.comp)
  }.enrichingMites { mite, contribution, state ->
    if (contribution.find { it.cxt == comma }) {
      return [mite.unify(new Mite(declOrQuestionComp, hasComma:true))]
    }
    return mite.unifyWherePossible(contribution)
  }
  Construction modality = cxt('modality', ['modality', 'infinitive', 'questioned']) { ParsingState state, Map args ->
    state = state.assign(args.modality, 'type', 'modality').assign(args.modality, 'arg1', args.infinitive)
    return state
  }
  Construction timedModality = cxt('timedModality', ['modality', 'time']) { ParsingState state, Map args ->
    state = state.assign(args.modality, 'time', args.time)
    return state
  }
  Construction question = cxt('question', ['questioned', 'frame', 'content']) { ParsingState state, Map args ->
    state = state.assign(args.frame, 'content', args.content)
    state = state.assign(args.frame, 'type', 'question').assign(args.frame, 'questioned', args.questioned)
    return state
  }
  Construction comeScalarly = cxt('comeScalarly', ['verb']) { ParsingState state, Map args ->
    state = state.assign(args.verb, 'type', 'COME_SCALARLY')
    args.order ? state.assign(args.verb, 'order', args.order) : state
  }
  Construction questionVariants = cxt('questionVariants', ['seq', 'questioned']) { ParsingState state, Map args ->
    state.assign(args.questioned, 'variants', args.seq)
  }.screeningMites { mite, screen ->
    if (!mite.contents.seq && mite.contents.questioned) return screen.hideAll() else return screen
  }
  Construction reflexiveHolder = cxt('reflexiveHolder', ['X']) { ParsingState state, Map args -> state }
  Construction shortAdj = cxt('shortAdj', ['noun', 'value', 'copula']) { ParsingState state, Map args ->
    if (args.noun && args.value && args.copula) {
      state = state.assign(args.copula, 'type', 'degree').assign(args.copula, 'arg1', args.noun).assign(args.copula, 'arg2', args.value)
      if (args.time) {
        state = state.assign(args.copula, 'time', args.time)
      }
    }
    return state
  }.structural { mite, state, via -> state.findState(mite, 'value') }
  Construction parenthetical = cxt('parenthetical', ['X']) { ParsingState state, Map args ->
    return state
  }
  Construction preposition = cxt('preposition', ['prep']) { ParsingState state, Map args ->
    return state
  }
  Construction possArg1 = cxt('possArg1', ['+head', 'possessor']) { ParsingState state, Map args ->
    if (((Variable) args.possessor).frame(state.chart).flatten()[0]?.type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'arg1', args.possessor)
      }
    }
    return state
  }
  Construction possOwner = cxt('possOwner', ['+head', 'possessor']) { ParsingState state, Map args ->
    if (((Variable) args.possessor).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'owner', args.possessor)
      }
    }
    return state
  }
  Construction possAuthor = cxt('possAuthor', ['+head', 'possessor']) { ParsingState state, Map args ->
    if (((Variable) args.possessor).frame(state.chart).type) {
      for (hf in ((Variable) args.head).frame(state.chart).flatten()) {
        state = state.assign(hf.var, 'author', args.possessor)
      }
    }
    return state
  }
  Construction possessive = cxt('possessive', ['+possessor', '*head']) { ParsingState state, Map args -> state }
  Construction control = cxt('control', ['+head', 'slave']) { ParsingState state, Map args ->
    return args.head && args.slave ? state.assign(args.head, 'theme', args.slave) : state
  }.structural { mite, state, via -> state.findState(mite, 'head') } { mite, fresh -> fresh.cxt != verbHolder }
  Construction conditionComp = cxt('conditionComp', ['hasComma', 'head', 'wh']) { ParsingState state, Map args ->
    state.assign(args.head, "${args.wh}Condition", args.comp)
  }.enrichingMites { mite, contribution, state ->
    if (contribution.find { it.cxt == comma }) {
      return [mite.unify(new Mite(conditionComp, hasComma:true))]
    }
    if ((mite.contents.hasComma || mite.contents.wh) && contribution.find { it.cxt == conditionComp && it.contents.head }) {
      return []
    }
    return mite.unifyWherePossible(contribution)
  }.screeningMites { mite, screen -> mite.contents.head && mite.contents.hasComma ? screen.hideAll() : screen }.structural { mite, state, via ->
    if (mite.contents.wh) {
      return ParsingState.EMPTY
    }
  }
  Construction reasonComp = cxt('reasonComp', ['reason', 'head']) { ParsingState state, Map args ->
    return state.assign(args.head, 'reason', args.reason)
  }.enrichingMites { mite, contribution, state ->
    if (contribution.find { it.cxt == comma }) {
      return [mite.unify(new Mite(reasonComp, hasComma:true))]
    }
    if (mite.contents.head && contribution.find { it.cxt == conditionComp && it.contents.hasComma } ||
        mite.contents.head && mite.contents.hasComma && contribution.find { it.cxt == conditionComp && it.contents.reason }) {
      return mite.unifyWherePossible(contribution)
    }
    return []
  }
  Construction numQuantifier = cxt('numQuantifier', ['+num', 'noun']) { ParsingState state, Map args ->
    state.assign(args.noun, 'quantifier', args.num)
  }.enrichingMites { mite, contribution, state -> NumQuantifier.enrichUpdate(mite, contribution, state) }
  Construction negation = cxt('negation', ['negated']) { ParsingState state, Map args ->
    state.assign(args.negated, 'negated', 'true')
  }.enrichingMites { mite, contribution, state ->
    def vh = contribution.find { it.cxt == verbHolder && ((Variable) it.contents.head).hard }
    if (vh && !mite.contents.negated) {
      return [mite.unify(new Mite(negation, negated:vh.contents.head))]
    }
    []
  }.screeningMites { mite, screen -> return screen.hide { it.cxt == negation } }.structural { mite, state, via ->
    if (mite.contents.negated) {
      return state.findState(mite.firstAtom).prevState
    }
  }
  Construction also = cxt('also', ['hasAlso', 'head']) { ParsingState state, Map args ->
    state.assign(args.head, 'also', 'true')
  }
  Construction vAcc = cxt('vAcc', ['+noun', '*head']) { ParsingState state, Map args -> state }
  Construction vAccGoal = cxt('vAccGoal', ['noun', '+head']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction vAccTheme = cxt('vAccTheme', ['noun', '+head']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'theme', args.noun) : state
  }
  Construction vPrepDomain = cxt('vPrepDomain', ['noun', '+head']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'domain', args.noun) : state
  }
  Construction vPrepCondition = cxt('vPrepCondition', ['noun', '+head']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'condition', args.noun) : state
  }
  Construction vPrep = cxt('vPrep', ['+noun', '*head']) { ParsingState state, Map args ->
    state
  }
  Construction posleGen = cxt('posleGen', ['+noun', '*head']) { ParsingState state, Map args ->
    ((Variable) args.noun)?.frame(state.chart)?.type ? state.assign(args.head, 'anchor', args.noun) : state
  }
  Construction ransheGen = cxt('ransheGen', ['+noun', '*head']) { ParsingState state, Map args ->
    def type = ((Variable) args.noun)?.frame(state.chart)?.type
    if (type && args.noun) {
      state = state.assign(args.head,'anchor', args.noun)
    }
    return state
  }
  Construction naPrep = cxt('naPrep', ['+noun', '*head']) { ParsingState state, Map args ->
    if (args.copula) {
      def location = args.copula
      state = state.assign(location, 'type', 'location').assign(location, 'arg1', args.head).assign(location, 'arg2', args.noun)
    } else {
      state = state.assign(args.head, 'location', args.noun)
    }
    return state
  }
  Construction izGen = Util.commonPrep('izGen')
  Construction izGenSource = cxt('izGenSource', ['noun', '+head']) { ParsingState state, Map args ->
    ((Variable) args.noun).frame(state.chart).type ? state.assign(args.head, 'source', args.noun) : state
  }
  Construction doGen = cxt('doGen', ['noun', 'head']) { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'goal', args.noun) : state
  }
  Construction otGen = cxt('otGen', ['noun', 'head']) { ParsingState state, Map args ->
    args.head && args.noun ? state.assign(args.head, 'theme', args.noun) : state
  }
  Construction participleArg = cxt('participleArg', ['participle', 'head']) { ParsingState state, Map args ->
    args.head && args.participle ? state.assign(args.head, 'theme', args.participle) : state
  }
  Construction adverbialPhrase = Util.commaSurrounded(cxt('adverbialPhrase', ['content', 'head']) { ParsingState state, Map args ->
    state.assign(args.head, 'perfectBackground', args.content)
  })
  Construction accordingTo = Util.commaSurrounded(cxt('accordingTo', ['content', 'head']) { ParsingState state, Map args ->
    state.assign(args.head, 'opinion_of', args.content)
  })
  Construction seq = cxt('seq') { ParsingState state, Map args ->
    String conj = args.conj
    if (args.second) {
      if (args.first) {
        state = state.assign(args.multi, 'member', args.first)
      }
      if (conj && conj != ',') {
        state = state.assign(args.multi, 'conj', conj)
      }
      if (args.distinguish) {
        state = state.assign(args.second, 'distinguished_in', args.multi)
      }
      state = state.assign(args.multi, 'member', args.second)
    }
    return state
  }.screeningMites { mite, screen ->
    if (mite.contents.mergedWith) {
      Node mergedWith = mite.contents.mergedWith
      screen = screen.showMites(mergedWith.ownMites.reverse()).showMites(mergedWith.screenPreviousState())
    }

    if (mite.contents.conj && !mite.contents.first) {
      return screen.hideAll()
    }
    return screen.hide { it.cxt == seq }
  }.enrichingMites { mite, contribution, state ->
    ParsingState before = mite.contents.beforeComma ?: state.findState(mite.firstAtom).prevState
    new SeqInterceptor(before).enrichUpdate(mite, contribution, state)
  }.structural { mite, state, via ->
    if (mite.contents.mergedWith) {
      return ((Node) mite.contents.mergedWith).prevState
    }
    if (mite.contents.conj && !mite.contents.first) {
      return ParsingState.EMPTY
    }
    return null
  }.routeWrong { mite, state ->
    if (mite.contents.conj == ',' && !mite.contents.mergedWith) {
      def apMites = state.miteList.findAll { it.cxt == adverbialPhrase }
      if (apMites.find { !it.contents.comma1 && it.contents.content } &&
          !apMites.find { it.contents.comma1 && it.contents.content }) {
        return true
      }
    }
    return false
  }
  Construction advObj = cxt('advObj', ['adv', 'head']) { ParsingState state, Map args ->
    if (args.head && args.adv) {
      state = state.assign(args.head, 'arg2', args.adv)
    }
    return state
  }
  Construction verbEmphasis = cxt('verbEmphasis', ['verb', 'emphasis']) { ParsingState state, Map args ->
    state.assign(args.verb, (String)args.emphasis, 'true')
  }
  Construction relTime = cxt('relTime', ['relTime', 'head']) { ParsingState state, Map args ->
    state.assign(args.head, 'relTime', args.relTime)
  }
  Construction absTime = cxt('absTime', ['rel', 'head', 'noun']) { ParsingState state, Map args ->
    state.assign(args.head, 'relTime_after', args.noun)
  }
  Construction adverb = cxt('adverb', ['head', 'adv', 'attr']) { ParsingState state, Map args ->
    state.assign(args.head, (String)args.attr, args.adv)
  }.screeningMites { mite, screen ->
    if (!((Variable) mite.contents.head).light) {
      screen = screen.hide { it.isPartOf(mite) }
    }
    screen
  }
  Construction quotedName = cxt('quotedName', ['noun', 'name']) { ParsingState state, Map args ->
    state.assign(args.noun, 'name', args.name)
  }.enrichingMites { mite, contribution, state ->
    if (contribution.find { it.cxt == quote }) {
      if (mite.contents.noun && !mite.contents.quote1) {
        return [mite.unify(RussianConstructions.quotedName(quote1:true))]
      }
      if (mite.contents.quote1 && !mite.contents.quote2) {
        return [mite.unify(RussianConstructions.quotedName(quote2:true))]
      }
    }
    def word = contribution.find { it.cxt == word }
    if (word && mite.contents.quote1) {
      return [mite.unify(RussianConstructions.quotedName(name:word.contents.word))]
    }
    return []
  }
  Construction relativeClause = cxt('relativeClause', ['noun', 'relative', 'wh']) { ParsingState state, Map args ->
    state.assign(args.noun, 'relative', args.relative).assign(args.wh, 'relativized', 'true')
  }.screeningMites { mite, screen ->
    if (mite.contents.comma1 && !mite.contents.wh) {
      screen = screen.hideAll()
    }
    screen
  }.enrichingMites { mite, contribution, state -> RelativeClause.enrichUpdate(mite, contribution, state) }
  Construction afterRelativeClause = cxt('afterRelativeClause', ['beforeComma', 'noun']) { ParsingState state, Map args ->
    state
  }.screeningMites { mite, screen ->
    def prevMites = ((ParsingState) mite.contents.beforeComma).miteList
    screen.showMites(prevMites.findAll { it.cxt != relativeClause || it.contents.noun != mite.contents.noun })
  }
  Construction complementizer = cxt('complementizer', ['frame', 'content']) { ParsingState state, Map args ->
    state = state.assign(args.frame, 'type', 'fact')
    state = state.assign(args.frame, 'content', args.content)
    return state
  }.structural { mite, state, via -> state.findState(mite, 'frame') } { mite, fresh -> fresh.cxt != verbHolder }
  Construction directSpeech = cxt('directSpeech', ['*head', 'message']) { ParsingState state, Map args ->
    state.assign(args.head, 'message', args.message).assign(args.message, 'directSpeech', 'true')
  }
  Construction summerGarden = cxt('summerGarden', ['summer', 'garden']) { ParsingState state, Map args ->
    state.assign(args.garden, 'name', 'Летний сад')
  }
  Construction subjunctive = cxt('subjunctive', ['head', 'subjunctive']) { ParsingState state, Map args ->
    state.assign(args.head, 'irrealis', 'true')
  }
  Construction adverbPred = cxt('adverbPred', ['adverb', 'time']) { ParsingState state, Map args ->
    state.assign(args.adverb, 'time', args.time)
  }
  Construction verbHolder = cxt('verbHolder', ['X']) { ParsingState state, Map args -> state }.
          enrichingMites { mite, contribution, state ->
            if (mite.contents.mustFinish) {
              return []
            }
            return mite.unifyWherePossible(contribution.findAll { it.cxt == verbHolder && !it.contents.mustStart })
          }
  Construction elaboration = cxt('elaboration', ['head', 'elaboration']) { ParsingState state, Map args ->
    state.assign(args.head, 'elaboration', args.elaboration)
  }.screeningMites { mite, screen ->
    if (mite.contents.head && !mite.contents.elaboration) return screen.hideAll() else return screen
  }.structural { mite, state, via ->
    if (mite.contents.head) {
      return ParsingState.EMPTY
    }
    return null

  }
  Construction dot = cxt('dot', ['head']) { ParsingState state, Map args ->
    state.assign(args.head, 'dot', 'true')
  }.screeningMites { mite, screen -> screen.hideAll() }.enrichingMites { mite, contribution, state -> [] }.structural { mite, state, via -> ParsingState.EMPTY }
  Construction comma = cxt('comma', ['hasComma']) { ParsingState state, Map args ->
    state
  }.screeningMites { mite, screen -> screen.hideAll() }.enrichingMites { mite, contribution, state -> [] }
  Construction word = cxt('word', ['word']) { ParsingState state, Map args -> state }
  Construction quote = cxt('quote', ['quote']) { ParsingState state, Map args -> state }.enrichingMites { mite, contribution, state -> [] }
}
