package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class Screen {
  ParsingState before
  LinkedHashSet<Mite> visibleMites

  Screen hide(Predicate1<Mite> condition) {
    hide before.miteList.findAll(condition)
  }
  Screen hide(Collection<Mite> toRemove) {
    LinkedHashSet<Mite> newMites = new LinkedHashSet<Mite>(visibleMites)
    newMites.removeAll(toRemove)
    new Screen(before, newMites)
  }

  Screen showEverything(ParsingState state) {
    showMites(state.miteList)
  }

  Screen showMites(Collection<Mite> mites) {
    new Screen(before, (LinkedHashSet)visibleMites + (mites as LinkedHashSet<Mite>))
  }

  Screen hideObscuredByHead(Mite mite) {
    hide findObscuredMites(mite, before)
  }

  static LinkedHashSet<Mite> findObscuredMites(Mite mite, ParsingState state) {
    LinkedHashSet<Mite> toRemove = []
    if (mite.cxt.beingMissedAttr && mite.contents[mite.cxt.beingMissedAttr] && mite.lastAtom.contents[mite.cxt.beingMissedAttr]) {
      LinkedHashSet<Variable> varsToHide = []
      for (val in mite.contents.values()) {
        if (val instanceof Variable && mite.contents[mite.cxt.beingMissedAttr] != val) {
          varsToHide.addAll(mite.allUnifiedWith(val))
        }
      }
      toRemove.addAll(state.miteList.findAll { ((Variable) it.contents[it.cxt.headAttr])?.base in varsToHide })
    }
    toRemove
  }

  Screen hideAll() {
    return hide(before.miteList)
  }
}
