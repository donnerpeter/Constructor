package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor implements RussianConstructions {
  ParsingState before

  Collection<Mite> enrichUpdate(Mite self, List<Mite> constructions, ParsingState state) {
    if (self.contents.conj == ',' && !self.contents.multi) {
      def buts = constructions.findAll { it.cxt == seq && it.contents.conj == 'but' }
      if (buts) {
        return seq(beforeComma:before).unifyWherePossible(buts, false, false)
      }
    }

    if (self.contents.precedent == null && self.contents.mergedWith) {
      return []
    }

    List<Mite> result = []

    Map<Pair<Variable, Variable>, Variable> seqs = [:]

    Node mergePoint = null

    for (mite in constructions) {
      if (mite.cxt in [nom, acc] && constructions.any { it.cxt in [nomSubject]}) {
        continue
      }

      Mite oldMite = before.visibleMites[mite.cxt]?.reverse()?.getAt(0)
      if (oldMite != null && oldMite.isSimilarTo(mite)) {
        def nextPoint = merge(state, oldMite, mite.contents, result, seqs, self.contents.questionLevel != null)
        if (nextPoint) {
          mergePoint = nextPoint
        }
      }
    }

    if (mergePoint != null) {
      seqs.each { pair, multi ->
        result.add(0, self.unify(seq(mergedWith:mergePoint, multi:multi, second:pair.second, first:(multi == pair.first ? null : pair.first))))

      }

    } else if (constructions.find { it.cxt == declOrQuestionComp && it.contents.comp }) {
      result.add(self.unify(seq(questionLevel:'true')))
    }

    return result
  }

  private Node merge(ParsingState state, Mite oldMite, Map newArgs, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs, boolean clauseLevel) {
    def oldArgs = oldMite.contents
    def cxt = oldMite.cxt
    if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
      return doMerge(state, oldMite, newArgs, 'elaboration', update, seqs)
    }
    if (cxt == complementizer && oldArgs.content && newArgs.content && before[cxt]?.frame && before[cxt].content) {
      return doMerge(state, oldMite, newArgs, 'content', update, seqs)
    }
    if (cxt == declOrQuestionComp && !before[cxt]?.head && oldArgs.comp && newArgs.comp && oldArgs.comp != state[cxt]?.head) {
      return doMerge(state, oldMite, newArgs, 'comp', update, seqs)
    }

    if (clauseLevel) return null

    if (cxt in [nomSubject]) {
      def mergePoint = findMergePoint(oldMite, 'head')
      def merged = createMergedMite(oldMite, 'head', newArgs, state, seqs)
      if (before[cxt]?.noun) {
        update.addAll reflexiveHolder(noun:before[cxt].noun).unifyWherePossible(mergePoint)
        update.addAll(merged.unify(cxt(noun:((Variable) before[cxt]?.noun).lightVar)).unifyWherePossible(mergePoint))
      }
      update.addAll merged.unifyWherePossible(mergePoint)
      return mergePoint
    }


    if (cxt in [nom, acc, gen, dat, poDat] && oldArgs.noun && newArgs.noun && state[seq]?.conj != 'but') {
      return doMerge(state, oldMite, newArgs, 'noun', update, seqs)
    }
    if (cxt in [preposition] && oldArgs.prep == newArgs.prep) {
      def mergePoint = findMergePoint(oldMite, 'x')
      update.addAll new Mite(newArgs + [repeated:true], cxt).unifyWherePossible(mergePoint)
      return mergePoint
    }
    if (cxt in [gen] && oldArgs.head && newArgs.head && !newArgs.noun) {
      return doMerge(state, oldMite, newArgs, 'head', update, seqs)
    }
    if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
      return doMerge(state, oldMite, newArgs, 'possessor', update, seqs)
    }
    if (cxt == possessive && oldArgs.head && newArgs.head) {
      return doMerge(state, oldMite, newArgs, 'head', update, seqs)
    }
    return null
  }


  private Node doMerge(ParsingState state, Mite oldMite, Map newArgs, String prop, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    def mPoint = findMergePoint(oldMite, prop)
    assert mPoint
    update.addAll createMergedMite(oldMite, prop, newArgs, state, seqs).unifyWherePossible(mPoint.prevState)
    return mPoint
  }

  private Mite createMergedMite(Mite oldMite, String prop, Map newArgs, ParsingState state, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldMite.contents[prop]
    Variable second = newArgs[prop]
    Variable multi = first.frame(state.chart).f('member') ? first : null
    if (multi) {
      def oldConj = multi.frame(state.chart).s('conj')
      if (!oldConj || oldConj == state[seq]?.conj) {
        def pair = new Pair(multi, second)
        if (!seqs[pair]) {
          seqs[pair] = multi
        }
      }
    } else {
      multi = joinedVar(seqs, first, second)
      if (first.light && second.light) {
        multi = multi.lightVar
      }
    }
    def createMergedMite = oldMite.cxt(newArgs + [(prop):multi, xor:Mite.mergeXor(oldMite.contents, newArgs)])
    createMergedMite
  }

  private Node findMergePoint(Mite oldMite, String property) {
    def node = before.node.findNode(oldMite)
    def prevSeq = node.ownMites.find { it.cxt == seq && it.contents.mergedWith && it.contents.multi && it.contents.multi == oldMite.contents[property]  }
    if (prevSeq) {
      return prevSeq.contents.mergedWith
    }
    node
  }

  private Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    return multi
  }

  @Override
  public String toString() {
    return "SeqInterceptor{" + "before=" + before + '}';
  }
}
