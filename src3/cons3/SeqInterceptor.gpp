package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor extends Interceptor implements RussianConstructions {
  ParsingState before

  SeqInterceptor(ParsingState before) {
    this.before = before
  }

  static boolean agree(agr1, agr2) {
    return agrUnifiable(agrGender((String)agr1), agrGender((String)agr2)) &&
           agrUnifiable(agrNumber((String)agr1), agrNumber((String)agr2)) &&
           agrUnifiable(agrPerson((String)agr1), agrPerson((String)agr2))
  }

  static String agrGender(String agr) { return agr == 'masc' ? 'masc' : agr == 'fem' ? 'fem' : null }
  static String agrNumber(String agr) { return agr?.endsWith('pl') ? 'pl' : agr?.endsWith('sg') || agr in ['masc', 'fem'] ? 'sg' : null }
  static String agrPerson(String agr) { return agr?.startsWith('3') ? '3' : null }
  private static boolean agrUnifiable(String a1, String a2) { return a1 == null || a2 == null || a1 == a2 }

  @Override
  Map<Construction, List<Mite>> getExtensionState(Mite mite, Node current) {
    if (mite.contents.rollback) {
      return ((ParsingState) mite.contents.rollback)?.visibleMites
    }
    return [:]
  }

  @Override
  Collection<Mite> getHiddenMites(Mite mite, ParsingState before) {
    return super.getHiddenMites(mite, before)
  }

  @Override
  Collection<Mite> enrichUpdate(Mite self, List<Mite> constructions, ParsingState state) {
    def plainMerge = super.enrichUpdate(self, constructions.findAll { self.contents.conj || it.cxt == seq && !it.contents.conj } as List, state)
    if (state[seq]?.precedent == null && state[seq]?.rollback) {
      return plainMerge
    }

    List<Mite> result = []

    def seqs = [:]
    boolean merged = false

    String conj = state[seq]?.conj
    for (mite in constructions) {
      if (mite.cxt in [nom] && constructions.any { it.cxt in [nomSubject]}) {
        continue
      }


      Mite oldArgs = before.visibleMites[mite.cxt]?.reverse()?.getAt(0)
      if (oldArgs != null) {
        def newUpdate = merge(state, mite.cxt, oldArgs?.contents, mite.contents, result, seqs, declOrQuestionComp in constructions, before.node.findNode(oldArgs).prevState)
        merged |= newUpdate
      }
    }

    if (merged) {
      ParsingState rollback = null
/*
      if (precedent == null) {
        rollback = before[commaList]?.rollback ?: history[similar].before
        rollback = rollback[numQuantifier]?.prev ?: rollback //todo a more generic way of finding a phrase start
        if (conj == null) {
          result << new Mite(commaList, rollback:rollback)
        }
      }
*/

      def newPrecedent = null
      result.add(0, new Mite(seq, conj:conj, interceptor:new SeqInterceptor(state)).unify(new Mite(seq, precedent:newPrecedent, rollback:rollback))) //todo don't unify mites artificially
    }
    return plainMerge + result
  }

  private boolean merge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs, boolean clauseLevel, ParsingState beforeState) {
    String conj = state[seq]?.conj
    if (oldArgs != null) {
      if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
        return doMerge(state, cxt, oldArgs, newArgs, 'elaboration', update, seqs, beforeState)
      }
      if (cxt == complementizer && oldArgs.content && newArgs.content && before[cxt]?.frame && before[cxt].content) {
        return doMerge(state, cxt, oldArgs, newArgs, 'content', update, seqs, beforeState)
      }
      if (cxt == declOrQuestionComp && !before[cxt]?.head && oldArgs.comp && newArgs.comp && oldArgs.comp != state[cxt]?.head) {
        return doMerge(state, cxt, oldArgs, newArgs, 'comp', update, seqs, beforeState)
      }
      if (cxt in [nomSubject]) {
        if (before[cxt]?.noun) {
          newArgs += [noun:before[cxt].noun]
          update.addAll new Mite(reflexiveHolder, noun:before[cxt].noun).unifyWherePossible(beforeState)
        }
        if (conj == 'but') {
          Variable second = newArgs.head
          Variable first = oldArgs.head
          update << new Mite(aSeqStart(), multi: joinedVar(seqs, first, second), first:first, second:second, conj:conj)
          update.addAll new Mite(newArgs, nom).unifyWherePossible(beforeState)
          return true
        }
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs, beforeState)
      }

      if (clauseLevel) return false

      if (cxt in [nom, acc, gen, dat, poDat] && oldArgs.noun && newArgs.noun && conj != 'but') {
        return doMerge(state, cxt, oldArgs, newArgs, 'noun', update, seqs, beforeState)
      }
      if (cxt in [preposition] && oldArgs.prep == newArgs.prep) {
        update.addAll new Mite(newArgs + [repeated:true], cxt).unifyWherePossible(beforeState)
        return true
      }
      if (cxt in [gen] && oldArgs.head && newArgs.head && !newArgs.noun) {
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs, beforeState)
      }
      if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
        return doMerge(state, cxt, oldArgs, newArgs, 'possessor', update, seqs, beforeState)
      }
      if (cxt == possessive && oldArgs.head && newArgs.head) {
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs, beforeState)
      }
    }

    return false
  }


  private boolean doMerge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, String prop, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs, ParsingState beforeState) {
    Variable first = (Variable) oldArgs[prop]
    Variable existingSeq = first.frame(state.chart).f('member') ? first : first.frame(state.chart).usages('member')[0]?.var
    if (existingSeq) {
      def oldConj = existingSeq.frame(state.chart).s('conj')
      if (!oldConj || oldConj == state[seq]?.conj) {
        update.addAll joinSeq(newArgs, state, cxt, existingSeq, oldArgs, prop, beforeState)
        return true
      }
    }

    Variable second = newArgs[prop]
    Variable multi = joinedVar(seqs, first, second)
    if (first.light && second.light) {
      multi = multi.lightVar
    }
    update << new Mite(aSeqStart(), multi:multi, first:first, second:second, conj:state[seq]?.conj, distinguish:state[preposition]?.repeated)
    update.addAll new Mite(newArgs + [(prop):multi, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt).unifyWherePossible(beforeState)
    return true
  }

  private Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    return multi
  }

  private Construction aSeqStart() {
    Reference<Construction> seqStart = []
    seqStart.set(Construction.cxt('seqStart') { ParsingState st, Map args ->
      st = st.assign(args.multi, 'member', args.first)
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      if (args.distinguish) {
        st = st.assign(args.second, 'distinguished_in', args.multi)
      }
      st.assign(args.multi, 'member', args.second).satisfied(seqStart.get())
    })
    return seqStart.get()
  }

  static Construction commaList = Construction.cxt('commaList') { state, args ->
    state
  }


  static List<Mite> joinSeq(Map newArgs, ParsingState state, Construction cxt, Variable seqVar, Map oldArgs, String property, ParsingState beforeState) {
    Reference<Construction> seqNext = []
    seqNext.set(Construction.cxt('seqNext') { ParsingState st, Map args ->
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      st = st.assign(args.multi, 'member', args.next)
      st.satisfied(seqNext.get())
    })
    def newMember = newArgs[property]
    return [new Mite(seqNext.get(), multi:seqVar, next:newMember, conj:state[seq]?.conj)] +
            new Mite(newArgs + [(property):seqVar, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt).unifyWherePossible(beforeState)

  }

  @Override
  public String toString() {
    return "SeqInterceptor{" +
           "before=" + before +
           '}';
  }
}
