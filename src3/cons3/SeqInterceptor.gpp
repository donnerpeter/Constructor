package cons3

import static cons3.Construction.cxt

/**
 * @author peter
 */
class SeqInterceptor implements Interceptor, RussianConstructions {
  ParsingState before
  String conj

  SeqInterceptor(ParsingState before, String conj) {
    this.before = before
    this.conj = conj
  }

  int findSimilar(List<Contribution> history, Map<Construction, Map> constructions) {
    int i = 0
    for (old in history) {
      if (Parser.areSimilar(old.apps, constructions)) {
        return i
      }
      if (old.apps[nom]?.head && !old.apps[nom].noun && (constructions[poDat]?.hasNoun || constructions[gen]?.hasNoun)) {
        return -1
      }
      i++
    }
    return -1
  }

  boolean agree(Map nom1, Map nom2) {
    String agr1 = nom1.agr
    String agr2 = nom2.agr
    if (agr1 == null) return agr2 == null

    return agrUnifiable(agrGender(agr1), agrGender(agr2)) &&
           agrUnifiable(agrNumber(agr1), agrNumber(agr2)) &&
           agrUnifiable(agrPerson(agr1), agrPerson(agr2))
  }

  static String agrGender(String agr) { return agr == 'masc' ? 'masc' : agr == 'fem' ? 'fem' : null }
  static String agrNumber(String agr) { return agr.endsWith('pl') ? 'pl' : agr.endsWith('sg') || agr in ['masc', 'fem'] ? 'sg' : null }
  static String agrPerson(String agr) { return agr.startsWith('3') ? '3' : null }
  boolean agrUnifiable(String a1, String a2) { return a1 == null || a2 == null || a1 == a2 }

  ParsingState intercept(Map<Construction, Map> constructions, ParsingState state, Function2<Map<Construction, Map>, ParsingState, ParsingState> base) {
    List<Contribution> history = before.history

    //todo a wiser conj limit
    def limit = history.reverse().findIndexOf { Contribution it -> it.before.situation == state.situation }
    if (limit > 0) {
      history = history.subList(0, history.size() - limit)
    }
    def similar = findSimilar(history, constructions)
    //todo exclude prepositions in a generic way
    if (similar >= 0 && !(poDat in constructions && preposition in constructions)) {
      Update update = new Update(FLinkedMap.emptyMap)
      def seqs = [:]
      boolean merged = false

      def oldApps = history[similar].apps
      if (conj == 'but' && oldApps[nom]?.head && constructions[nom]?.head) {
        def seqVar = new Variable()
        state = state.assign(seqVar, 'member', oldApps[nom].head).assign(seqVar, 'conj', 'but').assign(seqVar, 'member', constructions[nom].head).
                inhibit(seq, comeScalarly)
        if (before[nom]?.noun && !constructions[nom].noun && agree(oldApps[nom], constructions[nom])) {
          state = state.inhibit(nom).apply((nom):[noun:before[nom].noun])
        }
        return base(constructions, state)
      }

      for (cxt in constructions.keySet()) {
        def oldArgs = oldApps[cxt]
        def newUpdate = merge(state, cxt, oldArgs, constructions[cxt], update, seqs)
        merged |= newUpdate != null
        update = newUpdate ?: update.addCxt(constructions[cxt], cxt)
      }

      if (merged) {
        def modernHistory = state.history
        ParsingState rollback = history[similar].before
        rollback = rollback[numQuantifier]?.prev ?: rollback //todo a more generic way of finding a phrase start
        state = state.clearConstructions().restore(rollback)

        if (seqs.isEmpty()) { // continuing a sequence
          state = state.inhibit(seq)
        }

        def lastConj = modernHistory.findIndexOf { Contribution it -> it.apps[seq] != null }
        if (lastConj) {
          for (contribution in modernHistory.subList(0, lastConj).reverse()) {
            state = base(contribution.apps, state)
          }
        }
        return base(update.map.reverse(), state)
      }
    }
    if (constructions[nom]?.head) {
      state = state.inhibit(seq)
    }

    return base(constructions, state)
  }

  Map<String, Object> getArgs(Construction construction, ParsingState state) {
    null
  }


  private Update merge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, Update update, Map<Pair<Variable, Variable>, Variable> seqs) {
    if (oldArgs != null) {
      if (conj == 'but') {
        return null
      }

      if (cxt in [nom, acc, gen, poDat] && oldArgs.noun && newArgs.noun) {
        return doMerge(state, cxt, oldArgs, newArgs, 'noun', update, seqs)
      }
      if (cxt in [nom] && oldArgs.head && newArgs.head && !newArgs.noun && before[cxt]?.head) {
        return doMerge(state, cxt, before[cxt] ?: oldArgs, newArgs, 'head', update, seqs)
      }
      if (cxt in [gen] && oldArgs.head && newArgs.head && !newArgs.noun) {
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs)
      }
      if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
        return doMerge(state, cxt, oldArgs, newArgs, 'possessor', update, seqs)
      }
    }

    return null
  }


  private Update doMerge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, String prop, Update update, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldArgs[prop]
    Variable existingSeq = first.frame(state.chart).f('member') ? first : first.frame(state.chart).usages('member')[0]?.var
    if (existingSeq) {
      def oldConj = existingSeq.frame(state.chart).s('conj')
      if (!oldConj || oldConj == conj) {
        return joinSeq(newArgs, state, cxt, existingSeq, oldArgs, prop, update)
      }
    }

    def second = newArgs[prop]
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi

    Reference<Construction> seqStart = []
    seqStart.set(Construction.cxt('seqStart') { ParsingState st, Map args ->
      st = st.assign(args.multi, 'member', args.first)
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      if (args.distinguish) {
        st = st.assign(args.second, 'distinguished_in', args.multi)
      }
      st.assign(args.multi, 'member', args.second).satisfied(seqStart.get())
    })

    return update.
            addCxt(seqStart.get(), multi:multi, first:first, second:second, conj:conj, distinguish:state[cxt]?.repeated).
            addCxt(oldArgs + [(prop): multi, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt, ParsingState.mergeInits((Closure)oldArgs.init, (Closure)newArgs.init))
  }


  static Update joinSeq(Map newArgs, ParsingState state, Construction cxt, Variable seqVar, Map oldArgs, String property, Update update) {
    Reference<Construction> seqNext = []
    seqNext.set(Construction.cxt('seqNext') { ParsingState st, Map args ->
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      st.assign(args.multi, 'member', args.next).satisfied(seqNext.get())
    })
    def newMember = newArgs[property]
    return update.
            addCxt(seqNext.get(), multi:seqVar, next:newMember, conj:state[seq]?.conj).
            addCxt(oldArgs + [(property): seqVar, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt, ParsingState.mergeInits((Closure)oldArgs.init, (Closure)newArgs.init))

  }

}
