package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor implements Interceptor, RussianConstructions {
  ParsingState before
  String conj

  private int findSimilar(List<Contribution> history, List<Mite> constructions) {
    int i = 0
    for (old in history) {
      if (Parser.areSimilar(old.apps, constructions)) {
        return i
      }
      if (constructions.find { it.cxt == nom && it.contents.head }) {
        if (old.apps.find { it.cxt == complementizer && it.contents.frame || it.cxt == directSpeech && it.contents.hasColon }) {
          return -1
        }
      }
      
      if (old.apps.find { it.cxt == nom && it.contents.head && !it.contents.noun} && !constructions.find { it.cxt == complementizer } &&
        (constructions.find { it.cxt in [dat, gen, nom, acc] && it.contents.noun || it.cxt == preposition })) {
        return -1
      }

      if (old.apps.find { it.cxt == dat && it.contents.noun} && constructions.find { it.cxt in [acc] && it.contents.noun }) {
        return -1
      }

      i++
    }
    return -1
  }

  static boolean agree(agr1, agr2) {
    return agrUnifiable(agrGender((String)agr1), agrGender((String)agr2)) &&
           agrUnifiable(agrNumber((String)agr1), agrNumber((String)agr2)) &&
           agrUnifiable(agrPerson((String)agr1), agrPerson((String)agr2))
  }

  static String agrGender(String agr) { return agr == 'masc' ? 'masc' : agr == 'fem' ? 'fem' : null }
  static String agrNumber(String agr) { return agr?.endsWith('pl') ? 'pl' : agr?.endsWith('sg') || agr in ['masc', 'fem'] ? 'sg' : null }
  static String agrPerson(String agr) { return agr?.startsWith('3') ? '3' : null }
  static boolean agrUnifiable(String a1, String a2) { return a1 == null || a2 == null || a1 == a2 }

  ParsingState intercept(List<Mite> constructions, ParsingState state, Function2<List<Mite>, ParsingState, ParsingState> base) {
    List<Contribution> history
    int similar

    List<Contribution> precedent = state[seq]?.precedent
    if (precedent != null) {
      similar = findSimilar(precedent, constructions)
      if (similar >= 0) {
        history = precedent.reverse()
        similar = history.size() - 1 - similar
      }
    } else {
      history = before.history
      similar = before[preposition] == null && state[preposition] != null && !state[preposition].hasNoun ?
        -1 : findSimilar(history, constructions) //todo honor hierarchy in conj processing
    }

    if (similar >= 0) {
      Update update = new Update()
      def seqs = [:]
      boolean merged = false

      def oldApps = history[similar].apps
      LinkedHashSet<Variable> toSeparate = []

      for (mite in constructions) {
        Mite oldArgs = oldApps.find { it.cxt == mite.cxt }
        def newUpdate = merge(state, mite.cxt, oldArgs?.contents, mite.contents, update, seqs, declOrQuestionComp in constructions)
        merged |= newUpdate != null
        update = newUpdate ?: update.addMites(mite)
        if (newUpdate && oldArgs) {
          oldArgs.contents.values().each { if (it instanceof Variable) toSeparate << it.base }
        }
      }

      if (merged) {
        def modernHistory = state.history
        if (precedent == null) {
          ParsingState rollback = before[commaList]?.rollback ?: history[similar].before
          rollback = rollback[numQuantifier]?.prev ?: rollback //todo a more generic way of finding a phrase start
          if (conj == null) {
            update = update.addCxt(commaList, rollback:rollback)
          }
          def oldVerb = state[verbHolder]?.head
          state = state.clearConstructions().restore(rollback).separateUnifications(rollback, toSeparate)
          if (oldApps.find { it.cxt == nom && it.contents.head } && constructions.find { it.cxt == nom && it.contents.head }) {
            if (conj == 'but') {
              state = state.inhibit(nom, acc)
            }
            state = state.inhibit(verbHolder, verbEmphasis)
            if (oldVerb) {
              state = state.apply((verbHolder):[head:oldVerb])
            }
          }

          def lastConj = modernHistory.findLastIndexOf { Contribution it -> it.before[seq]?.interceptor == (SeqInterceptor)this }
          if (lastConj >= 0) {
            for (contribution in modernHistory.subList(0, lastConj + 1).reverse()) {
              state = state.apply(contribution)
            }
          }
        } else {
          state = state.inhibit(seq)
        }


        if (similar > 0) {
          List<Contribution> remainingPrecedent = history[0..<similar].reverse() //todo alex infer
          if (history[similar].apps.find { it.cxt == poDat }) { //todo a generic way of finding sequence precedents
            def nounContribution = remainingPrecedent.find { it.apps.any { it.cxt == dat && it.contents.noun } }
            if (nounContribution) {
              update = update.addCxt(seq, precedent:[nounContribution], interceptor:new SeqInterceptor(state, conj))
            }
          }
        }
        return update.apply(state)
      }
    }

    return base(constructions, state)
  }

  private Update merge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, Update update, Map<Pair<Variable, Variable>, Variable> seqs, boolean clauseLevel) {
    if (oldArgs != null) {
      if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
        return doMerge(state, cxt, oldArgs, newArgs, 'elaboration', update, seqs)
      }
      if (cxt == complementizer && oldArgs.mainVerb && newArgs.mainVerb && before[cxt]?.frame && before[cxt].mainVerb) {
        return doMerge(state, cxt, oldArgs, newArgs, 'mainVerb', update, seqs)
      }
      if (cxt == declOrQuestionComp && !before[cxt]?.head && oldArgs.comp && newArgs.comp && oldArgs.comp != state[cxt]?.head) {
        return doMerge(state, cxt, oldArgs, newArgs, 'comp', update, seqs)
      }
      if (cxt in [nom] && oldArgs.head && newArgs.head) {
        if (conj == 'but' && !agree(before[cxt]?.agr, newArgs.agr)) {
          Variable second = newArgs.head
          Variable first = oldArgs.head
          return update.addCxt(aSeqStart(), multi: joinedVar(seqs, first, second), first:first, second:second, conj:conj).addCxt(newArgs, nom)
        }
        if (before[cxt]?.noun) {
          newArgs += [noun:before[cxt].noun]
          update = update.addCxt(reflexiveHolder, noun:before[cxt].noun)
        }
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs)
      }

      if (clauseLevel) return null

      if (cxt in [nom, acc, gen, dat, poDat] && oldArgs.noun && newArgs.noun && conj != 'but') {
        return doMerge(state, cxt, oldArgs, newArgs, 'noun', update, seqs)
      }
      if (cxt in [poDat] && !oldArgs.noun && !newArgs.noun && before[cxt]?.noun && !newArgs.head) {
        def newNoun = new Variable()
        return doMerge(state, cxt, oldArgs + [noun:before[cxt].noun], newArgs + [noun:newNoun, unmergedNoun:newNoun], 'noun', update, seqs)
      }
      if (cxt in [gen] && oldArgs.head && newArgs.head && !newArgs.noun) {
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs)
      }
      if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
        return doMerge(state, cxt, oldArgs, newArgs, 'possessor', update, seqs)
      }
      if (cxt == possessive && oldArgs.head && newArgs.head) {
        return doMerge(state, cxt, oldArgs, newArgs, 'head', update, seqs)
      }
    }

    return null
  }


  private Update doMerge(ParsingState state, Construction cxt, Map oldArgs, Map newArgs, String prop, Update update, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldArgs[prop]
    Variable existingSeq = first.frame(state.chart).f('member') ? first : first.frame(state.chart).usages('member')[0]?.var
    if (existingSeq) {
      def oldConj = existingSeq.frame(state.chart).s('conj')
      if (!oldConj || oldConj == conj) {
        return joinSeq(newArgs, state, cxt, existingSeq, oldArgs, prop, update)
      }
    }

    Variable second = newArgs[prop]
    Variable multi = joinedVar(seqs, first, second)
    if (first.light && second.light) {
      multi = multi.lightVar
    }

    return update.
            addCxt(aSeqStart(), multi:multi, first:first, second:second, conj:conj, distinguish:newArgs.repeated).
            addCxt(newArgs + [(prop):multi, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt)
  }

  private Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    return multi
  }

  private Construction aSeqStart() {
    Reference<Construction> seqStart = []
    seqStart.set(Construction.cxt('seqStart') { ParsingState st, Map args ->
      st = st.assign(args.multi, 'member', args.first)
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      if (args.distinguish) {
        st = st.assign(args.second, 'distinguished_in', args.multi)
      }
      st.assign(args.multi, 'member', args.second).satisfied(seqStart.get())
    })
    return seqStart.get()
  }

  static Construction commaList = Construction.cxt('commaList') { state, args ->
    state
  }


  static Update joinSeq(Map newArgs, ParsingState state, Construction cxt, Variable seqVar, Map oldArgs, String property, Update update) {
    Reference<Construction> seqNext = []
    seqNext.set(Construction.cxt('seqNext') { ParsingState st, Map args ->
      if (args.conj) {
        st = st.assign(args.multi, 'conj', args.conj)
      }
      st = st.assign(args.multi, 'member', args.next)
      st.satisfied(seqNext.get())
    })
    def newMember = newArgs[property]
    return update.
            addCxt(seqNext.get(), multi:seqVar, next:newMember, conj:state[seq]?.conj).
            addCxt(newArgs + [(property):seqVar, xor:ParsingState.mergeXor(oldArgs, newArgs)], cxt)

  }

}
