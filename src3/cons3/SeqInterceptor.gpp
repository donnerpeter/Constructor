package cons3

import groovy.transform.TupleConstructor

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor {
  final ParsingState before
  final Mite self
  final List<Mite> constructions
  final ParsingState state

  SeqInterceptor(Mite mite, List<Mite> constructions, ParsingState state) {
    before = mite.contents.beforeComma ?: state.findState(mite.firstAtom).prevState
    self = mite
    this.constructions = constructions
    this.state = state
  }

  private boolean isButAfterComma() {
    return self.contents.conj == ',' && !self.contents.multi &&
           constructions.find { it.cxt == seq && it.contents.conj == 'but' }
  }

  Collection<Mite> enrichUpdate() {
    if (isButAfterComma()) {
      return seq(beforeComma:before).unifyWherePossible(constructions, false, false)
    }

    if (self.contents.mergedWith) {
      return []
    }

    def similar = findBestSimilarContribution()
    if (!similar) return []

    List<Mite> result = []

    Map<Pair<Variable, Variable>, Variable> seqs = [:]

    ParsingState mergePoint = null
    LinkedHashSet newXors = []

    for (mite in constructions) {
      Mite oldMite = similar.ownMites.reverse().find { it.atom && it.isSimilarTo(mite) }
      if (oldMite) {
        def nextPoint = merge(oldMite, mite, result, seqs)
        if (nextPoint) {
          mergePoint = nextPoint
          newXors.addAll(calcSeqXors(oldMite, mite, mergePoint))
        } else if (mite.cxt == nomSubject) {
          def oldState = before.findState(oldMite)
          def prevSeq = findPrevSeq(oldState, oldMite, 'head', true)
          if (!canJoinSeq(prevSeq)) {
            mergePoint = oldState
            Variable first = prevSeq?.contents?.second ?: oldMite.contents.head
            def newMulti = obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
            if (prevSeq) {
              Variable veryFirst = prevSeq.contents.first
              result << prevSeq.firstAtom.unify(seq(mergedWith:prevSeq.contents.mergedWith, multi:joinedVar([:], veryFirst, newMulti), second:newMulti, first:veryFirst, xor:prevSeq.contents.xor))
            }
          } else {
            mergePoint = prevSeq.firstMemberState
            Variable first = prevSeq.contents.multi
            obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
          }
        }
      }
    }

    if (mergePoint != null) {
      result.addAll(unifyHeadsWithMergePoint(similar))
      result.addAll(mergePoint.prevState.enrichUpdate(result, state))
      seqs.each { pair, multi ->
        result.add(0, self.unify(seq(mergedWith:mergePoint, multi:multi, second:pair.second, first:(multi == pair.first ? null : pair.first), xor:newXors)))
      }
    }

    return result
  }

  private LinkedHashSet calcSeqXors(Mite oldMite, Mite newMite, ParsingState nextPoint) {
    LinkedHashSet newXors = []

    def oldMerge = before.findState(oldMite)?.ownMites?.find { it.cxt == seq && it.contents.mergedWith == nextPoint }
    if (!oldMerge) {
      newXors.addAll(oldMite.primaries)
    }
    newXors.addAll(newMite.primaries)

    Set xor = Mite.mergeXor(oldMite.contents, newMite.contents)
    if (xor) {
      for (id in xor) {
        List<Mite> members = constructions.findAll { it.contents.xor && id in (Set) it.contents.xor }
        def existing = state.network.groups[id]
        if (existing) {
          members.addAll(existing)
        }
        assert members
        newXors << new ExternalContradiction(id.toString(), members)
      }
    }

    return newXors
  }

  private ParsingState findBestSimilarContribution() {
    def states = findAllSimilarContributions()
    if (!states) return null

    def closest = states[0]
    Mite numQ = closest.ownMites.find { it.cxt == numQuantifier && it.contents.num && ((Variable) it.contents.noun).hard }
    if (numQ) {
      def better = closest.prevVisibleState
      if (better in states) {
        return better
      }
    }

    return closest
  }
  private List<ParsingState> findAllSimilarContributions() {
    before.hierarchy.findAll { state -> hasSimilarOwnMite(state) }
  }

  private boolean hasSimilarOwnMite(ParsingState state) {
    def similar = constructions.find { findSimilarOwnMite(it, state) }
    if (similar != null) {
      return true
    }
    return false
  }

  private static Mite findSimilarOwnMite(Mite mite, ParsingState inState) {
    if (mite.cxt in [nom, acc, gen, genArg1] && mite.contents.head) return null
    if (mite.cxt in [sentenceHolder, noArg, verbalModifier, verbHolder, quotedName]) return null
    return inState.ownMites.find { it.isSimilarTo(mite) }
  }

  private List<Mite> unifyHeadsWithMergePoint(ParsingState mergePoint) {
    List<Mite> result = []
    for (newMite in state.currentContribution) {
      def cxt = newMite.cxt
      def attr = cxt in [nom, acc, gen, dat, poDat] ? 'noun' : cxt == possessive ? 'possessor' : null
      Mite oldPure = mergePoint.ownMites.find { it.isSimilarTo(newMite) && it.atom && agree(newMite, it) }
      if (attr && newMite.contents[attr] && newMite.contents.head && newMite.atom && oldPure) {
        Mite unified = argSharing(cxt:cxt, var:newMite.contents[attr], xor:newMite.xor + [newMite] as LinkedHashSet)
        List<Mite> oldUnified = mergePoint.ownMites.findAll { it.cxt == argSharing && it.contents.cxt == cxt }
        if (!oldUnified) {
          oldUnified << argSharing(cxt:cxt, xor:oldPure.xor + [oldPure] as LinkedHashSet, var:oldPure.contents[attr])
        }
        for (oldMite in oldUnified) {
          result << oldMite.unify(argSharing(var:newMite.contents[attr]))
          for (atom in oldMite.primaries.findAll { it.contents.var } ) {
            unified = argSharing(var:atom.contents.var).unify(unified)
          }
        }
        result << unified
      }
    }
    return result
  }

  private static boolean agree(Mite mite, Mite oldMite) {
    return mite.contents.agrNumber == oldMite.contents.agrNumber
  }

  private static Mite findPrevSeq(ParsingState state, Mite mite, String property, boolean topLevel) {
    return state.ownMites.find {
      it.cxt == seq &&
      it.contents.mergedWith && it.contents.multi &&
      (topLevel ? it.contents.second : it.contents.multi) == mite.contents[property]
    }
  }

  private static boolean canJoinSeq(Mite prevSeq) {
    return prevSeq && prevSeq.contents.conj != 'but' && prevSeq.contents.conj != 'and'
  }

  private ParsingState merge(Mite oldMite, Mite newMite, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    def oldArgs = oldMite.contents
    def newArgs = newMite.contents
    def cxt = oldMite.cxt
    if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
      return doMerge(oldMite, newArgs, 'elaboration', update, seqs)
    }
    if (cxt == complementizer && oldArgs.content && newArgs.content && before[cxt]?.frame && before[cxt].content) {
      return doMerge(oldMite, newArgs, 'content', update, seqs)
    }
    if (cxt == declOrQuestionComp && oldArgs.comp && newArgs.comp) {
      if (oldArgs.comp == before[complementizer]?.frame &&
          before.visibleMites[declOrQuestionComp]?.any { before[complementizer]?.content == it.contents.head } ) {
        return null
      }
      return doMerge(oldMite, newArgs, 'comp', update, seqs)
    }

    if (cxt in [nom, acc, gen, dat, poDat] && newArgs.noun && !newArgs.head) {
      if (cxt == gen && state.miteList.find { it.cxt == preposition } &&
          !state.findState(oldMite).prevState.miteList.find { it.cxt == preposition }) {
        return null
      }
      return doMerge(oldMite, newArgs, 'noun', update, seqs)
    }
    if (cxt == possessive && oldArgs.possessor && newArgs.possessor && !newArgs.head) {
      return doMerge(oldMite, newArgs, 'possessor', update, seqs)
    }
    if (cxt == boxedForPreposition && oldArgs.prep == newArgs.prep) {
      List<Mite> oldBoxed = oldArgs.boxed
      List<Mite> newBoxed = newArgs.boxed
      def oldAccording = oldBoxed.find { it.cxt == accordingTo }
      def newAccording = newBoxed.find { it.cxt == accordingTo }
      def mergePoint = suggestMergePoint(oldMite, 'boxed')
      if (oldAccording && newAccording && mergePoint) {
        update << boxedForPreposition(prep:oldArgs.prep, boxed:[createMergedMite(oldAccording, 'content', newAccording.contents, seqs)])
        return mergePoint
      }
    }
    if (cxt == accordingTo && oldArgs.content && newArgs.content) {
      def mPoint = doMerge(oldMite, newArgs, 'content', update, seqs)
      update << new Mite(var:newArgs.content, Parser.varCxt(distinguished_in:newArgs.head))
      if (!mPoint.contribution.find { it.cxt == accordingTo } && mPoint.visibleMites[preposition]) {
        return mPoint.hierarchy[1]
      }
      return mPoint
    }
    return null
  }

  private ParsingState suggestMergePoint(Mite oldMite, String prop) {
    def oldMiteState = before.findState(oldMite)
    def prevSeq = findPrevSeq(oldMiteState, oldMite, prop, false)
    if (prevSeq && !canJoinSeq(prevSeq)) {
      return null
    }
    return prevSeq?.firstMemberState ?: oldMiteState
  }

  private ParsingState doMerge(Mite oldMite, Map newArgs, String prop, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    def mPoint = suggestMergePoint(oldMite, prop)
    if (mPoint) {
      update << createMergedMite(oldMite, prop, newArgs, seqs)
    }
    return mPoint
  }

  private Mite createMergedMite(Mite oldMite, String prop, Map newArgs, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldMite.contents[prop]
    Variable second = newArgs[prop]
    Variable multi = obtainMergedVariable(first, second, seqs)
    return oldMite.cxt(newArgs + [(prop):multi, xor:Mite.mergeXor(oldMite.contents, newArgs)])
  }

  private Variable obtainMergedVariable(Variable first, Variable second, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable multi = first.frame(state.chart).f('member') ? first : null
    if (multi) {
      def oldConj = multi.frame(state.chart).s('conj')
      if (!oldConj || oldConj == state[seq]?.conj) {
        def pair = new Pair(multi, second)
        if (!seqs[pair]) {
          seqs[pair] = multi
        }
      }
    } else {
      multi = joinedVar(seqs, first, second)
    }
    return multi
  }


  private static ParsingState getFirstMemberState(Mite prevSeq) {
    return prevSeq.contents.mergedWith
  }

  private static Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, Variable second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    if (first.light && second.light) {
      multi = multi.lightVar
    }
    return multi
  }

  @Override
  public String toString() {
    return "SeqInterceptor{" + "before=" + before + '}';
  }
}
