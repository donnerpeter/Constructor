package cons3

import groovy.transform.TupleConstructor

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor implements RussianConstructions {
  final ParsingState before
  final Mite self
  final List<Mite> constructions
  final ParsingState state
  final boolean clauseLevel

  SeqInterceptor(Mite mite, List<Mite> constructions, ParsingState state) {
    before = mite.contents.beforeComma ?: state.findState(mite.firstAtom).prevState
    self = mite
    this.constructions = constructions
    this.state = state
    clauseLevel = constructions.any { it.cxt == declOrQuestionComp && it.contents.comp }
  }

  Collection<Mite> enrichUpdate() {
    if (self.contents.conj == ',' && !self.contents.multi) {
      def buts = constructions.findAll { it.cxt == seq && it.contents.conj == 'but' }
      if (buts) {
        return seq(beforeComma:before).unifyWherePossible(buts, false, false)
      }
    }

    if (self.contents.precedent == null && self.contents.mergedWith ||
        constructions.find { it.cxt == clauseEllipsis && it.contents.guard }) {
      return []
    }

    List<Mite> result = []

    Map<Pair<Variable, Variable>, Variable> seqs = [:]

    ParsingState mergePoint = null
    LinkedHashSet newXors = []
    for (mite in constructions) {
      Mite oldMite = before.visibleMites[mite.cxt]?.reverse()?.find { it.atom && it.isSimilarTo(mite) }
      if (oldMite) {
        def nextPoint = merge(oldMite, mite, result, seqs)
        if (nextPoint) {
          def prev = before.findState(oldMite)
          def oldMerge = prev?.ownMites?.find { it.cxt == seq && it.contents.mergedWith == nextPoint }
          if (!oldMerge) {
            newXors.addAll(oldMite.primaries)
          }
          newXors.addAll(mite.primaries)
          mergePoint = nextPoint
        } else if (mite.cxt == nomSubject) {
          def oldState = before.findState(oldMite)
          def prevSeq = findPrevSeq(oldState, oldMite, 'head', true)
          if (!canJoinSeq(prevSeq)) {
            mergePoint = oldState
            Variable first = prevSeq?.contents?.second ?: oldMite.contents.head
            def newMulti = obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
            if (prevSeq) {
              Variable veryFirst = prevSeq.contents.first
              result << prevSeq.firstAtom.unify(seq(mergedWith:prevSeq.contents.mergedWith, multi:joinedVar([:], veryFirst, newMulti), second:newMulti, first:veryFirst, xor:prevSeq.contents.xor))
            }
          } else {
            mergePoint = prevSeq.firstMemberState
            Variable first = prevSeq.contents.multi
            obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
          }
        }
      }
    }

    if (mergePoint != null) {
      for (mite in constructions) {
        Mite oldMite = mergePoint.ownMites.find { it.atom && it.isSimilarTo(mite) }
        if (oldMite && mite.cxt in [nom, acc, gen, dat, poDat] && mite.contents.noun && mite.contents.head && agree(mite, oldMite)) {
          result << mite.cxt(noun:oldMite.contents.noun).unify(mite)
        }
      }
      result.addAll(mergePoint.prevState.enrichUpdate(result))
      seqs.each { pair, multi ->
        result.add(0, self.unify(seq(mergedWith:mergePoint, multi:multi, second:pair.second, first:(multi == pair.first ? null : pair.first), xor:newXors)))
      }

    } else if (constructions.find { it.cxt == declOrQuestionComp && it.contents.comp }) {
      result.add(self.unify(seq(questionLevel:'true')))
    }

    return result
  }

  private boolean agree(Mite mite, Mite oldMite) {
    return mite.contents.agrNumber == oldMite.contents.agrNumber
  }

  private Mite findPrevSeq(ParsingState state, Mite mite, String property, boolean topLevel) {
    return state.ownMites.find {
      it.cxt == seq &&
      it.contents.mergedWith && it.contents.multi &&
      (topLevel ? it.contents.second : it.contents.multi) == mite.contents[property]
    }
  }

  private boolean canJoinSeq(Mite prevSeq) {
    return prevSeq && prevSeq.contents.conj != 'but'
  }

  private ParsingState merge(Mite oldMite, Mite newMite, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    def oldArgs = oldMite.contents
    def newArgs = newMite.contents
    def cxt = oldMite.cxt
    if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
      return doMerge(oldMite, newArgs, 'elaboration', update, seqs)
    }
    if (cxt == complementizer && oldArgs.content && newArgs.content && before[cxt]?.frame && before[cxt].content) {
      return doMerge(oldMite, newArgs, 'content', update, seqs)
    }
    if (cxt == declOrQuestionComp && oldArgs.comp && newArgs.comp) {
      if (oldArgs.comp == before[complementizer]?.frame &&
          before.visibleMites[declOrQuestionComp]?.any { before[complementizer]?.content == it.contents.head } ) {
        return null
      }
      return doMerge(oldMite, newArgs, 'comp', update, seqs)
    }

    if (clauseLevel) return null

    if (cxt in [nom, acc, gen, dat, poDat] && newArgs.noun && !newArgs.head) {
      return doMerge(oldMite, newArgs, 'noun', update, seqs)
    }
    if (cxt in [preposition] && oldArgs.prep == newArgs.prep) {
      def mergePoint = findMergePoint(oldMite, 'x')
      update.addAll new Mite(newArgs + [repeated:true], cxt)
      return mergePoint
    }
    if (cxt in [gen] && oldArgs.head && newArgs.head) {
      return doMerge(oldMite, newArgs, 'head', update, seqs)
    }
    if (cxt == possessive && oldArgs.possessor && newArgs.possessor) {
      return doMerge(oldMite, newArgs, 'possessor', update, seqs)
    }
    if (cxt == possessive && oldArgs.head && newArgs.head) {
      return doMerge(oldMite, newArgs, 'head', update, seqs)
    }
    return null
  }


  private ParsingState doMerge(Mite oldMite, Map newArgs, String prop, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    update << createMergedMite(oldMite, prop, newArgs, seqs)
    def mPoint = findMergePoint(oldMite, prop)
    assert mPoint
    return mPoint
  }

  private Mite createMergedMite(Mite oldMite, String prop, Map newArgs, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldMite.contents[prop]
    Variable second = newArgs[prop]
    Variable multi = obtainMergedVariable(first, second, seqs)
    return oldMite.cxt(newArgs + [(prop):multi, xor:Mite.mergeXor(oldMite.contents, newArgs)])
  }

  private Variable obtainMergedVariable(Variable first, Variable second, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable multi = first.frame(state.chart).f('member') ? first : null
    if (multi) {
      def oldConj = multi.frame(state.chart).s('conj')
      if (!oldConj || oldConj == state[seq]?.conj) {
        def pair = new Pair(multi, second)
        if (!seqs[pair]) {
          seqs[pair] = multi
        }
      }
    } else {
      multi = joinedVar(seqs, first, second)
    }
    return multi
  }

  private ParsingState findMergePoint(Mite oldMite, String property) {
    def oldState = before.findState(oldMite)
    def prevSeq = findPrevSeq(oldState, oldMite, property, false)
    return canJoinSeq(prevSeq) ? prevSeq.firstMemberState : oldState
  }

  private static ParsingState getFirstMemberState(Mite prevSeq) {
    return prevSeq.contents.mergedWith
  }

  private Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, Variable second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    if (first.light && second.light) {
      multi = multi.lightVar
    }
    return multi
  }

  @Override
  public String toString() {
    return "SeqInterceptor{" + "before=" + before + '}';
  }
}
