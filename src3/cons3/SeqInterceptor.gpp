package cons3

import groovy.transform.TupleConstructor

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
@TupleConstructor
class SeqInterceptor {
  final ParsingState before
  final Mite self
  final List<Mite> constructions
  final ParsingState state

  SeqInterceptor(Mite mite, List<Mite> constructions, ParsingState state) {
    before = mite.contents.beforeComma ?: state.findState(mite.firstAtom).prevState
    self = mite
    this.constructions = constructions
    this.state = state
  }

  private boolean isButAfterComma() {
    return self.contents.conj == ',' && !self.contents.multi &&
           constructions.find { it.cxt == seq && it.contents.conj == 'but' }
  }

  Collection<Mite> enrichUpdate() {
    if (isButAfterComma()) {
      return seq(beforeComma:before).unifyWherePossible(constructions, false, false)
    }

    if (self.contents.mergedWith || isInsideEllipsisProcessing()) {
      return []
    }

    def similar = findSimilarContribution()
    if (!similar) return []

    List<Mite> result = []

    Map<Pair<Variable, Variable>, Variable> seqs = [:]

    ParsingState mergePoint = null
    LinkedHashSet newXors = []

    for (mite in constructions) {
      Mite oldMite = similar.ownMites.reverse().find { it.atom && it.isSimilarTo(mite) }
      if (oldMite) {
        def nextPoint = merge(oldMite, mite, result, seqs)
        if (nextPoint) {
          def prev = before.findState(oldMite)
          def oldMerge = prev?.ownMites?.find { it.cxt == seq && it.contents.mergedWith == nextPoint }
          if (!oldMerge) {
            newXors.addAll(oldMite.primaries)
          }
          newXors.addAll(mite.primaries)
          mergePoint = nextPoint
        } else if (mite.cxt == nomSubject) {
          def oldState = before.findState(oldMite)
          def prevSeq = findPrevSeq(oldState, oldMite, 'head', true)
          if (!canJoinSeq(prevSeq)) {
            mergePoint = oldState
            Variable first = prevSeq?.contents?.second ?: oldMite.contents.head
            def newMulti = obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
            if (prevSeq) {
              Variable veryFirst = prevSeq.contents.first
              result << prevSeq.firstAtom.unify(seq(mergedWith:prevSeq.contents.mergedWith, multi:joinedVar([:], veryFirst, newMulti), second:newMulti, first:veryFirst, xor:prevSeq.contents.xor))
            }
          } else {
            mergePoint = prevSeq.firstMemberState
            Variable first = prevSeq.contents.multi
            obtainMergedVariable(first, (Variable) mite.contents.head, seqs)
          }
        }
      }
    }

    if (mergePoint != null) {
      result.addAll(unifyHeadsWithMergePoint(mergePoint))
      result.addAll(mergePoint.prevState.enrichUpdate(result, state))
      seqs.each { pair, multi ->
        result.add(0, self.unify(seq(mergedWith:mergePoint, multi:multi, second:pair.second, first:(multi == pair.first ? null : pair.first), xor:newXors)))
      }
    }

    return result
  }

  private Mite isInsideEllipsisProcessing() {
    return constructions.find { it.cxt == clauseEllipsis && it.contents.guard }
  }

  private ParsingState findSimilarContribution() {
    def states = findSimilarContributions()
    if (!states) return null

    def closest = states[0]
    Mite numQ = closest.ownMites.find { it.cxt == numQuantifier && it.contents.num && ((Variable) it.contents.noun).hard }
    if (numQ) {
      def better = closest.prevVisibleState
      if (better in states) {
        return better
      }
    }

    return closest
  }
  private List<ParsingState> findSimilarContributions() {
    before.hierarchy.findAll { state -> constructions.any { findSimilarOwnMite(it, state) } }
  }

  private static Mite findSimilarOwnMite(Mite mite, ParsingState inState) {
    if (mite.cxt == acc && mite.contents.head) return null
    if (mite.cxt in [sentenceHolder, noArg, verbalModifier]) return null
    return inState.contribution.find { it.isSimilarTo(mite) }
  }

  private List<Mite> unifyHeadsWithMergePoint(ParsingState mergePoint) {
    List<Mite> result = []
    for (mite in constructions) {
      Mite oldMite = mergePoint.ownMites.find { it.atom && it.isSimilarTo(mite) }
      if (oldMite) {
        result.addAll(unifyHeadWithMergePoint(oldMite, mite))
      }
    }
    return result
  }

  private static List<Mite> unifyHeadWithMergePoint(Mite oldMite, Mite newMite) {
    if (newMite.cxt in [nom, acc, gen, dat, poDat] && newMite.contents.noun && newMite.contents.head && agree(newMite, oldMite)) {
      return [newMite.cxt(noun:oldMite.contents.noun, inferred:true).unify(newMite)]
    }
    if (newMite.cxt == possessive && newMite.contents.possessor && newMite.contents.head) {
      return [newMite.cxt(possessor:oldMite.contents.possessor).unify(newMite)]
    }
    return []
  }

  private static boolean agree(Mite mite, Mite oldMite) {
    return mite.contents.agrNumber == oldMite.contents.agrNumber
  }

  private static Mite findPrevSeq(ParsingState state, Mite mite, String property, boolean topLevel) {
    return state.ownMites.find {
      it.cxt == seq &&
      it.contents.mergedWith && it.contents.multi &&
      (topLevel ? it.contents.second : it.contents.multi) == mite.contents[property]
    }
  }

  private static boolean canJoinSeq(Mite prevSeq) {
    return prevSeq && prevSeq.contents.conj != 'but'
  }

  private ParsingState merge(Mite oldMite, Mite newMite, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    def oldArgs = oldMite.contents
    def newArgs = newMite.contents
    def cxt = oldMite.cxt
    if (cxt == elaboration && before[cxt]?.head && oldArgs.elaboration && newArgs.elaboration) {
      return doMerge(oldMite, newArgs, 'elaboration', update, seqs)
    }
    if (cxt == complementizer && oldArgs.content && newArgs.content && before[cxt]?.frame && before[cxt].content) {
      return doMerge(oldMite, newArgs, 'content', update, seqs)
    }
    if (cxt == declOrQuestionComp && oldArgs.comp && newArgs.comp) {
      if (oldArgs.comp == before[complementizer]?.frame &&
          before.visibleMites[declOrQuestionComp]?.any { before[complementizer]?.content == it.contents.head } ) {
        return null
      }
      return doMerge(oldMite, newArgs, 'comp', update, seqs)
    }

    if (cxt in [nom, acc, gen, dat, poDat] && newArgs.noun && !newArgs.head) {
      return doMerge(oldMite, newArgs, 'noun', update, seqs)
    }
    if (cxt in [preposition] && oldArgs.prep == newArgs.prep) {
      def mergePoint = findMergePoint(oldMite, 'x')
      update.addAll new Mite(newArgs + [repeated:true], cxt)
      return mergePoint
    }
    if (cxt == possessive && oldArgs.possessor && newArgs.possessor && !newArgs.head) {
      return doMerge(oldMite, newArgs, 'possessor', update, seqs)
    }
    return null
  }


  private ParsingState doMerge(Mite oldMite, Map newArgs, String prop, List<Mite> update, Map<Pair<Variable, Variable>, Variable> seqs) {
    update << createMergedMite(oldMite, prop, newArgs, seqs)
    def mPoint = findMergePoint(oldMite, prop)
    assert mPoint
    return mPoint
  }

  private Mite createMergedMite(Mite oldMite, String prop, Map newArgs, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable first = (Variable) oldMite.contents[prop]
    Variable second = newArgs[prop]
    Variable multi = obtainMergedVariable(first, second, seqs)
    return oldMite.cxt(newArgs + [(prop):multi, xor:Mite.mergeXor(oldMite.contents, newArgs)])
  }

  private Variable obtainMergedVariable(Variable first, Variable second, Map<Pair<Variable, Variable>, Variable> seqs) {
    Variable multi = first.frame(state.chart).f('member') ? first : null
    if (multi) {
      def oldConj = multi.frame(state.chart).s('conj')
      if (!oldConj || oldConj == state[seq]?.conj) {
        def pair = new Pair(multi, second)
        if (!seqs[pair]) {
          seqs[pair] = multi
        }
      }
    } else {
      multi = joinedVar(seqs, first, second)
    }
    return multi
  }

  private ParsingState findMergePoint(Mite oldMite, String property) {
    def oldState = before.findState(oldMite)
    def prevSeq = findPrevSeq(oldState, oldMite, property, false)
    return canJoinSeq(prevSeq) ? prevSeq.firstMemberState : oldState
  }

  private static ParsingState getFirstMemberState(Mite prevSeq) {
    return prevSeq.contents.mergedWith
  }

  private static Variable joinedVar(Map<Pair<Variable, Variable>, Variable> seqs, Variable first, Variable second) {
    Variable multi = seqs[new Pair(first, second)] ?: new Variable("$first&$second")
    seqs[new Pair(first, second)] = multi
    if (first.light && second.light) {
      multi = multi.lightVar
    }
    return multi
  }

  @Override
  public String toString() {
    return "SeqInterceptor{" + "before=" + before + '}';
  }
}
