package cons3

import static cons3.RussianConstructions.*

/**
 * @author peter
 */
class Similarity {
  private static final ArrayList<Construction> importantForSimilarity =
    [nom, acc, gen, dat, instr, prep, poDat, nomSubject,
            possessive, parenthetical, comeScalarly, elaboration, declOrQuestionComp, question]

  static boolean areSimilar(Contribution old, List<Mite> c2) {
    def c1 = old.apps
    def common = c1.findAll { m1 -> m1.cxt in importantForSimilarity && m1.findSimilar(c2) } as List<Mite>
    common = common.findAll { !(it.cxt == possessive && it.contents.head) }

    if (!common) {
      return false
    }

    def nq1 = c1.findAll { it.cxt == numQuantifier }
    def nq2 = c2.findAll { it.cxt == numQuantifier }
    if (nq1 && nq2 && nq1.every { m1 -> nq2.every { m2 -> !m1.isSimilarTo(m2) } }) {
      return false
    }

    return true
  }

  static int findSimilar(List<Contribution> history, List<Mite> constructions) {
   int i = 0
   for (old in history) {
     if (Similarity.areSimilar(old, constructions)) {
       return i
     }
     if (constructions.find { it.cxt == nom && it.contents.head }) {
       if (old.apps.find { it.cxt == complementizer && it.contents.frame || it.cxt == directSpeech && it.contents.hasColon }) {
         return -1
       }
     }

     if (old.apps.find { it.cxt == nom && it.contents.head && !it.contents.noun} && !constructions.find { it.cxt == complementizer } &&
       (constructions.find { it.cxt in [dat, gen, nom, acc] && it.contents.noun || it.cxt == preposition })) {
       return -1
     }

     if (old.apps.find { it.cxt == dat && it.contents.noun} && constructions.find { it.cxt in [acc] && it.contents.noun }) {
       return -1
     }

     i++
   }
   return -1
 }
}
