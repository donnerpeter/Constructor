package cons3

/**
 * @author peter
 */

class Chart {
  final Map<Situation, LinkedHashSet<Assignment<Variable>>> __assignments
  final Map<Variable, Situation> __vars
  private final FList<Variable> currentMetas
  final FLinkedMap<Assignment<Variable>, FList<Variable>> __metas

  Chart() {
    this([:], [:], FList.emptyList, FLinkedMap.emptyMap)
  }

  private Chart(Map<Situation, LinkedHashSet<Assignment<Variable>>> __assignments, Map<Variable, Situation> __vars, FList<Variable> currentMetas, FLinkedMap<Assignment<Variable>, FList<Variable>> metas) {
    this.__assignments = __assignments
    this.__vars = __vars
    this.currentMetas = currentMetas
    this.__metas = metas
  }

  List<Situation> getSituations() {
    def result = (__assignments.keySet()) as LinkedHashSet
    __assignments.values().each {
      it.each {
        if (it.value instanceof Situation) {
          result << (Situation) it.value
        }
      }
    }
    return result as List
  }

  List<Frame> frames(Situation situation) {
    vars(situation).collect { it.frame(this) }
  }

  boolean earlier(Frame f1, String a1, Frame f2, String a2) {
    assert f1.situation == f2.situation
    List<Assignment<Variable>> assignments = __assignments[f1.situation] as List
    def i1 = assignments.findIndexOf { Assignment it -> it.frame == f1.var && it.property == a1 }
    def i2 = assignments.findIndexOf { Assignment it -> it.frame == f2.var && it.property == a2 }
    return i1 < i2
  }

  List<Variable> vars(Situation situation) {
    Set<Variable> set = []
    for (assignment in __assignments[situation]) {
      if (assignment.frame != situation) {
        set << assignment.frame
      }
      if (assignment.value instanceof Variable && !(assignment.value instanceof Situation)) {
        set << (Variable) assignment.value
      }
    }
    return set as List
  }

  List<Assignment<Frame>> allAssignments(Situation situation) {
    __assignments[situation].collect {
      def oldValue = it.value
      def newValue = oldValue instanceof String ? oldValue : ((Variable) oldValue).frame(this)
      Frame newFrame = it.frame.frame(this)
      new Assignment<Frame>(newFrame, it.property, newValue)
    }
  }

  Chart assign(Variable var, Situation situation, String property, def value) {
    assert value instanceof String || value instanceof Variable
    assert var

    Map<Situation, LinkedHashSet<Assignment<Variable>>> newAsss = [:] + __assignments
    def assignment = new Assignment(var, property, value)
    newAsss[situation] = newAsss.get(situation, [] as LinkedHashSet) + [assignment]

    Map<Variable, Situation> newVars = [:] + __vars
    newVars[var] = situation
    return new Chart(newAsss, newVars, currentMetas, __metas + [(assignment):currentMetas])
  }

  String presentable() {
    situations.collect { it.presentable(this) }.findAll { it.trim().size() > 0 }.join("\n--\n")
  }

  Chart startMeta(Variable meta) {
    return new Chart(__assignments, __vars, currentMetas + meta, __metas)
  }

  Chart finishMeta(Variable meta) {
    return new Chart(__assignments, __vars, currentMetas - meta, __metas)
  }
}

class Situation extends Variable {

  String presentable(Chart chart) {
    Map<Variable, String> naming = [:]

    chart.vars(this).eachWithIndex { Variable var, int i ->
      naming[var] = String.valueOf((char)(i + (int)'A'.charAt(0)))
    }
    chart.situations.eachWithIndex { Situation sit, int i ->
      naming[sit] = "#${i + 1}"
    }

    Set<Variable> prevMetas = []
    List<String> lines = []
    for (eq in chart.__assignments[this]) {
      Set<Variable> metas = chart.__metas[eq] as Set
      for (finished in (prevMetas - metas)) {
        lines << "</${naming[finished]}>"
      }
      for (started in (metas - prevMetas)) {
        lines << "<${naming[started]}>"
      }
      prevMetas = metas
      lines << "${naming[eq.frame]}.$eq.property=${ eq.value instanceof String ? eq.value : naming[(Variable)eq.value]}"
    }
    for (finished in prevMetas) {
      lines << "</${naming[finished]}>"
    }
    return lines.join("\n")
  }

}

class Frame {
  final Variable var
  final Situation situation
  final Chart chart

  Frame(Variable var, Situation situation, Chart chart) {
    this.var = var
    this.situation = situation
    this.chart = chart
  }

  String toString() {
    return "$var: ${chart.allAssignments(situation).findAll { it.frame == (Frame) this }}"
  }

  List<Frame> conjArg(String attr) {
    def value = f(attr)
    if (!value) {
      return []
    }

    if (value.f('member')) {
      return value.allAssignments('member').collect { (Frame) it.value }
    }
    return [value]
  }

  Frame f(String attr) {
    def v = allAssignments(attr).reverse()[0]?.value
    if (v instanceof Frame) {
      return (Frame) v
    }

    if (!situation) {
      return null
    }

    if (attr == 'arg1') {
      if (type == 'NEIGHBOURS') {
        return mockFrame(type:'ME')
      }
      if (type in ['MOUTH', 'NOSE', 'JAW']) {
        return mockFrame(type:'SHE')
      }
    }

    return null
  }

  private Frame mockFrame(Map attrs) {
    return new Frame(new Variable(), situation, chart) {

      @Override
      String s(String attr) {
        def s = attrs[attr]
        return s instanceof String ? (String) s : null
      }

    }

  }

  String s(String attr) {
    def v = allAssignments(attr).reverse()[0]?.value
    if (v instanceof String) {
      return (String) v
    }

    if (!situation) {
      return null
    }

    if (attr == 'given') {
      if (this == situation.frame(chart).f('copulaTopic')) {
        return 'true'
      }

      if (type in ['THING', 'HAMMER']) return 'false'
      if (type == 'CASHIER') {
        def shop = chart.frames(situation).find { it.type == 'SHOP' }
        return shop && chart.earlier(shop, 'type', this, 'type') ? 'false' : 'true'
      }
      if (type == 'SHOP') {
        def cashier = chart.frames(situation).find { it.type == 'CASHIER' }
        if (cashier && chart.earlier(cashier, 'type', this, 'type')) {
          return 'true'
        }

        def verb = chart.frames(situation).find { it.f('source') == (Frame) this }
        return verb ? 'true' : 'false'
      }
      return 'true'
    }

    return null
  }

  String getType() { s('type') }

  List<Assignment<Frame>> allAssignments(String attr) {
    if (!situation) {
      return []
    }
    return chart.allAssignments(situation).findAll { it.frame.var == var && it.property == attr }
  }

  boolean equals(o) {
    if (this.is(o)) return true;
    if (!(o instanceof Frame)) return false;

    Frame frame = (Frame) o;

    if (chart != frame.chart) return false;
    if (situation != frame.situation) return false;
    if (var != frame.var) return false;

    return true;
  }

  int hashCode() {
    int result;
    result = var.hashCode();
    result = 31 * result + situation?.hashCode();
    result = 31 * result + chart.hashCode();
    return result;
  }
}

class Variable {
  private static int counter = 0

  final String id

  Variable() {
    id = ((this instanceof Situation) ? 'Var' : 'Sit') + counter++
  }

  String toString() {
    return "$id"
  }

  Frame frame(Chart chart) {
    new Frame(this, chart.__vars[this], chart)
  }

}

class Assignment<T> {
  final T frame
  final String property
  final Object value

  Assignment(T frame, String property, def value) {
    assert frame
    assert property
    this.frame = frame
    this.property = property
    this.value = value
  }

  @Override
  String toString() {
    return "${frameId(frame)}.$property=${stringValue()}"
  }

  String stringValue() {
    return value instanceof String ? value : frameId(value)
  }

  private String frameId(value) {
    return value instanceof Variable ? ((Variable) value).id : ((Frame) value).var.id
  }

  boolean equals(o) {
    if (this.is(o)) return true;
    if (!(o instanceof Assignment)) return false;

    Assignment that = (Assignment) o;

    if (frame != that.frame) return false;
    if (property != that.property) return false;
    if (value != that.value) return false;

    return true;
  }

  int hashCode() {
    int result;
    result = frame.hashCode();
    result = 31 * result + property.hashCode();
    result = 31 * result + value.hashCode();
    return result;
  }
}
