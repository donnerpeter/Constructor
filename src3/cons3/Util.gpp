package cons3
import static cons3.Construction.cxt
/**
 * @author peter
 */
class Util {

  static Integer parseNumber(String word) {
    if (word == null || word.length() == 0 || !Character.isDigit(word.charAt(0))) {
      return null
    }

    try {
      return Integer.parseInt(word)
    } catch (NumberFormatException ignore) {
      return null
    }
  }

  static <T> List<T> lcs(List<T> l1, List<T> l2, Function2<T,T,Boolean> eq) {
    if (!l1 || !l2) return []

    int[][] table = new int[l1.size()][l2.size()]
    for (i in 0..<l1.size()) {
      for (j in 0..<l2.size()) {
        int max = 0;
        if (i > 0 && table[i-1][j] > max) max = table[i-1][j]
        if (j > 0 && table[i][j-1] > max) max = table[i][j-1]
        if (eq(l1[i], l2[j])) {
          int prev = i > 0 && j > 0 ? table[i-1][j-1] : 0
          if (prev + 1 > max) max = prev + 1
        }
        table[i][j] = max
      }
    }

    def result = [null] * table[-1][-1]
    int i = l1.size() - 1
    int j = l2.size() - 1
    int k = result.size() - 1
    while (k >= 0) {
      if (i > 0 && table[i-1][j] == table[i][j]) {
        i--
      } else if (j > 0 && table[i][j-1] == table[i][j]) {
        j--
      } else {
        assert eq(l1[i], l2[j])
        result[k] = l1[i]
        k--
        i--
        j--
      }
    }
    return result
  }

  static <T> boolean intersects(Collection<T> set1, Collection<T> set2) {
    if (set2.size() < set1.size()) {
      def temp = set1; set1 = set2; set2 = temp;
    }
    if (!(set2 instanceof Set)) {
      set2 = new HashSet<T>(set2)
    }
    for (x in set1) {
      if (x in set2) {
        return true
      }
    }
    return false
  }

  static <T> LinkedHashSet<T> intersect(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.retainAll(new HashSet<T>(set2))
    return ts
  }

  static <T> LinkedHashSet<T> minus(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.removeAll(set2)
    return ts
  }

  static Construction commaSurrounded(Construction cxt) {
    cxt.screeningMites { mite, screen ->
      if (mite.contents.comma1 && !mite.contents.content) {
        return screen.hideAll()
      }
      if (mite.contents.content) {
        if (mite.contents.comma2) {
          screen = screen.hideAll()
        }
        def firstAtom = mite.firstAtom
        if (firstAtom?.contents?.comma1) {
          return screen.showEverything(screen.before.findState(firstAtom).prevState)
        }
      }
      return screen
    }.enrichingMites { mite, contribution, state ->
      boolean wantContent = mite.contents.comma1 && !mite.contents.content
      boolean wantComma2 = mite.contents.content && !mite.contents.comma2
      return mite.unifyWherePossible(contribution.findAll { it.cxt == cxt &&
                                                            (wantContent && it.contents.content ||
                                                             wantComma2 && it.contents.comma2)
      })
    }.structural { mite, state, via, up ->
      if (mite.contents.comma1 && !mite.contents.content) {
        return ParsingState.EMPTY
      }
      if (mite.contents.content && mite.contents.comma2) {
        def firstAtom = mite.firstAtom
        if (firstAtom?.contents?.comma1) {
          return state.findState(firstAtom).prevState
        }
      }
    }
  }

  static Construction commonCase(String name) {
    cxt(name, ['+noun', '*head']) { ParsingState state, Map args ->
      state
    }.structural { mite, state, via, up ->
      def parentState = state.findState(mite, 'head')
      return up ? parentState : state.findState(mite.firstAtom)?.prevState
    }
  }

  static Construction commonPrep(String name) {
    cxt(name, ['+noun', '*head']) { ParsingState state, Map args ->
      state
    }.structural { mite, state, via, up ->
      Variable noun = mite.lastAtom.contents.noun
      if (noun && !mite.lastAtom.contents.head) {
        if (!via ||
            !via.primaries.find { it.contents.noun == noun.lightVar }) {
          return ParsingState.EMPTY
        }
      }

      def parentState = state.findState(mite, 'head')
      return parentState ?: state.findState(mite.firstAtom)?.prevState
    }
  }
}
