package cons3

import static cons3.RussianConstructions.verbHolder

/**
 * @author peter
 */
class Util {

  static Integer parseNumber(String word) {
    if (word == null || word.length() == 0 || !Character.isDigit(word.charAt(0))) {
      return null
    }

    try {
      return Integer.parseInt(word)
    } catch (NumberFormatException ignore) {
      return null
    }
  }

  static <T> List<T> lcs(List<T> l1, List<T> l2, Function2<T,T,Boolean> eq) {
    if (!l1 || !l2) return []

    int[][] table = new int[l1.size()][l2.size()]
    for (i in 0..<l1.size()) {
      for (j in 0..<l2.size()) {
        int max = 0;
        if (i > 0 && table[i-1][j] > max) max = table[i-1][j]
        if (j > 0 && table[i][j-1] > max) max = table[i][j-1]
        if (eq(l1[i], l2[j])) {
          int prev = i > 0 && j > 0 ? table[i-1][j-1] : 0
          if (prev + 1 > max) max = prev + 1
        }
        table[i][j] = max
      }
    }

    def result = [null] * table[-1][-1]
    int i = l1.size() - 1
    int j = l2.size() - 1
    int k = result.size() - 1
    while (k >= 0) {
      if (i > 0 && table[i-1][j] == table[i][j]) {
        i--
      } else if (j > 0 && table[i][j-1] == table[i][j]) {
        j--
      } else {
        assert eq(l1[i], l2[j])
        result[k] = l1[i]
        k--
        i--
        j--
      }
    }
    return result
  }

  static <T> boolean intersects(Collection<T> set1, Collection<T> set2) {
    if (set2.size() < set1.size()) {
      def temp = set1; set1 = set2; set2 = temp;
    }
    if (!(set2 instanceof Set)) {
      set2 = new HashSet<T>(set2)
    }
    for (x in set1) {
      if (x in set2) {
        return true
      }
    }
    return false
  }

  static <T> LinkedHashSet<T> intersect(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.retainAll(new HashSet<T>(set2))
    return ts
  }

  static <T> LinkedHashSet<T> minus(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.removeAll(set2)
    return ts
  }

  static Construction commaSurrounded(Construction cxt) {
    cxt.screeningMites { mite, screen ->
      if (mite.contents.comma1 && !mite.contents.content) {
        return screen.hideAll()
      }
      if (mite.contents.content) {
        if (mite.contents.comma2) {
          screen = screen.hideAll()
        }
        def firstAtom = mite.firstAtom
        if (firstAtom?.contents?.comma1) {
          return screen.showEverything(screen.before.node.findNode(firstAtom).prevState)
        }
      }
      return screen
    }.enrichingMites { mite, contribution, state ->
      def newComma = contribution.find { it.cxt == cxt && it.contents.comma1 && it.contents.head }
      if (newComma) {
        if (mite.contents.content && !mite.contents.comma2) {
          def newVerb = new Mite(verbHolder, head:newComma.contents.head)
          def result = [mite.unify(new Mite(cxt, comma2:true, head:newComma.contents.head)), newVerb]
          if (mite.contents.head) {
            def firstAtom = mite.firstAtom
            if (firstAtom.contents?.comma1) {
              result.addAll(newVerb.unifyWherePossible(state.node.findNode(firstAtom)?.prevState?.visibleMites?.get(verbHolder) ?: [], false))
            }
          }
          return result
        }
        return []
      }
      return mite.unifyWherePossible(contribution)
    }
  }
}
