package cons3
import static cons3.Construction.cxt
import static cons3.RussianConstructions.posleGen
import static cons3.RussianConstructions.preposition
import static cons3.RussianConstructions.ransheGen
/**
 * @author peter
 */
class Util {

  static Integer parseNumber(String word) {
    if (word == null || word.length() == 0 || !Character.isDigit(word.charAt(0))) {
      return null
    }

    try {
      return Integer.parseInt(word)
    } catch (NumberFormatException ignore) {
      return null
    }
  }

  static <T> List<T> lcs(List<T> l1, List<T> l2, Function2<T,T,Boolean> eq) {
    if (!l1 || !l2) return []

    int[][] table = new int[l1.size()][l2.size()]
    for (i in 0..<l1.size()) {
      for (j in 0..<l2.size()) {
        int max = 0;
        if (i > 0 && table[i-1][j] > max) max = table[i-1][j]
        if (j > 0 && table[i][j-1] > max) max = table[i][j-1]
        if (eq(l1[i], l2[j])) {
          int prev = i > 0 && j > 0 ? table[i-1][j-1] : 0
          if (prev + 1 > max) max = prev + 1
        }
        table[i][j] = max
      }
    }

    def result = [null] * table[-1][-1]
    int i = l1.size() - 1
    int j = l2.size() - 1
    int k = result.size() - 1
    while (k >= 0) {
      if (i > 0 && table[i-1][j] == table[i][j]) {
        i--
      } else if (j > 0 && table[i][j-1] == table[i][j]) {
        j--
      } else {
        assert eq(l1[i], l2[j])
        result[k] = l1[i]
        k--
        i--
        j--
      }
    }
    return result
  }

  static <T> boolean intersects(Collection<T> set1, Collection<T> set2) {
    if (set2.size() < set1.size()) {
      def temp = set1; set1 = set2; set2 = temp;
    }
    if (!(set2 instanceof Set)) {
      set2 = new HashSet<T>(set2)
    }
    for (x in set1) {
      if (x in set2) {
        return true
      }
    }
    return false
  }

  static <T> LinkedHashSet<T> intersect(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.retainAll(new HashSet<T>(set2))
    return ts
  }

  static <T> LinkedHashSet<T> minus(Collection<T> set1, Collection<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.removeAll(set2)
    return ts
  }

  static Construction commaSurrounded(Construction cxt) {
    cxt.
            enrichingMites { mite, contribution, state -> handleCommaEnrichments(mite, contribution) }.
            structural { mite, state, via, up -> getPrevStateForCommaSurrounded(mite, state)
    }
  }

  static List<ParsingState> getPrevStateForCommaSurrounded(Mite mite, ParsingState state) {
    if (mite.contents.comma1 && !mite.contents.content) {
      return [ParsingState.EMPTY]
    }
    if (mite.contents.content) {
      def firstAtom = mite.firstAtom
      if (firstAtom?.contents?.comma1) {
        def beforeState = state.findState(firstAtom)
        def beforeComma = beforeState.prevState?.hierarchy
        if (beforeComma) {
          return [beforeState] + beforeComma
        }
      }
    }
    return null
  }

  static List<Mite> handleCommaEnrichments(Mite mite, List<Mite> contribution) {
    boolean wantContent = mite.contents.comma1 && !mite.contents.content
    boolean wantComma2 = mite.contents.content && !mite.contents.comma2
    return mite.unifyWherePossible(contribution.findAll {
      it.cxt == mite.cxt &&
      (wantContent && it.contents.content ||
       wantComma2 && it.contents.comma2)
    })
  }

  static Construction commonCase(String name) {
    cxt(name, ['+noun', '*head']) { ParsingState state, Map args ->
      state
    }.structural { mite, state, via, up ->
      if (up) {
        def headState = state.findState(mite, 'head')
        if (headState) {
          if (headState.ownMites.find { it.cxt == preposition }) {
            return [headState] + headState.prevState.hierarchy
          }
          return headState.hierarchy
        }
        return null
      }
      return state.findState(mite.firstAtom)?.prevVisibleState?.hierarchy
    }.enrichingMites { mite, contribution, state ->
      if (contribution.find { it.cxt == preposition || it.cxt in [ransheGen, posleGen] && it.contents.noun && !it.contents.head }) {
        return []
      }
      if (mite.contents.inferred) {
        return []
      }
      mite.unifyWherePossible(contribution)
    }
  }

  static Construction emptyCxt(String name) {
    cxt(name, ['X']) { state, args -> state }
  }
  static Construction commonPrep(String prep, Construction caze) {
    cxt(prep + caze.name.capitalize(), ['+noun', '*head']) { ParsingState state, Map args ->
      state
    }.structural { mite, state, via, up ->
      def parentState = state.findState(mite, 'head')
      return up ? parentState?.hierarchy : state.findState(mite.firstAtom)?.prevState?.hierarchy
    }
  }

  static Construction commonArg(String name, String rel) {
    cxt(name + rel.capitalize(), ['+noun', '*head']) { ParsingState state, Map args ->
      def nf = ((Variable) args.noun).frame(state.chart)
      nf.type || nf.s('name') ? state.assign(args.head, rel, args.noun) : state
    }
  }
}
