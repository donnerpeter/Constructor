package cons3

import groovypp.concurrent.FList

/**
 * @author peter
 */
class Util {

  static Integer parseNumber(String word) {
    try {
      return Integer.parseInt(word)
    } catch (NumberFormatException e) {
      return null
    }
  }

  static <T> List<T> lcs(FList<T> l1, FList<T> l2, Function2<T,T,Boolean> eq) {
    return lcs(l1.collect {it} as List, l2.collect {it} as List, eq)
  }
  static <T> List<T> lcs(List<T> l1, List<T> l2, Function2<T,T,Boolean> eq) {
    if (!l1 || !l2) return []

    int[][] table = new int[l1.size()][l2.size()]
    for (i in 0..<l1.size()) {
      for (j in 0..<l2.size()) {
        int max = 0;
        if (i > 0 && table[i-1][j] > max) max = table[i-1][j]
        if (j > 0 && table[i][j-1] > max) max = table[i][j-1]
        if (eq(l1[i], l2[j])) {
          int prev = i > 0 && j > 0 ? table[i-1][j-1] : 0
          if (prev + 1 > max) max = prev + 1
        }
        table[i][j] = max
      }
    }

    def result = [null] * table[-1][-1]
    int i = l1.size() - 1
    int j = l2.size() - 1
    int k = result.size() - 1
    while (k >= 0) {
      if (i > 0 && table[i-1][j] == table[i][j]) {
        i--
      } else if (j > 0 && table[i][j-1] == table[i][j]) {
        j--
      } else {
        assert eq(l1[i], l2[j])
        result[k] = l1[i]
        k--
        i--
        j--
      }
    }
    return result
  }

  static <T> Set<T> intersect(Set<T> set1, Set<T> set2) {
    def ts = new LinkedHashSet<T>(set1)
    ts.retainAll(set2)
    return ts
  }
}
