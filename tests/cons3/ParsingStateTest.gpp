package cons3;

import junit.framework.TestCase

/**
 * @author peter
 */
public class ParsingStateTest extends TestCase {
  Construction ac1 = attrCxt('ac1')
  Construction ac2 = attrCxt('ac2')
  Construction ec2 = emptyCxt('ec2')
  Construction ec3 = emptyCxt('ec3')
  Construction myAcc = Construction.cxt('myAcc', ['+head', 'noun']) { state, args -> state.assign(args.head, 'arg2', args.noun) }
  Construction myNom = Construction.cxt('myNom', ['+head', 'noun']) { state, args -> state.assign(args.head, 'arg1', args.noun) }
  Tokens t = new Tokens()

  Construction emptyCxt(String name) {
    return Construction.cxt(name, ['head']) { state, args -> state }
  }

  Construction attrCxt(String name) {
    return Construction.cxt(name, ['head']) { state, args ->
      for (String key in args.keySet() - 'head' - 'xor') {
        state = state.assign(args.head, key, args[key])
      }
      state
    }
  }

  public void testUnify() {
    def state = new ParsingState().apply((ac1):[head:new Variable(), a1:'v1']).apply((ac1):[head:new Variable().lightVar, a2:'v2'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'v2' == frame.s('a2')
  }

  public void testPreferJustSupportedConstructions() {
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ec3):[head:'z', xor:t.b], (ac1):[xor:t.b])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
  }

  public void testDontAbandonActiveMitesWhenNotMergingWithThem() {
    Construction c3 = Construction.cxt('ec3', ['head']) { state, args -> state }
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ac1):[a2:'xxx']).
            apply((c3):[head:'z'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'xxx' == frame.s('a2')
  }

  public void testDontAbandonActiveMitesWhenAddingExistingMite() {
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ac1):[a2:'xxx']).
            apply((ac1):[a1:'v1'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'xxx' == frame.s('a2')
  }

  public void testReviveEarlierCompetitorsWhenChoosingABetterMite() {
    def head = new Variable()
    def noun1 = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:noun1, xor:t.a], (ec2):[head:head, xor:t.b], (myNom):[noun:noun1, xor:t.ab]).
            apply((myAcc):[head:head], (myNom):[head:head]).
            apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert frame.f('arg1')
    assert frame.f('arg1') != frame.f('arg2')
  }

  public void testChooseLatterAlternativeForRevival() {
    def head = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:new Variable(), xor:t.a], (ec2):[head:head, xor:t.b], (ac1):[head:head, xor:t.ab, a1:'v1']).
            apply((myAcc):[head:head], (ac1):[a2:'zzz']).
            apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert 'v1' == frame.s('a1')
    assert 'zzz' == frame.s('a2')
  }

  public void testPreferInactiveConstructionsWhenDisplacing() {
    def head = new Variable()
    def noun1 = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:noun1, xor:t.a], (ec2):[head:head, xor:t.a], (myNom):[noun:noun1, xor:t.a]).
            apply((myAcc):[head:head], (ec2):[head:new Variable()], (myNom):[head:head]).
            apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert frame.f('arg1')
    assert frame.f('arg1') != frame.f('arg2')
  }

  public void testPreferFirst() {
    def head = new Variable()
    def state = new ParsingState().
            apply((ac1):[head:head, a1:'42'], (ec2):[head:head]).
            apply((ac1):[a2:'239', xor:t.b], (ec2):[xor:t.b])
    def frame = state.chart.frames[0]
    assert frame.s('a1') == '42'
    assert frame.s('a2') == '239'
  }

  public void testPreferRecentMites() {
    def state = new ParsingState().
            apply((ac1):[head:new Variable(), a1:'42']).
            apply((ac1):[head:new Variable(), a1:'239'])
    assert state.chart.frames.find { it.s('a1') == '239' }
  }

  public void testDontPreferOldMitesJustBecauseTheirConstructionUpdated() {
    def head = new Variable()

    def state = new ParsingState().
            apply((ec2):[xor:t.ab], (ac1):[head:head, xor:t.a], (ac2):[head:head]).
            apply((ac1):[xtype:'byAc1']).
            apply((ac2):[rel:'AFTER', xor:t.d], (ec2):[xor:t.d])

    def frame = state.chart.frames[0]
    assert frame.s('xtype') == 'byAc1'
    assert frame.s('rel') == 'AFTER'
  }

  public void testOldActivePriorityMatters() {
    def head = new Variable()

    def state = new ParsingState().
            apply((ac1):[head:head], (ac2):[head:head]).
            apply((ac2):[rel:'2', xor:t.d], (ac1):[rel:'1', xor:t.d])
    def frame = state.chart.frames[0]
    assert frame.s('rel') == '1'
  }

  public void testPreferLessActiveMites() {
    def head = new Variable()

    def state = new ParsingState().
            apply((ac1):[head:head], (ac2):[head:head]).
            apply((ac1):[rel:'1', xor:t.d], (ac2):[rel:'2', xor:t.ad], (ec2):[xor:t.a])
    def frame = state.chart.frames[0]
    assert frame.s('rel') == '2'
  }

  public void testRestoreLatestPossibleMite() {
    def head = new Variable()

    def state = new ParsingState().
            apply((ac1):[head:head, xor:t.e]).
            apply((ac1):[rel:'1', xor:t.d]).
            apply((ac1):[rel:'2', xor:t.a], (ac2):[head:head, xor:t.a])
            state = state.apply((ac2):[attr:'val'])
    def frame = state.chart.frames[0]
    assert frame.s('attr') == 'val'
    assert frame.s('rel') == '1'
  }

  public void testOnlyOneHardVariable() {
    def state = new ParsingState().
            apply((ac1):[head:new Variable(), a:'b']).
            apply((ac1):[rel:'1', head:new Variable().lightVar]).
            apply((ac1):[attr:'2', head:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.s('attr') == '2'
    assert !frame.s('a')
    assert frame.s('rel') == '1'
  }

  public void testChain() {
    def vars = [new Variable(), new Variable(), new Variable()]
    def state = new ParsingState().
            apply((myAcc):[head:vars[0]]).
            apply([myAcc(noun:vars[1]), myAcc(head:vars[1])]).
            apply([myAcc(noun:vars[2]), myAcc(head:vars[2])])
    def frame = state.chart.frames[0]
    assert frame.var == vars[0]
    assert frame.f('arg2')?.var == vars[1]
    assert frame.f('arg2').f('arg2')?.var == vars[2]
  }

  public void testHeadHidesPrecedingArguments() {
    def var = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:new Variable()], (ac1):[hidden:'true'], (myNom):[head:var]).
            apply((myAcc):[head:new Variable()]).
            apply((ac1):[head:var, visible:'true'], (myNom):[noun:new Variable()])
    def frame = state.chart.frames.find { it.s('visible') == 'true' }
    assert !frame.s('hidden')
    assert !frame.s('arg1')

  }

}
