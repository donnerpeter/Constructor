package cons3;

import junit.framework.TestCase

/**
 * @author peter
 */
public class ParsingStateTest extends TestCase {
  Construction ac1 = attrCxt('ac1')
  Construction ac2 = attrCxt('ac2')
  Construction ec2 = emptyCxt('ec2')
  Construction ec3 = emptyCxt('ec3')
  Construction myAcc = Construction.cxt('myAcc', ['+head', 'noun']) { state, args -> state.assign(args.head, 'arg2', args.noun) }
  Construction myNom = Construction.cxt('myNom', ['+head', 'noun']) { state, args -> state.assign(args.head, 'arg1', args.noun) }
  Tokens t = new Tokens()

  Construction emptyCxt(String name) {
    return Construction.cxt(name, ['head']) { state, args -> state }
  }

  Construction attrCxt(String name) {
    return Construction.cxt(name, ['head']) { state, args ->
      for (String key in args.keySet() - 'head' - 'xor') {
        state = state.assign(args.head, key, args[key])
      }
      state
    }
  }

  public void testUnify() {
    def state = new ParsingState().apply((ac1):[head:new Variable(), a1:'v1']).apply((ac1):[head:new Variable().lightVar, a2:'v2'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'v2' == frame.s('a2')
  }

  public void testPreferJustSupportedConstructions() {
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ec3):[head:'z', xor:t.b], (ac1):[xor:t.b])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
  }

  public void testDontAbandonActiveMitesWhenNotMergingWithThem() {
    Construction c3 = Construction.cxt('ec3', ['head']) { state, args -> state }
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ac1):[a2:'xxx']).
            apply((c3):[head:'z'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'xxx' == frame.s('a2')
  }

  public void testDontAbandonActiveMitesWhenAddingExistingMite() {
    def state = new ParsingState().
            apply((ec2):[head:'z', xor:t.a], (ac1):[head:new Variable(), xor:t.a, a1:'v1']).
            apply((ac1):[a2:'xxx']).
            apply((ac1):[a1:'v1'])
    def frame = state.chart.frames[0]
    assert 'v1' == frame.s('a1')
    assert 'xxx' == frame.s('a2')
  }

  public void testReviveEarlierCompetitorsWhenChoosingABetterMite() {
    def head = new Variable()
    def noun1 = new Variable()
    def state = new ParsingState()
    state = state.apply((myAcc):[noun:noun1, xor:t.a], (ec2):[head:head, xor:t.b], (myNom):[noun:noun1, xor:t.ab])
    state = state.apply((myAcc):[head:head], (myNom):[head:head])
    state = state.apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert frame.f('arg1')
    assert frame.f('arg1') != frame.f('arg2')
  }

  public void testChooseLatterAlternativeForRevival() {
    def head = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:new Variable(), xor:t.a], (ec2):[head:head, xor:t.b], (ac1):[head:head, xor:t.ab, a1:'v1']).
            apply((myAcc):[head:head], (ac1):[a2:'zzz']).
            apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert 'v1' == frame.s('a1')
    assert 'zzz' == frame.s('a2')
  }

  public void testPreferInactiveConstructionsWhenDisplacing() {
    def head = new Variable()
    def noun1 = new Variable()
    def state = new ParsingState()
    state = state.apply((myAcc):[noun:noun1, xor:t.a], (ec2):[head:head, xor:t.a], (myNom):[noun:noun1, xor:t.a])
    state = state.apply((myAcc):[head:head], (ec2):[head:new Variable()], (myNom):[head:head])
    state = state.apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert frame.f('arg1')
  }

  public void testPreferFirst() {
    def head = new Variable()
    def state = new ParsingState().
            apply((ac1):[head:head, a1:'42'], (ec2):[head:head]).
            apply((ac1):[a2:'239', xor:t.b], (ec2):[xor:t.b])
    def frame = state.chart.frames[0]
    assert frame.s('a1') == '42'
    assert frame.s('a2') == '239'
  }

  public void testPreferRecentMites() {
    def state = new ParsingState().
            apply((ac1):[head:new Variable(), a1:'42']).
            apply((ac1):[head:new Variable(), a1:'239'])
    assert state.chart.frames.find { it.s('a1') == '239' }
  }

  public void testDontPreferOldMitesJustBecauseTheirConstructionUpdated() {
    def head = new Variable()

    def state = new ParsingState()
    state = state.apply((ec2):[xor:t.a], (ac1):[head:head, xor:t.a], (ac2):[head:head])
    state = state.apply((ac1):[xtype:'byAc1', xor:t.b])
    state = state.apply((ac2):[rel:'AFTER', xor:t.d], (ec2):[xor:t.d])

    def frame = state.chart.frames[0]
    assert frame.s('xtype') == 'byAc1'
    assert frame.s('rel') == 'AFTER'
  }

  public void testOldActivePriorityMatters() {
    def head = new Variable()

    def state = new ParsingState()
    state = state.apply((ac1):[head:head], (ac2):[head:head])
    state = state.apply((ac2):[rel:'2', xor:t.d], (ac1):[rel:'1', xor:t.d])
    def frame = state.chart.frames[0]
    assert frame.s('rel') == '1'
  }

  public void testPreferLessActiveMites() {
    def head = new Variable()
    def daughter = new Variable()

    def state = new ParsingState().
            apply((ac1):[rel:'1'], (myAcc):[noun:daughter]).
            apply((ac1):[head:head, xor:t.d], (myAcc):[head:head, xor:t.ad], (ec2):[xor:t.a])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert !frame.s('rel')
  }

  public void testRestoreLatestPossibleMite() {
    def head = new Variable()

    def state = new ParsingState()
    state = state.apply((ac1):[head:head, xor:t.e])
    state = state.apply((ac1):[rel:'1', xor:t.d])
    state = state.apply((ac1):[rel:'2', xor:t.a], (ac2):[head:head, xor:t.a])
    state = state.apply((ac2):[attr:'val'])
    def frame = state.chart.frames[0]
    assert frame.s('attr') == 'val'
    assert frame.s('rel') == '1'
  }

  public void testOnlyOneHardVariable() {
    def var0 = new Variable()
    def var1 = new Variable()
    def state = new ParsingState()
    state = state.apply((ac1):[head:var0, a:'b'])
    state = state.apply((ac1):[rel:'1', head:new Variable().lightVar])
    state = state.apply((ac1):[attr:'2', head:var1])

    def frame0 = var0.frame(state.chart)
    def frame1 = var1.frame(state.chart)
    assert frame0.s('a') == 'b'

    assert frame1.s('rel') == '1'
    assert frame1.s('attr') == '2'
  }

  public void testChain() {
    def vars = [new Variable(), new Variable(), new Variable()]
    def state = new ParsingState()
    state = state.apply((myAcc):[head:vars[0]])
    state = state.apply([myAcc(noun:vars[1]), myAcc(head:vars[1])])
    state = state.apply([myAcc(noun:vars[2]), myAcc(head:vars[2])])
    def frame = state.chart.frames[0]
    assert frame.var == vars[0]
    assert frame.f('arg2')?.var == vars[1]
    assert frame.f('arg2').f('arg2')?.var == vars[2]
    assert state.active.findAll { it.cxt == myAcc }.size() == 3
  }

  public void _testHeadHidesPrecedingArguments() {
    def var = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:new Variable()], (ac1):[hidden:'true'], (myNom):[head:var]).
            apply((myAcc):[head:new Variable()]).
            apply((ac1):[head:var, visible:'true'], (myNom):[noun:new Variable()])
    def frame = state.chart.frames.find { it.s('visible') == 'true' }
    assert !frame.s('hidden')
    assert !frame.s('arg1')

  }

  public void testPreferMergedWhenDisplacing() {
    def var = new Variable()
    def head = new Variable()
    def state = new ParsingState()
    state = state.apply((myAcc):[noun:var, xor:t.a], (myNom):[noun:var, xor:t.a, agr:'b'], (ac1):[comp:'true', xor:t.a])
    state = state.apply((myAcc):[head:head], (myNom):[head:head, agr:'a'], (ac1):[head:head])
    state = state.apply((myAcc):[noun:new Variable()])
    def frame = state.chart.frames.find { it.s('comp') == 'true' }
    assert frame.f('arg2')
    assert !frame.f('arg1')
  }

  public void testDispreferNotMerged() {
    def head = new Variable()
    def state = new ParsingState().
            apply((myAcc):[noun:new Variable(), xor:t.a], (ac1):[xor:t.b, quest:'true'], (ac2):[xor:t.ab, comp:'true']).
            apply((ac1):[head:head, xor:t.c], (ac2):[head:head, xor:t.c])
    def frame = state.chart.frames[0]
    assert frame.s('comp') == 'true'
  }

  public void testBeConservativeAboutMerged() {
    def head = new Variable()
    def noun = new Variable()
    def state = new ParsingState()
    state = state.apply((ec2):[head:head, xor:t.ac], (ec3):[xor:t.c], (myAcc):[xor:t.a, head:head], (myNom):[head:head])
    state = state.apply((myAcc):[noun:new Variable()])
    state = state.apply((ec2):[xxx:'yyy', xor:t.b], (myNom):[noun:noun, xor:t.b], (ac1):[attr:'val'])
    def frame = state.chart.frames[0]
    assert frame.f('arg2')
    assert frame.f('arg1')
  }

  public void testNewMitesLeavingNoChoice() {
    def head = new Variable()
    def var = new Variable()
    def state = new ParsingState()
    state = state.apply((myAcc):[head:head], (myNom):[head:head])
    state = state.apply((myAcc):[noun:var, xor:t.a], (myNom):[noun:var, xor:t.a])
    state = state.apply((myNom):[agr:'aaa'])
    def frame = state.chart.frames[0]
    assert frame.f('arg1')
    assert !frame.f('arg2')
  }

  public void testThatMotherLovesDaughter() {
    def var0 = new Variable()
    def var1 = new Variable()
    def head = new Variable()
    def var2 = new Variable()
    def state = new ParsingState()
    state = state.apply((myAcc):[noun:var0, xor:t.a], (myNom):[noun:var0, xor:t.a], (ec2):[xor:t.a])
    state = state.apply((myNom):[noun:var1, xor:t.c], (ac1):[head:var1, type:'mother'])
    state = state.apply((myNom):[head:head], (myAcc):[head:head])
    state = state.apply((myNom):[noun:var2, xor:t.b], (myAcc):[noun:var2, xor:t.b], (ac2):[head:var2, type:'daughter'])
    def frame = head.frame(state.chart)
    assert frame.f('arg1')?.type == 'mother'
    assert frame.f('arg2')?.type == 'daughter'
  }

  public void testNoMiteDuplication() {
    def state = new ParsingState()
    state = state.apply((ec2):[foo:2, bar:3], (ec3):[foo:2])
    assert state.visibleMites[ec2].size() == 1
    assert state.visibleMites[ec3].size() == 1

    state = state.apply((ec2):[foo:2], (ec3):[foo:2])
    assert state.visibleMites[ec2].size() == 1
    assert state.visibleMites[ec3].size() == 1
  }

}
